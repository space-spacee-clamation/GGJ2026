# 游戏核心循环与系统 BaseSpec（V0）

> **项目背景**：本项目为 **48 小时 Game Jam** 作品。核心目标是 **可玩闭环** 与 **效果落地**。  
> **关键取舍**：扩展性、可维护性、通用化为次要目标；**不要为了“架构优雅/可维护”额外增加复杂度**。

---

## 0. 本文档的地位（强约束）

- **执行优先级**：后续所有「核心玩法 / 经营合成 / 战斗 / 掉落」相关实现必须以本文档（以及其后续版本）为准。  
- **先文档后实现**：任何代码修改前，必须先输出一份「对需求的理解与实现思路」的小文档给策划/负责人确认；收到修正意见后再动手实现。  
- **不做“顺手优化”**：除非文档明确要求，否则不做重构、不更换框架、不引入大型第三方系统（例如复杂行为树/GOAP 等）。

---

## 1. 48 小时 Game Jam 的工程目标与边界

### 1.1 目标（必须做到）

- **可玩性优先**：经营合成可操作、战斗能推进、有胜负、有掉落回馈，玩家能“感受到成长”。  
- **闭环完整**：至少具备最小闭环：经营/合成 → 战斗 → 胜负结算 → 掉落材料 → 回到经营/合成。  
- **可调参**：关键数值（角色/敌人属性、面具法力值、材料消耗与效果、掉落）要能快速调整（Inspector / ScriptableObject 均可，以省时间为第一目标）。

### 1.2 非目标（明确不做）

- **不追求高度扩展**：不为未来“可能会有几十种材料/敌人/面具/技能”预先搭一套复杂通用框架。  
- **不追求复杂可维护**：不引入过多抽象层、事件总线、反射注册、依赖注入等。  
- **不追求网络同步**：默认单机本地逻辑。

---

## 1.3 已导入插件（核心约定）

> 本节用于“统一口径”：哪些插件可以用、用于什么目的、避免怎么用。

### 1.3.1 DOTween（允许使用）

- **用途**：用于实现简单可靠的 Tween（例如音量淡入淡出、UI 动画、轻量动效）。  
- **原则**：优先用 DOTween 替代手写 Update 插值，减少 bug 与时间成本。  
- **限制**：不为 DOTween 搭建复杂通用封装；需要时在具体 Manager/组件里直接调用即可。

### 1.3.2 Odin Inspector（允许使用）

- **用途**：用于快速绘制调试面板/工具窗口/Inspector 按钮（例如音频试音、关卡调参）。  
- **原则**：工具性代码以“省时间”为第一目标，允许与业务逻辑放在同一 Manager 中（Jam 取舍）。  
- **限制**：不引入复杂 Editor 架构；不做大而全的自定义编辑器系统。

---

## 2. 生命周期与初始化规范（硬性规则）

### 2.1 单例/管理类初始化规则

- **唯一入口**：所有管理类与各种单例 **只能在 `GameManager` 中实例化与持有引用**。  
- **Awake 阶段**：`GameManager.Awake()` 中完成 **所有单例初始化**（创建对象、赋值引用、基础依赖注入）。  
- **Start 阶段**：`GameManager.Start()` 中完成 **其它内容初始化**（读取关卡、生成敌人、开局状态、UI 初始化等）。  
- **严禁分散初始化**：任何单例不得在自己的 `Awake`/`Start` 中自行 `Instance = this` 并承担“全局初始化职责”。（可以在自身 Awake 做本地组件缓存，但不得决定全局时序）

### 2.2 运行时创建与销毁

- **可控创建**：运行时生成的技能特效/投射物/临时对象必须由明确的“拥有者”负责创建与销毁（例如 SkillRunner/ProjectileManager）。  
- **销毁策略简单**：允许使用 `Destroy(gameObject, t)` 或简单对象池；优先保证稳定与省时间。  
- **失败可见**：关键路径必须有最小化日志/断言（例如技能找不到目标/缺少组件时给出清晰报错），避免 Game Jam 临场排查困难。

---

## 3. 核心玩法概述（V0）

> 本节定义本游戏是什么、核心循环是什么，以及经营与战斗两大系统如何通过“面具 + 材料”连接成闭环。

### 3.1 玩法一句话

- **模拟经营 + 自动战斗**：玩家在经营阶段用“材料”附加到“面具库”中任意面具上构筑效果；进入战斗后采用“速度条机制”自动推进，面具库全部生效；战斗结束掉落新材料，并结算持久增值写入玩家实际数值，回到经营阶段继续构筑。

### 3.2 核心循环（必须闭环）

- **经营/合成阶段**  
  - 玩家拥有一个**面具库（MaskLibrary）**，其中包含多个面具。  
  - 玩家当前会有一个“当前面具/展示面具（CurrentMask）”，与面具库中的其它面具 **差别仅在表现/UI**。  
  - 选择/获得材料（Material），附加到**当前面具**上（会消耗该面具法力值）。  
  - 若材料为“即时生效”，在附加阶段立即执行效果。  
  - 允许存在“恢复法力值”的功能（也是在附加阶段/经营阶段执行，且**恢复本身也是一种材料效果**）。  
- **战斗阶段（速度条自动战斗）**  
  - 流程：进入战斗 → 双方速度值按秒增长 → 达到场地速度阈值则触发攻击 → 循环 → 一方胜利触发回调。  
  - 每个环节前后都有回调，材料效果可在回调中介入修改。  
  - **战斗生效来源**：本次战斗中，**面具库内所有面具**（包含当前面具）都会持续生效（类似肉鸽道具库）。  
- **战后奖励阶段**  
  - 胜负结算后获得新材料（预制体 + 数量）。  
  - 本场使用/获得的面具会进入“面具库”，并在后续战斗持续生效。  
  - 回到经营/合成阶段，开始下一轮构筑。

### 3.3 关键对象与术语（统一口径）

- **面具（Mask）**  
  - **Mask 静态配置（配置）**：面具基础法力值与描述等静态配置（V0 落地为 `MaskObj` 内嵌的配置数据，运行时不修改）。  
  - **MaskObj（实例）**：运行时面具对象（持有当前法力值、已附加材料链表、对外提供“注入上下文”能力）。  
- **面具库（MaskLibrary）**  
  - 一个列表/集合，包含多个 `MaskObj`。  
  - **核心约束**：面具库中的所有面具会在后续战斗中持续生效（表现不同但逻辑一致）。  
- **当前面具（CurrentMask）**  
  - 当前展示/操作的面具（UI 表现焦点）；逻辑上与面具库中的其它面具一致。  
- **材料（Material）**（注意：存在“材料类”与“材料效果组件”的概念区分）  
  - **Material Prefab（预制体）**：每一个材料是一个预制体，挂有 `MaterialObj`（提供消耗等基础数据）与多个效果组件（实现接口并在对应阶段生效）。  
  - **即时生效**：在经营/附加阶段立即执行。  
  - **战斗过程生效**：在战斗流程回调/攻击处理链中介入效果。  
- **角色（Player）与敌人（Enemy）**  
  - 本项目约束：**玩家、敌人是一对一**（不会出现一对多 / 多对多战斗）；但**面具为多面具（面具库）**。  
  - 玩家全程只有一个实例（可使用单例），并存在“基础/实际/战斗”三层数值（见第 5 章与战斗文档）。

---

## 4. 经营/合成系统需求（材料 + 面具）

> 面具/材料系统的详细设计请参考：`Mask_System_Spec_V0.md`。

### 4.1 面具法力值（Mana）规则（必须）

- **基础法力值**：每个面具有一个基础法力值（来自配置）。  
- **消耗**：材料绑定会消耗法力值；每个材料的消耗由“材料类”提供。  
- **恢复**：存在“恢复法力值”的功能；恢复行为发生在**附加面具阶段（经营阶段）**，并且**恢复由材料效果驱动**（不存在金币/按钮等额外交互系统）。  
- **约束**：法力值不足时材料不得绑定（需有清晰失败反馈/日志/提示）。

### 4.2 材料绑定（Attach/Bind）流程（必须）

- **输入**：一个材料预制体（Material Prefab）。  
- **检查**：  
  - 是否是合法材料（存在“材料类”组件）。  
  - 法力值是否足够支付消耗。  
- **执行**：  
  - 扣除法力值。  
  - 将材料加入面具的已附加材料列表（运行时实例层面）。  
  - 若材料包含“即时生效”效果：在此阶段执行（见 4.3）。  
  - 触发材料绑定回调（供 UI/统计/其它效果使用）。  
- **输出**：绑定成功/失败结果与原因（便于 UI 提示与调试）。

### 4.3 即时生效材料（经营阶段效果）（必须）

即时生效材料在“附加面具阶段”执行，并且必须拿到“面具合成上下文”。

#### 4.3.1 合成上下文（BindContext）最小内容

- **面具实例**：当前 `MaskObj`。  
- **现有材料列表**：当前已附加材料的列表（绑定前/后按需求明确）。  
- **材料绑定回调**：允许即时生效材料在合适时机触发/订阅“绑定完成”的回调（例如链式反应、统计、刷新 UI）。  

> 说明：上下文是“只给即时材料在合成阶段使用”的数据包；不要让即时材料直接去找全局单例，尽量从上下文拿引用。

### 4.4 材料效果组件化（必须）

- **组合优先**：材料效果逻辑以“基础效果组件 + 组合”实现。  
- **实现方式**：使用 `MonoBehaviour` 类作为“材料效果组件”的功能载体；每个材料 Prefab 可以挂多个效果组件。  
- **边界**：  
  - 材料类负责“这个 Prefab 是什么材料 + 基础数据”。  
  - 材料效果组件负责“效果怎么发生（经营阶段/战斗阶段/修改数值）”。  
  - 不做复杂编辑器/DSL/反射注册。
- **触发顺序（链表规则）**：材料效果按“已附加材料列表（链表）顺序”依次触发/注入；当多个材料修改同一数据时，以链表顺序形成最终结果（V0 不额外引入优先级系统）。

---

## 5. 战斗系统需求（速度条自动战斗 + 回调注入）

> 战斗部分的详细设计与落地清单请参考：`Fight_System_Spec_V0.md`。

### 5.1 战斗流程（必须）

战斗为速度条自动战斗，固定流程：

- **进入战斗**：创建/准备战斗上下文；注入面具与材料效果（见 5.4）。  
- **触发攻击**：当某一方速度值达到场地速度阈值时，生成一次 `AttackInfo` → 处理器修改 → 结算伤害。  
- **循环**：直到一方胜利触发回调并退出战斗。  

### 5.2 回调点（必须，材料可注入）

每一个环节的**前后都有回调**，材料效果可以在回调中介入修改。V0 最小建议回调集合如下（可按实现合并，但语义需保留）：

- **战斗级**  
  - `OnBattleEnter`：进入战斗时（回合循环开始前）。  
  - `OnBattleStart`：战斗正式开始（可用于“开战减敌攻”等）。  
  - `OnBattleEnd`：战斗结束（胜负已判定）。  
  - `OnVictory` / `OnDefeat`：胜负结果回调。  
- **攻击级（最关键）**  
  - `OnBeforePlayerAttack(AttackInfo info)` / `OnAfterPlayerAttack(AttackInfo info)`  
  - `OnBeforeEnemyAttack(AttackInfo info)` / `OnAfterEnemyAttack(AttackInfo info)`  

> 说明：材料效果应优先通过这些回调修改上下文与 `AttackInfo`，而不是在战斗系统内部塞大量 if/else。

---

### 5.3 AttackInfo（每次攻击创建）（必须）

`AttackInfo` 是每一次攻击都会创建的信息类，至少包含：

- **BaseValue**：这次攻击基础的值（来源于攻击者属性/技能等）。  
- **CritChance**：这次攻击的暴击概率。  
- **CritMultiplier**：这次攻击的暴击乘数。  
- **RawAttack**：这次攻击的实际攻击（**未结算暴击**的攻击，主要用于“处理器修改”）。  

> 约束：`AttackInfo` 是“本次攻击的可变数据载体”，材料/处理器修改它来影响结算。

### 5.4 AttackInfo 处理器（玩家/敌人各一个）（必须）

战斗上下文中需要存在攻击 `AttackInfo` 处理器：

- **玩家攻击处理器**：仅处理“玩家发起的攻击”的 `AttackInfo` 修改链。  
- **敌人攻击处理器**：仅处理“敌人发起的攻击”的 `AttackInfo` 修改链。  

处理器职责：

- 接收原始 `AttackInfo`。  
- 按顺序调用：材料效果注入的修改（**按材料链表顺序**）、以及战斗系统自身需要的调整（如基础结算规则）。  
- 输出用于最终伤害结算的 `AttackInfo`（可为同一个对象被修改后返回）。

> 说明：分成两套处理器能避免“玩家/敌人规则不同”时到处写分支。

---

### 5.5 战斗上下文（BattleContext）（必须）

材料效果需要拿到战斗上下文进行修改。战斗上下文至少包含：

- **玩家实例**：Player（运行时实例）。  
- **敌人实例**：Enemy（运行时实例）。  
- **面具库**：MaskLibrary（运行时面具列表）。  
- **当前面具**：CurrentMask（可选，仅用于表现/UI，不影响“全库生效”约束）。  
- **回调集合**：第 5.2 中提到的所有回调入口（允许以事件/委托集合形式存在）。  
- **攻击处理器**：玩家攻击处理器 + 敌人攻击处理器。  

> 约束：上下文应由战斗系统创建并分发；材料效果不直接自行构造上下文。

### 5.6 战斗前注入顺序（必须）

- **进入战斗前**：按固定顺序把“面具库内所有面具”（包含当前面具）依次注入 `BattleContext`：  
  - 面具顺序：以面具库列表顺序为准  
  - 材料顺序：每个面具内部按材料链表顺序  
  - 组件顺序：每个材料内部按组件遍历顺序  
- **之后**：战斗按回合正常推进即可（战斗系统不需要知道每个材料具体做什么）。

---

## 6. 配置与数据（强烈建议用 ScriptableObject）

> 本节解决“战斗敌人属性、角色属性、掉落材料、面具基础法力值”的可配置需求，并明确“配置数据不可被运行时修改”。

### 6.1 属性配置（必须）

- **角色属性配置（PlayerStatsConfig）**：只配置“基础数值（BaseStats）”（攻击、生命、防御、暴击、爆伤、速度等）。  
- **敌人属性配置（EnemyStatsConfig）**：同上。  

关键约束：

- **Config 是静态数据**：`ScriptableObject` / 配置类中的数值 **不参与实际计算的动态变更**。  
- **运行时战斗要改实例，不改配置**：实际计算需要修改“角色/敌人运行时实例”的数据，而不是修改 config 数据。

补充约束（玩家三层数值）：

- 玩家存在 **BaseStats / ActualStats / BattleStats** 三层数值。  
- 材料在战斗开始时只叠加到 BattleStats；战斗结束时再根据“持久增值收集”更新 ActualStats；不直接改 BaseStats。

### 6.2 掉落配置（必须）

掉落改为“材料池 + 幸运值 + 品质 + 掉落方法可替换”的机制：

- **幸运值（Luck）**：0~100 的整数（超出范围按 0/100 夹紧）。  
- **品质（MaterialQuality）**：枚举值 0~4（低→高），用于控制不同品质材料的掉落概率。  
- **材料池（MaterialPool）**：按品质分组的材料列表（每个条目引用材料 Prefab/MaterialObj，并可选权重）。  
- **掉落数量（DropCount）**：每次战斗结算时掉落的材料数量（整数，可配置）。  
- **材料库存（MaterialInventory）**：掉落材料先进入“材料库”，并在制造阶段由玩家选择绑定到面具上；绑定成功即从材料库消耗。  
- **保质期（ShelfLifeTurns）**：材料 Prefab 上配置的“回合数”。从获取开始，每经过一次“制造面具回合结束”，材料剩余回合数 -1；变为 0 时在本次结束时自动销毁，下一次制造阶段不可再用。已绑定到面具的材料不再参与材料库结算。  

#### 6.2.1 掉落方法接口（可替换）

在掉落位置增加一个抽象接口，便于后续替换算法：

```csharp
public interface IMaterialDropMethod
{
    // luck: 0~100
    // dropCount: 本次应掉落多少个材料（整数）
    IReadOnlyList<MaterialDropEntry> Roll(MaterialPool pool, int luck, int dropCount);
}
```

`MaterialDropEntry` 为 “MaterialPrefab + Count” 的记录结构（可合并同一 Prefab 的数量）。

#### 6.2.2 V0 简单掉落方法（先落地一个）

- 上限：`luck` 最大 100。  
- 机制：根据 luck 改变 5 个品质的概率分布；先抽品质，再从该品质的材料池中抽一个材料。  
- 若某品质池为空：可降级到更低品质，或回退到任意非空池（以实现为准，Jam 取舍）。

### 6.3 面具配置（必须）

- **面具基础法力值**：可配置（V0 落地为 `MaskObj.StaticConfig.BaseMana`，由 `MaskMakeManager` 按列表顺序生成）。  
- 其它：面具名称、描述。

补充：底板面具

- 每次制造面具回合，都会从一个“底板面具预制体”实例开始制作；`MaskMakeManager` 负责实例化底板，再应用本次配置并进入材料附加阶段。

---

## 7. 非功能需求（稳定性优先）

- **严格生命周期**：遵循第 2 章规则，避免初始化时序错误。  
- **容错**：缺组件/目标为空/配置缺失时必须安全失败（不崩溃），并输出可定位日志。  
- **性能足够即可**：避免明显的每帧 Find/GC；但不需要过度优化或建立复杂缓存系统。

---

## 8. 交付物清单（V0 期望）

- **经营/合成最小可玩**：可选择材料、可绑定到面具、法力值扣除与不足失败、即时材料能在合成阶段生效。  
- **战斗最小可玩**：按回合自动推进；攻击会生成 `AttackInfo` 并通过处理器结算；胜负可判定并触发回调。  
- **材料影响战斗**：至少 2 个“战斗过程生效”的材料效果组件能通过回调影响战斗（例如开战减敌攻、提高暴击、降低受到伤害等）。  
- **掉落闭环**：战斗结束获得材料（预制体 + 数量）并回到经营阶段。  
- **配置可调**：角色/敌人属性、掉落、面具法力值可通过 Inspector/SO 快速调整。

---

## 9. 实现前的“理解与思路文档”模板（必须先写、你确认后再动代码）

> 后续任何实现请求，我会先按这个模板输出，等待你修正/确认。

### 9.1 需求理解

- 需求模块：经营/合成 / 战斗 / 材料效果 / 配置 / UI（选填）  
- 目标行为：要新增/修改的具体玩法点（例如“开战降低敌人攻击”材料）  
- 触发时机：合成阶段即时 / 战斗回调点（具体到 5.2 的哪个回调）  
- 影响对象：玩家 / 敌人 / 面具 / AttackInfo / 回合流程  
- 结算规则：如何修改（加法/乘法/覆盖/限幅），是否可叠加，叠加上限  
- 失败处理：上下文缺失/配置缺失/法力值不足/列表为空等  

### 9.2 实现思路（尽量简单）

- 将新增/修改的脚本列表：  
- 生命周期与初始化（GameManager Awake/Start 中做什么）：  
- 关键数据字段（可调参）：  
- 注入点与顺序（BindContext / BattleContext / AttackInfo Processor）：  
- 预计风险点与规避：  

---

## 10. 已确认信息与开放问题

### 10.1 已确认（按你在文档中的回答）

- 经营阶段不存在商店/刷新/购买机制；材料获取途径只有战斗掉落；内容与掉落均为手动配置。  
- 存在“面具库（多面具）”机制：战斗结束后旧面具不会丢弃，而是进入面具库，并在后续战斗持续生效（类似肉鸽道具库）；当前面具与面具库面具差别仅在表现。  
- 法力值恢复是材料效果的一种；不存在金币或其它交互系统。  
- 材料效果按链表顺序触发（叠加/冲突以链表顺序得到最终结果）。

### 10.2 仍待确认（会影响实现细节）

- 战斗结算公式的基准：攻击/防御/暴击/爆伤如何计算（给一个最小可行公式即可）？



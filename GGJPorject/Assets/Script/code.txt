
// === GameManager.cs ===
using System.Collections.Generic;
using System.Threading;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using UnityEngine;
public class GameManager : MonoBehaviour
{
    public static GameManager I { get; private set; }

    private AudioManager audioManager => AudioManager.I;

    [SerializeField] private CanvasGroup bookCanvasGroup;
    [Header("Fight (Runtime Created)")]
    [SerializeField] private FightManager fightManager;

    [Header("Spawn (Runtime Created)")]
    [SerializeField] private MonsterSpawnSystem monsterSpawnSystem;

    [Header("Mask (Runtime Created)")]
    [SerializeField] private MaskMakeManager maskMakeManager;

    [Header("UI")]
    [SerializeField] private MakeMuskUI makeMuskUI;
    [SerializeField] public BattleUI battleUI;
    [Tooltip("黑屏 CanvasGroup（用于场景切换时的淡入淡出）。")]
    [SerializeField] private CanvasGroup blackScreen;
    [Tooltip("费用不足警告的 CanvasGroup（用于 fadeIn/fadeOut 动画）。")]
    [SerializeField] private CanvasGroup costWarningCanvasGroup;

    [Header("Mask Library (Runtime)")]
    [SerializeField] private Transform maskLibraryRoot;
    private readonly System.Collections.Generic.List<MaskObj> _maskLibrary = new();

    [Header("持久成长（未应用）")]
    [Tooltip("跨回合累积的成长值（从上次结算后开始累积，直到下次战斗结束应用）。")]
    private PlayerGrowthDelta _pendingGrowthDelta;

    /// <summary>
    /// 获取未应用的提升值（跨回合累积，从上次结算后开始累积，直到下次战斗结束应用）。
    /// </summary>
    public PlayerGrowthDelta PendingGrowthDelta => _pendingGrowthDelta;

    [Header("材料库存")]
    [SerializeField] private MaterialInventory materialInventory = new();
    [SerializeField] private Transform materialInventoryRoot;

    [Header("制造阶段（可选自动行为）")]
    [Tooltip("Jam 方便测试：进入制造回合时自动把库存材料尽量绑定到当前面具（按保质期优先）。")]
    [SerializeField] private bool autoBindInventoryOnMake = false;

    [Header("掉落配置（Jam 默认：纯代码，无 SO）")]
    [Tooltip("运行时生成的材料池（由 Resources/Mat 扫描得到）。Jam 默认不需要手动配置 MaterialPool SO。")]
    [SerializeField] private MaterialPool dropPool;
    [Tooltip("运行时创建的掉落方法（SO 实例，仅用于运行时；Jam 默认不需要创建 DropMethod 资产）。")]
    [SerializeField] private SimpleLuckMaterialDropMethod dropMethod;
    [SerializeField, Min(0)] private int dropCount = JamDefaultSettings.DropCountPerBattle;

    [Header("材料池/初始材料（Jam 默认：纯代码）")]
    [SerializeField] private string resourcesMatFolder = JamDefaultSettings.ResourcesMatFolder;
    [SerializeField, Min(0)] private int initialCommonMaterialCount = JamDefaultSettings.InitialCommonMaterialCount;
    private bool _initialMaterialsSpawned;

    [Header("面具 Sprite 配置")]
    [Tooltip("默认面具 Sprite（如果池为空或随机失败时使用）。")]
    [SerializeField] private Sprite defaultMaskSprite;
    [Tooltip("面具 Sprite 池（Compose 后随机选择）。")]
    [SerializeField] private List<Sprite> maskSpritePool = new();

    [Header("Flow")]
    [SerializeField] private bool autoRunLoop = false;

    [Header("流程控制（UniTask）")]
    [Tooltip("进入制造阶段后，是否自动视为玩家已完成制造（仅用于快速测试）。")]
    [SerializeField] private bool autoCompleteMakePhase = false;

    [Header("Jam 自动化/调试")]
    [SerializeField] private bool enableJamAutoFixes = true;
    [SerializeField] private bool enablePhaseDebugLogs = true;
    private int _roundIndex;

    private UniTaskCompletionSource<bool> _makePhaseTcs;
    private UniTaskCompletionSource<bool> _battleEndTcs;
    private CancellationToken _destroyToken;
    private bool _manualAdvanceInProgress;
    private Tween _costWarningTween; // 费用不足警告动画
    private readonly System.Threading.SemaphoreSlim _blackScreenTransitionGate = new(1, 1);
    private AudioKey? _currentMainBgm;

    private void Awake()
    {
        // Singleton bootstrap (Jam 简化：重复实例直接销毁)
        if (I != null && I != this)
        {
            Destroy(I.gameObject);
        }
        I = this;
        // 所有单例/管理类必须在此初始化（强约束）
        BootstrapAudio();
        BootstrapFight();
        BootstrapSpawn();
        BootstrapMask();
        BootstrapPlayer();
        BootstrapRuntimeRoots();
        _pendingGrowthDelta= new PlayerGrowthDelta();
        _destroyToken = this.GetCancellationTokenOnDestroy();

        if (enablePhaseDebugLogs)
        {
            Debug.Log("[GameManager] Awake 完成：系统 Bootstrap 完毕。");
        }
    }

    private void Start()
    {

        // Jam：自动构建材料池（用于掉落与开局发牌）。不依赖任何 SO 资产。
        BuildDropPoolFromResources();

        // Jam：自动化掉落配置（保证 dropMethod/dropCount 可用）
        EnsureDropConfigForJam();

        // Jam：开局发放默认数量的 Common 材质给玩家
        SpawnInitialCommonMaterialsIfNeeded();

        // Jam 容错：用临时测试补全未配置内容，保证流程可跑
        if (enableJamAutoFixes)
        {
            new JamTempFixer().Apply(this);
        }

        if (autoRunLoop)
        {
            RunMainLoopAsync().Forget();
        }
        SwitchMainBgm(AudioKey.Game_Shop_Music);
        bookCanvasGroup.DOFade(1f, 0.6f);
    }

    private void SwitchMainBgm(AudioKey key)
    {
        if (audioManager == null) return;
        audioManager.Play(key);
    }

    private void BuildDropPoolFromResources()
    {
        var mats = Resources.LoadAll<MaterialObj>(resourcesMatFolder);
        if (mats == null || mats.Length == 0)
        {
            Debug.LogWarning($"[GameManager] Resources/{resourcesMatFolder} 未找到任何 MaterialObj，无法自动生成材料池。");
            return;
        }

        var pool = ScriptableObject.CreateInstance<MaterialPool>();
        pool.name = $"RuntimeMaterialPool_{resourcesMatFolder}";

        for (int i = 0; i < mats.Length; i++)
        {
            var prefab = mats[i];
            if (prefab == null) continue;

            var entry = new MaterialPoolEntry { MaterialPrefab = prefab, Weight = 1 };
            switch (prefab.Quality)
            {
                case MaterialQuality.Common: pool.Common.Add(entry); break;
                case MaterialQuality.Uncommon: pool.Uncommon.Add(entry); break;
                case MaterialQuality.Rare: pool.Rare.Add(entry); break;
                case MaterialQuality.Epic: pool.Epic.Add(entry); break;
                case MaterialQuality.Legendary: pool.Legendary.Add(entry); break;
                default: pool.Common.Add(entry); break;
            }
        }

        dropPool = pool;
        Debug.Log($"[GameManager] 已从 Resources/{resourcesMatFolder} 自动生成材料池：Common={pool.Common.Count}, Uncommon={pool.Uncommon.Count}, Rare={pool.Rare.Count}, Epic={pool.Epic.Count}, Legendary={pool.Legendary.Count}");
    }

    private void EnsureDropConfigForJam()
    {
        // dropMethod: 如果没配，运行时创建一个默认实现（SO 实例）
        if (dropMethod == null)
        {
            dropMethod = ScriptableObject.CreateInstance<SimpleLuckMaterialDropMethod>();
            dropMethod.name = "Runtime_SimpleLuckDropMethod";
            if (enablePhaseDebugLogs) Debug.Log("[GameManager] dropMethod 未配置：已创建 Runtime_SimpleLuckDropMethod。");
        }

        // Jam：dropCount 直接走 JamDefaultSettings 的默认值（可在 JamDefaultSettings 改）
        dropCount = Mathf.Max(0, JamDefaultSettings.DropCountPerBattle);
    }

    private void SpawnInitialCommonMaterialsIfNeeded()
    {
        if (_initialMaterialsSpawned) return;
        _initialMaterialsSpawned = true;

        if (initialCommonMaterialCount <= 0) return;
        if (materialInventory == null)
        {
            Debug.LogError("[GameManager] materialInventory 为空，无法发放开局材料。", this);
            return;
        }
        if (materialInventoryRoot == null)
        {
            Debug.LogError("[GameManager] materialInventoryRoot 未初始化，无法实例化开局材料。", this);
            return;
        }

        if (dropPool == null)
        {
            Debug.LogWarning("[GameManager] dropPool 为空，无法从材料池发放开局材料。");
            return;
        }

        var list = dropPool.GetList(MaterialQuality.Common);
        if (list == null || list.Count == 0)
        {
            Debug.LogWarning("[GameManager] 材料池 Common 列表为空，无法发放开局材料。");
            return;
        }

        // 不强求不重复：数量不足时允许重复抽取（Jam 简化）
        var used = new HashSet<int>();
        for (int n = 0; n < initialCommonMaterialCount; n++)
        {
            int pick;
            if (list.Count >= initialCommonMaterialCount)
            {
                // 尽量不重复
                int safety = 200;
                do
                {
                    pick = Random.Range(0, list.Count);
                } while (!used.Add(pick) && --safety > 0);
            }
            else
            {
                pick = Random.Range(0, list.Count);
            }

            var prefab = list[pick]?.MaterialPrefab;
            if (prefab == null) continue;

            var inst = Instantiate(prefab, materialInventoryRoot, false);
            inst.ResetInventoryShelfLife();
            materialInventory.Add(inst);
        }

        if (makeMuskUI != null && makeMuskUI.gameObject.activeInHierarchy)
        {
            makeMuskUI.RefreshInventoryUI();
        }
    }

    /// <summary>
    /// UI/外部在玩家完成“制造面具回合”（材料附加结束）后调用，GameManager 会继续进入战斗。
    /// </summary>
    public void NotifyMakeMaskFinished()
    {
        if (enablePhaseDebugLogs) Debug.Log($"[GameManager] 制造阶段完成（Next）。round={_roundIndex}");
        if (_makePhaseTcs != null)
        {
            _makePhaseTcs.TrySetResult(true);
            return;
        }

        // Jam/手动模式兜底：如果主循环没跑起来（或 UI 被直接打开），则 Next 直接推进一次完整流程
        if (!_manualAdvanceInProgress)
        {
            _manualAdvanceInProgress = true;
            AdvanceFromMakeUIAsync(_destroyToken).Forget();
        }
        else
        {
            if (enablePhaseDebugLogs) Debug.LogWarning("[GameManager] 手动推进中，忽略重复 Next。");
        }
    }

    private async UniTaskVoid AdvanceFromMakeUIAsync(CancellationToken ct)
    {
        try
        {
            // 2) 制造阶段结束：材料库存保质期结算
            if (enablePhaseDebugLogs) Debug.Log($"[GameManager]（手动）制造阶段结算：库存 TickEndOfMakePhase。round={_roundIndex}");
            materialInventory?.TickEndOfMakePhase(materialInventoryRoot);

            // 3) 战斗阶段：开始战斗并等待结束
            if (enablePhaseDebugLogs) Debug.Log($"[GameManager]（手动）进入战斗阶段。round={_roundIndex}");
            await StartBattlePhaseAsync(ct);

            if (enablePhaseDebugLogs) Debug.Log($"[GameManager]（手动）回合结束。round={_roundIndex}");
            _roundIndex++;

            // 回到制造阶段（方便继续点）
            EnterMakeMaskPhase();
        }
        finally
        {
            _manualAdvanceInProgress = false;
        }
    }

    private async UniTaskVoid RunMainLoopAsync()
    {
        while (!_destroyToken.IsCancellationRequested)
        {
            await RunOneRoundAsync(_destroyToken);
        }
    }

    private async UniTask RunOneRoundAsync(CancellationToken ct)
    {
        if (enablePhaseDebugLogs) Debug.Log($"[GameManager] RoundStart round={_roundIndex}");
        // 1) 制造阶段：生成底板面具，等待玩家完成合成
        EnterMakeMaskPhase();

        _makePhaseTcs = new UniTaskCompletionSource<bool>();
        if (autoCompleteMakePhase) _makePhaseTcs.TrySetResult(true);

        if (enablePhaseDebugLogs) Debug.Log($"[GameManager] 等待制造阶段结束... round={_roundIndex}");
        await _makePhaseTcs.Task.AttachExternalCancellation(ct);

        // 2) 制造阶段结束：材料库存保质期结算
        if (enablePhaseDebugLogs) Debug.Log($"[GameManager] 制造阶段结算：库存 TickEndOfMakePhase。round={_roundIndex}");
        materialInventory?.TickEndOfMakePhase(materialInventoryRoot);

        // 制造阶段结束时：收集当前面具材料的成长值（回合结束奖励）
        CollectMakePhaseGrowth();

        // 3) 战斗阶段：开始战斗并等待结束
        if (enablePhaseDebugLogs) Debug.Log($"[GameManager] 进入战斗阶段。round={_roundIndex}");
        await StartBattlePhaseAsync(ct);

        if (enablePhaseDebugLogs) Debug.Log($"[GameManager] RoundEnd round={_roundIndex}");
        _roundIndex++;
    }

    private void BootstrapAudio()
    {

    }

    private void BootstrapFight()
    {
        if (fightManager == null)
        {
            var go = new GameObject("FightManager");
            go.transform.SetParent(transform, false);
            fightManager = go.AddComponent<FightManager>();
        }

        fightManager.Initialize();
    }

    private void BootstrapSpawn()
    {
        if (monsterSpawnSystem == null)
        {
            var go = new GameObject("MonsterSpawnSystem");
            go.transform.SetParent(transform, false);
            monsterSpawnSystem = go.AddComponent<MonsterSpawnSystem>();
        }
        monsterSpawnSystem.Initialize();
    }

    private void BootstrapMask()
    {
        if (maskMakeManager == null)
        {
            var go = new GameObject("MaskMakeManager");
            go.transform.SetParent(transform, false);
            maskMakeManager = go.AddComponent<MaskMakeManager>();
        }

        maskMakeManager.Initialize();
    }

    private void BootstrapPlayer()
    {
        if (Player.I != null) return;
        // Jam：不依赖 PlayerConfigSO，直接使用默认值（改 JamDefaultSettings 即可调参）
        Player.CreateSingleton(JamDefaultSettings.DefaultPlayerBaseStats);
    }

    private void BootstrapRuntimeRoots()
    {
        if (maskLibraryRoot == null)
        {
            var go = new GameObject("MaskLibraryRoot");
            go.transform.SetParent(transform, false);
            maskLibraryRoot = go.transform;
        }
        if (materialInventoryRoot == null)
        {
            var go = new GameObject("MaterialInventoryRoot");
            go.transform.SetParent(transform, false);
            materialInventoryRoot = go.transform;
        }
    }

    /// <summary>
    /// 进入"制造面具/经营阶段"：按顺序生成一个新的 MaskObj。
    /// </summary>
    public void EnterMakeMaskPhase()
    {
        EnterMakeMaskPhaseAsync(_destroyToken).Forget();
    }

    private async UniTaskVoid EnterMakeMaskPhaseAsync(CancellationToken ct)
    {
        SwitchMainBgm(AudioKey.Game_Shop_Music);
        // 黑屏淡入淡出：从战斗到制造（内容切换在黑屏期间执行）
        await PlayBlackScreenTransition(_ =>
        {
            // 商店/制造阶段音乐：尽量在黑屏中切换

            if (maskMakeManager == null)
            {
                Debug.LogError("[GameManager] MaskMakeManager 未初始化。", this);
                return UniTask.CompletedTask;
            }

            var newMask = maskMakeManager.MakeNextMask();
            if (newMask == null) return UniTask.CompletedTask;

            // 当前面具：用于本回合材料附加与本场战斗，同时也会参与"面具库注入"（但战后才正式入库）
            if (newMask.transform.parent != transform && newMask.transform.parent != maskMakeManager.transform)
            {
                newMask.transform.SetParent(maskMakeManager.transform, false);
            }

            if (autoBindInventoryOnMake)
            {
                AutoBindInventoryToCurrentMask();
            }

            if (makeMuskUI != null)
            {
                SetUIActiveWithCanvasGroup(makeMuskUI.gameObject, true);
                makeMuskUI.RefreshInventoryUI();
            }

            // 进入制造阶段：关闭战斗 UI
            if (battleUI != null) {SetUIActiveWithCanvasGroup(battleUI.gameObject, false)
            ;
            };
            return UniTask.CompletedTask;
        }, ct);
    }

    /// <summary>
    /// 播放黑屏淡入淡出过渡动画。
    /// 流程：fadeIn 0.5s -> 执行内容切换回调 -> 等待 0.5s -> fadeOut 0.5s
    /// </summary>
    /// <param name="onContentSwitch">在 fadeIn 完成后、等待期间执行的内容切换回调</param>
    private async UniTask PlayBlackScreenTransition(System.Func<CancellationToken, UniTask> onContentSwitch, CancellationToken ct)
    {
        if (blackScreen == null) return;

        // 强约束：黑屏转场不允许并发/重入（否则会造成 Tween Kill、时序错乱、流程异常）
        await _blackScreenTransitionGate.WaitAsync(ct);
        try
        {
        // 确保黑屏 GameObject 激活
        if (!blackScreen.gameObject.activeSelf)
        {
            blackScreen.gameObject.SetActive(true);
        }

        // 初始化：alpha = 0，blocksRaycasts = true（防止点击穿透）
        blackScreen.alpha = 0f;
        blackScreen.blocksRaycasts = true;
        blackScreen.interactable = false;
        

        // FadeIn: 0 -> 1 (0.5s)
        var fadeInTcs = new UniTaskCompletionSource();
        var fadeInTween = blackScreen.DOFade(1f, 0.5f).SetUpdate(true);
        fadeInTween.OnComplete(() => fadeInTcs.TrySetResult());
        fadeInTween.OnKill(() =>
        {
            // 被外部 Kill 时尽量保证状态一致，避免 await 抛异常导致流程中断
            if (blackScreen != null) blackScreen.alpha = 1f;
            fadeInTcs.TrySetResult();
        });
        await fadeInTcs.Task.AttachExternalCancellation(ct);

    

        // 等待 0.5s（让内容切换完成）
        await UniTask.Delay(200, cancellationToken: ct);
        // 在黑屏完全显示后立即执行内容切换
        if (onContentSwitch != null) await onContentSwitch(ct);
        await UniTask.Delay(200, cancellationToken: ct);

        // FadeOut: 1 -> 0 (0.5s)
        var fadeOutTcs = new UniTaskCompletionSource();
        var fadeOutTween = blackScreen.DOFade(0f, 0.5f).SetUpdate(true);
        fadeOutTween.OnComplete(() => fadeOutTcs.TrySetResult());
        fadeOutTween.OnKill(() =>
        {
            if (blackScreen != null) blackScreen.alpha = 0f;
            fadeOutTcs.TrySetResult();
        });
        await fadeOutTcs.Task.AttachExternalCancellation(ct);

        // 淡出后禁用 blocksRaycasts
        blackScreen.blocksRaycasts = false;
        }
        finally
        {
            _blackScreenTransitionGate.Release();
        }
    }

    /// <summary>
    /// 游戏结束（方法后续补充）。
    /// </summary>
    private void GameOver()
    {
        // TODO: 后续补充游戏结束逻辑
        if (enablePhaseDebugLogs)
        {
            Debug.Log("[GameManager] GameOver 被调用（方法待补充）。");
        }
    }

    /// <summary>
    /// 进入战斗阶段：使用 FightManager 开始战斗。
    /// </summary>
    public void StartBattlePhase()
    {
        // 兼容旧入口：不再在这里做“严格顺序等待”，只作为手动开战入口。
        StartBattlePhaseAsync(_destroyToken).Forget();
    }

    private async UniTask StartBattlePhaseAsync(CancellationToken ct)
    {
        if (fightManager == null)
        {
            Debug.LogError("[GameManager] FightManager 未初始化。", this);
            return;
        }

        // 注意：不再在这里清空 _pendingGrowthDelta，因为它是跨回合的
        // 会在 CollectAndApplyPersistentGrowth 中应用后立即创建新的

        // 确保存在当前面具（在进入战斗前先创建，但不等待黑屏过渡）
        if (maskMakeManager != null && maskMakeManager.CurrentMask == null)
        {
            if (maskMakeManager != null)
            {
                var newMask = maskMakeManager.MakeNextMask();
                if (newMask != null)
                {
                    if (newMask.transform.parent != transform && newMask.transform.parent != maskMakeManager.transform)
                    {
                        newMask.transform.SetParent(maskMakeManager.transform, false);
                    }
                    if (autoBindInventoryOnMake)
                    {
                        AutoBindInventoryToCurrentMask();
                    }
                }
            }
        }
        SwitchMainBgm(AudioKey.Game_Fight_Music);

        // 黑屏淡入淡出：从制造到战斗（内容切换在黑屏期间执行）
        await PlayBlackScreenTransition(_ =>
        {
            // 战斗音乐：尽量在黑屏中切换

            // 进入战斗阶段：关闭制造 UI，打开战斗 UI（CanvasGroup 会同时控制透明度与射线）
            if (makeMuskUI != null) {
                SetUIActiveWithCanvasGroup(makeMuskUI.gameObject, false);
            }
            if (battleUI != null) 
            {
                SetUIActiveWithCanvasGroup(battleUI.gameObject, true);
            }

            // 注入面具库 + 当前面具（不依赖 battleUI 是否存在）
            var injectors = new System.Collections.Generic.List<IMaskBattleInjector>();
            for (int i = 0; i < _maskLibrary.Count; i++)
            {
                if (_maskLibrary[i] != null) injectors.Add(_maskLibrary[i]);
            }
            if (maskMakeManager != null && maskMakeManager.CurrentMask != null)
            {
                injectors.Add(maskMakeManager.CurrentMask);
            }
            fightManager.SetMaskBattleInjector(new MaskLibraryInjector(injectors));
            fightManager.StartFight();

            return UniTask.CompletedTask;
        }, ct);
        _battleEndTcs = new UniTaskCompletionSource<bool>();

        var ctx = fightManager.Context;
        fightManager.StartFightUpdate();

        if (ctx == null)
        {
            Debug.LogError("[GameManager] FightContext 为空，无法等待战斗结束。", this);
            _battleEndTcs.TrySetResult(false);
        }
        else
        {
            System.Action<FightContext> onVictory = null;
            System.Action<FightContext> onDefeat = null;
            
            onVictory = async (fightCtx) =>
            {
                ctx.OnVictory -= onVictory;
                ctx.OnDefeat -= onDefeat;
                
                // 战斗胜利：停止战斗计算
                if (fightManager != null)
                {
                    fightManager.StopFight();
                }
                
                // 等待几秒后调用 gameOver
                await UniTask.Delay(2000, cancellationToken: ct); // 等待 2 秒
                GameOver();
                
                _battleEndTcs.TrySetResult(true);
            };
            
            onDefeat = _ =>
            {
                ctx.OnVictory -= onVictory;
                ctx.OnDefeat -= onDefeat;
                _battleEndTcs.TrySetResult(true);
            };
            
            ctx.OnVictory += onVictory;
            ctx.OnDefeat += onDefeat;
        }

        await _battleEndTcs.Task.AttachExternalCancellation(ct);

        // 战后结算（严格在战斗结束后执行，等待 UI 掉落动画完成）
        await PostBattleSettlementAsync(ctx, ct);

        // 战斗结束：关闭战斗 UI（制造阶段会在下一轮再打开）
        // 重要：不要在这里关 battleUI；否则会出现"还没黑屏战斗界面就关闭"的观感问题。
        // battleUI 的关闭应统一放到 EnterMakeMaskPhaseAsync 的黑屏内容切换中执行。
    }

    private static void SetUIActiveWithCanvasGroup(GameObject go, bool active)
    {
        if (go == null) return;

        var cg = go.GetComponent<CanvasGroup>();
        if (cg != null)
        {
            if (active)
            {
                // 先激活，再恢复可见/可交互（避免 OnEnable 期间状态不一致）
                go.SetActive(true);
                cg.alpha = 1f;
                cg.interactable = true;
                cg.blocksRaycasts = true;
            }
            else
            {
                // 先禁止交互/射线，再隐藏
                cg.interactable = false;
                cg.blocksRaycasts = false;
                cg.alpha = 0f;
                go.SetActive(false);
            }
            return;
        }

        // 没有 CanvasGroup 就保持旧逻辑
        go.SetActive(active);
    }

    private async UniTask PostBattleSettlementAsync(FightContext ctx, CancellationToken ct)
    {
        if (enablePhaseDebugLogs) Debug.Log($"[GameManager] 战后结算开始。round={_roundIndex}");
        
        // 当前面具入库
        var cur = maskMakeManager != null ? maskMakeManager.DetachCurrentMaskForLibrary() : null;
        if (cur != null && !_maskLibrary.Contains(cur))
        {
            _maskLibrary.Add(cur);
            if (maskLibraryRoot != null) cur.transform.SetParent(maskLibraryRoot, false);
        }

        // 持久增值结算
        CollectAndApplyPersistentGrowth(ctx);
        if (enablePhaseDebugLogs) Debug.Log($"[GameManager] 持久增值结算完成。round={_roundIndex}");

        // 等待 UI 掉落动画完成（掉落物会在动画完成后自动加入库存）
        if (battleUI != null)
        {
            if (enablePhaseDebugLogs) Debug.Log($"[GameManager] 等待掉落动画完成... round={_roundIndex}");
            await battleUI.WaitForDropAnimationAsync().AttachExternalCancellation(ct);
            if (enablePhaseDebugLogs) Debug.Log($"[GameManager] 掉落动画完成。round={_roundIndex}");
        }
        else
        {
            // 如果没有 battleUI，直接执行掉落逻辑（兼容性处理）
            RunDrops();
            if (enablePhaseDebugLogs) Debug.Log($"[GameManager] 掉落结算完成（无 UI）。round={_roundIndex}");
        }

    }

    // ---- UI helpers ----
    public IReadOnlyList<MaterialObj> GetMaterialInventoryItems()
    {
        return materialInventory != null ? materialInventory.Items : null;
    }

    public MaskObj GetCurrentMask()
    {
        return maskMakeManager != null ? maskMakeManager.CurrentMask : null;
    }

    /// <summary>
    /// 获取面具库（只读列表）。
    /// </summary>
    public IReadOnlyList<MaskObj> GetMaskLibrary()
    {
        return _maskLibrary;
    }

    /// <summary>
    /// 为面具分配随机 Sprite（Compose 后调用）。
    /// </summary>
    public void AssignRandomMaskSprite(MaskObj mask)
    {
        if (mask == null) return;

        Sprite sprite = null;

        // 从池中随机选择
        if (maskSpritePool != null && maskSpritePool.Count > 0)
        {
            var validSprites = new List<Sprite>();
            foreach (var s in maskSpritePool)
            {
                if (s != null) validSprites.Add(s);
            }

            if (validSprites.Count > 0)
            {
                sprite = validSprites[Random.Range(0, validSprites.Count)];
            }
        }

        // 如果池为空或随机失败，使用默认 sprite
        if (sprite == null)
        {
            sprite = defaultMaskSprite;
        }

        mask.DisplaySprite = sprite;

        if (enablePhaseDebugLogs)
        {
            Debug.Log($"[GameManager] 已为面具分配 Sprite：{mask.name} -> {(sprite != null ? sprite.name : "null")}");
        }
    }

    /// <summary>
    /// UI 兜底：如果策划直接把 MakeMuskUI 打开但没有走 EnterMakeMaskPhase()，
    /// 则此方法会保证存在一个 CurrentMask（不会重复开启 UI，也不会触发流程等待）。
    /// </summary>
    public MaskObj EnsureCurrentMaskForMakeUI()
    {
        if (maskMakeManager == null)
        {
            Debug.LogError("[GameManager] MaskMakeManager 未初始化，无法 EnsureCurrentMaskForMakeUI。", this);
            return null;
        }

        if (maskMakeManager.CurrentMask != null) return maskMakeManager.CurrentMask;

        var m = maskMakeManager.MakeNextMask();
        if (m == null) return null;

        if (m.transform.parent != transform && m.transform.parent != maskMakeManager.transform)
        {
            m.transform.SetParent(maskMakeManager.transform, false);
        }

        if (enablePhaseDebugLogs) Debug.Log("[GameManager] EnsureCurrentMaskForMakeUI：已自动创建 CurrentMask。");
        return m;
    }

    public void RemoveMaterialFromInventory(MaterialObj mat)
    {
        if (mat == null) return;
        materialInventory?.Remove(mat);
    }

    /// <summary>
    /// Jam 调试工具：手动生成一个材料实例并加入库存。
    /// </summary>
    public MaterialObj DebugSpawnMaterialToInventory(MaterialObj prefab)
    {
        if (prefab == null)
        {
            Debug.LogWarning("[GameManager] DebugSpawnMaterialToInventory：prefab 为空。", this);
            return null;
        }
        if (materialInventory == null)
        {
            Debug.LogError("[GameManager] DebugSpawnMaterialToInventory：materialInventory 为空。", this);
            return null;
        }

        var parent = materialInventoryRoot != null ? materialInventoryRoot : transform;
        var inst = Instantiate(prefab, parent, false);
        inst.name = $"{prefab.name}_Inv_Debug";
        inst.ResetInventoryShelfLife();
        materialInventory.Add(inst);

        if (makeMuskUI != null && makeMuskUI.gameObject.activeInHierarchy)
        {
            makeMuskUI.RefreshInventoryUI();
        }

        Debug.Log($"[GameManager] DebugSpawnMaterialToInventory：已入库 {inst.name}", inst);
        return inst;
    }

    /// <summary>
    /// 收集制造阶段的成长值（回合结束奖励）。
    /// 遍历当前面具的材料，收集 IPersistentGrowthProvider 的成长值到 _pendingGrowthDelta。
    /// </summary>
    private void CollectMakePhaseGrowth()
    {
        if (Player.I == null) return;

        // 确保 _pendingGrowthDelta 存在（如果不存在则创建）
        if (_pendingGrowthDelta == null)
        {
            _pendingGrowthDelta = new PlayerGrowthDelta();
        }

        // 获取当前面具
        var currentMask = maskMakeManager != null ? maskMakeManager.CurrentMask : null;
        if (currentMask == null) return;

        var mats = currentMask.Materials;
        if (mats == null || mats.Count == 0) return;

        // 遍历当前面具的材料，收集成长值
        for (int i = 0; i < mats.Count; i++)
        {
            var mat = mats[i];
            if (mat == null) continue;

            // 树状逻辑：PersistentGrowth 阶段
            if (mat.LogicTreeRoots != null && mat.LogicTreeRoots.Count > 0)
            {
                var tctx = new MaterialVommandeTreeContext(
                    MaterialTraversePhase.PersistentGrowth,
                    mask: currentMask,
                    maskMaterials: mats,
                    onMaterialBound: null,
                    fight: null,
                    side: FightSide.None,
                    defenderSide: FightSide.None,
                    actionNumber: 0,
                    attackerAttackNumber: 0,
                    attackInfo: default,
                    damage: 0f,
                    player: null,
                    growthDelta: _pendingGrowthDelta
                );
                TraverseMaterialGrowthTree(mat.LogicTreeRoots, in tctx, _pendingGrowthDelta, null);
            }
        }

        if (enablePhaseDebugLogs)
        {
            Debug.Log($"[GameManager] 制造阶段成长值收集完成。round={_roundIndex}");
        }
    }

    private void CollectAndApplyPersistentGrowth(FightContext ctx)
    {
        if (Player.I == null) return;
        if (ctx == null) return;

        // 使用现有的 _pendingGrowthDelta（如果存在），否则创建新的
        // 这样可以从上次结算后开始累积（包括制造阶段的成长值）
        var delta = _pendingGrowthDelta ?? new PlayerGrowthDelta();

        // 面具库顺序 → 材料顺序 → 逻辑树遍历顺序（运行时只使用 logicTreeRoots）
        for (int mi = 0; mi < _maskLibrary.Count; mi++)
        {
            var mask = _maskLibrary[mi];
            if (mask == null) continue;

            var mats = mask.Materials;
            for (int i = 0; i < mats.Count; i++)
            {
                var mat = mats[i];
                if (mat == null) continue;

                // 树状逻辑优先：PersistentGrowth 阶段（建议配 Gate_Phase(PersistentGrowth)）
                if (mat.LogicTreeRoots != null && mat.LogicTreeRoots.Count > 0)
                {
                    var tctx = new MaterialVommandeTreeContext(
                        MaterialTraversePhase.PersistentGrowth,
                        mask: null,
                        maskMaterials: null,
                        onMaterialBound: null,
                        fight: null,
                        side: FightSide.None,
                        defenderSide: FightSide.None,
                        actionNumber: ctx.BattleActionCount,
                        attackerAttackNumber: 0,
                        attackInfo: default,
                        damage: 0f,
                        player: null,
                        growthDelta: delta
                    );
                    TraverseMaterialGrowthTree(mat.LogicTreeRoots, in tctx, delta, ctx);
                    continue;
                }

                // 不再兼容链式：没有树就跳过并输出提示
                if (ctx.DebugVerbose)
                {
                    ctx.DebugLogger?.Invoke($"[GameManager] PersistentGrowth Skip：Material={mat.name} 未配置 logicTreeRoots。");
                }
            }
        }

        // 先存储未应用的提升值（用于 UI 显示"提升的数值（还未运用）"）
        // 注意：这里存储的是收集到的提升值，在应用前 UI 可以显示
        _pendingGrowthDelta = new PlayerGrowthDelta
        {
            AddMaxHP = delta.AddMaxHP,
            AddAttack = delta.AddAttack,
            AddDefense = delta.AddDefense,
            AddCritChance = delta.AddCritChance,
            AddCritMultiplier = delta.AddCritMultiplier,
            AddSpeedRate = delta.AddSpeedRate,
            AddLuck = delta.AddLuck
        };

        // 然后应用提升值
        if (JamDefaultSettings.PersistentGrowthCalculator != null)
        {
            JamDefaultSettings.PersistentGrowthCalculator.Apply(Player.I, delta, ctx);
        }
        else
        {
            // 兜底：直接应用（不建议为 null）
            Player.I.ApplyGrowth(delta);
        }

        if (enablePhaseDebugLogs)
        {
            Debug.Log($"[GameManager] 持久成长值已应用，已创建新的 _pendingGrowthDelta 用于下一轮。round={_roundIndex}");
        }
    }

    private void TraverseMaterialGrowthTree(IReadOnlyList<MaterialLogicNode> nodes, in MaterialVommandeTreeContext tctx, PlayerGrowthDelta delta, FightContext fight)
    {
        if (nodes == null) return;
        for (int i = 0; i < nodes.Count; i++)
        {
            var n = nodes[i];
            if (n == null) continue;
            var c = n.Component;

            if (c is IMaterialTraversalGate gate && gate.ShouldBreak(in tctx))
            {
                // 仅跳过该分支
                continue;
            }

            if (c is IPersistentGrowthProvider p)
            {
                p.OnCollectPersistentGrowth(Player.I, delta, fight);
            }

            // 只有逻辑节点（gate/空节点）允许子节点
            if ((c == null || c is IMaterialTraversalGate) && n.Children != null && n.Children.Count > 0)
            {
                TraverseMaterialGrowthTree(n.Children, in tctx, delta, fight);
            }
        }
    }

    /// <summary>
    /// 获取本次战斗的掉落列表（不直接加入库存，用于 UI 表现）。
    /// </summary>
    public System.Collections.Generic.IReadOnlyList<MaterialDropEntry> GetBattleDrops()
    {
        if (Player.I == null) return null;
        if (dropPool == null || dropMethod == null) return null;

        int luck = Player.I.ActualStats.Luck;
        if (enablePhaseDebugLogs) Debug.Log($"[GameManager] RollDrops luck={luck} dropCount={dropCount} round={_roundIndex}");
        return dropMethod.Roll(dropPool, luck, dropCount);
    }

    /// <summary>
    /// 将掉落物加入库存（在掉落动画完成后调用）。
    /// </summary>
    public void AddDropsToInventory(System.Collections.Generic.IReadOnlyList<MaterialDropEntry> drops)
    {
        if (drops == null) return;

        for (int i = 0; i < drops.Count; i++)
        {
            var e = drops[i];
            if (e == null || e.MaterialPrefab == null) continue;

            int count = Mathf.Max(0, e.Count);
            for (int k = 0; k < count; k++)
            {
                var inst = Instantiate(e.MaterialPrefab, materialInventoryRoot != null ? materialInventoryRoot : transform, false);
                inst.name = $"{e.MaterialPrefab.name}_Inv";
                inst.ResetInventoryShelfLife();
                materialInventory.Add(inst);
            }
        }
    }

    private void RunDrops()
    {
        var drops = GetBattleDrops();
        if (drops == null) return;
        AddDropsToInventory(drops);
    }

    private void AutoBindInventoryToCurrentMask()
    {
        if (maskMakeManager == null) return;
        var mask = maskMakeManager.CurrentMask;
        if (mask == null) return;
        if (materialInventory == null) return;

        var items = materialInventory.Items;
        if (items == null || items.Count == 0) return;

        // 按加入库存顺序尝试绑定。材料实例直接绑定到面具：绑定成功就从库存移除。
        // 注意：移除会改变 Items，故这里先拷贝一份快照。
        var snapshot = new List<MaterialObj>(items);
        for (int i = 0; i < snapshot.Count; i++)
        {
            var mat = snapshot[i];
            if (mat == null) continue;

            var result = mask.BindMaterial(mat);
            if (result.Success)
            {
                materialInventory.Remove(mat);
            }
            else
            {
                // 不消耗库存；继续尝试其它材料（可能更便宜）
                if (materialInventoryRoot != null && mat.transform.parent != materialInventoryRoot)
                {
                    mat.transform.SetParent(materialInventoryRoot, false);
                }
            }
        }
    }

    /// <summary>
    /// Jam 临时补全：在策划还没配置完 Inspector/Prefab 的情况下，让流程先跑通。
    /// 手动 new 出来（非 Mono），符合“临时测试类”需求。
    /// </summary>
    private sealed class JamTempFixer
    {
        public void Apply(GameManager gm)
        {
            if (gm == null) return;

            // Jam：玩家一律使用 JamDefaultSettings（不再依赖 PlayerConfigSO）
            if (Player.I == null)
            {
                Player.CreateSingleton(JamDefaultSettings.DefaultPlayerBaseStats);
                if (gm.enablePhaseDebugLogs) Debug.Log("[JamTempFixer] Player 已用 JamDefaultSettings 初始化。");
            }

            // 面具底板：确保存在（未配置时自动创建临时底板）
            if (gm.maskMakeManager != null)
            {
                gm.maskMakeManager.EnsureBaseMaskPrefabForTest(10);
            }


                var testCfg = gm.monsterSpawnSystem.Spawn(0, null);
                if (testCfg == null)
                {
                    Debug.LogWarning("[JamTempFixer] 当前怪物生成链无法生成怪物：已自动挂 JamTestMonsterSpawnLogic。");
                    if (gm.monsterSpawnSystem.GetComponent<JamTestMonsterSpawnLogic>() == null)
                    {
                        gm.monsterSpawnSystem.gameObject.AddComponent<JamTestMonsterSpawnLogic>();
                    }
                    gm.monsterSpawnSystem.Initialize();
                }

            // 制造 UI：如果没配 UI 且没开 autoCompleteMakePhase，会卡住等待
            if (gm.makeMuskUI == null && !gm.autoCompleteMakePhase)
            {
                gm.autoCompleteMakePhase = true;
                Debug.LogWarning("[JamTempFixer] makeMuskUI 未配置：已强制 autoCompleteMakePhase=true，避免流程卡住。");
            }

            // 战斗 UI：尽量自动补一个引用（不强制；没有也不影响流程，只是少展示）
            if (gm.battleUI == null)
            {
                gm.battleUI = Object.FindFirstObjectByType<BattleUI>(FindObjectsInactive.Include);
                if (gm.battleUI == null)
                {
                    if (gm.enablePhaseDebugLogs)
                        Debug.LogWarning("[JamTempFixer] battleUI 未配置/未找到：战斗阶段将只输出 Log（不显示血条/速度条/飘字）。");
                }
                else
                {
                    if (gm.enablePhaseDebugLogs)
                        Debug.Log("[JamTempFixer] 已自动找到 BattleUI 并注入到 GameManager。");
                }
            }
        }
    }

    /// <summary>
    /// 显示费用不足警告动画：fadeIn -> 持续1秒 -> fadeOut
    /// </summary>
    public void ShowCostWarning()
    {
        if (costWarningCanvasGroup == null) return;

        // 播放费用不足音效
        if (audioManager != null)
        {
            audioManager.PlaySfxOnce(AudioKey.FBX_Cost_Not_Enough);
        }

        // 停止当前动画
        _costWarningTween?.Kill();

        // 确保 CanvasGroup 激活
        if (!costWarningCanvasGroup.gameObject.activeSelf)
        {
            costWarningCanvasGroup.gameObject.SetActive(true);
        }

        // 初始化：alpha = 0
        costWarningCanvasGroup.alpha = 0f;

        // 创建动画序列：fadeIn (0.3s) -> 等待 (1s) -> fadeOut (0.3s)
        _costWarningTween = DOTween.Sequence()
            .SetUpdate(true) // 即使 TimeScale=0 也能播 UI
            .Append(costWarningCanvasGroup.DOFade(1f, 0.3f).SetEase(Ease.OutQuad)) // fadeIn
            .AppendInterval(1f) // 持续1秒
            .Append(costWarningCanvasGroup.DOFade(0f, 0.3f).SetEase(Ease.InQuad)) // fadeOut
            .OnComplete(() => {
                _costWarningTween = null;
                // 动画完成后可以隐藏 GameObject（可选）
                // costWarningCanvasGroup.gameObject.SetActive(false);
            });
    }
}






// === GameSetting.cs ===
using UnityEngine;

public static class GameSetting
{
    /// <summary>
    /// 小节长度（秒）。AudioTimeline 的 bar 对齐与排挤 cross-fade 都基于这个值。
    /// </summary>
    public const float BarSeconds = 1.6f;

    /// <summary>
    /// Resources 下 AudioEntrySO 的加载路径（相对 Resources 根目录）。
    /// </summary>
    public const string AudioEntriesResourcesPath = "AudioEntries";

    /// <summary>
    /// 攻击动画间隔（秒）。速度条机制下的最小攻击间隔不允许低于此值。
    /// </summary>
    public const float AttackAnimIntervalSeconds = 0.25f;

    /// <summary>
    /// 攻击动画总时间（秒）。往返移动的总时长（去程 + 回程）。
    /// </summary>
    public const float AttackTweenTotalSeconds = 0.3f;

    /// <summary>
    /// 攻击动画命中距离（像素）。移动到目标方向的距离偏移。
    /// </summary>
    public const float AttackHitDistance = 50f;

    /// <summary>
    /// 场地速度阈值默认值（整数）。后续如果需要"根据默认值生成关卡速度"，再补逻辑。
    /// </summary>
    public const int DefaultArenaSpeedThreshold = 100;

    // ---- UI：品质描边颜色（白/绿/紫/金/红，低->高）----
    public static readonly Color32 QualityOutline_Common = new(255, 255, 255, 255);
    public static readonly Color32 QualityOutline_Uncommon = new(80, 255, 80, 255);
    public static readonly Color32 QualityOutline_Rare = new(170, 90, 255, 255);
    public static readonly Color32 QualityOutline_Epic = new(255, 210, 60, 255);
    public static readonly Color32 QualityOutline_Legendary = new(255, 80, 80, 255);

    // ---- UI：选中描边颜色----
    public static readonly Color32 SelectedOutline_Green = new(80, 255, 80, 255);
    public static readonly Color32 SelectedOutline_Red = new(255, 80, 80, 255);
}






// === Audio\AudioEntrySO.cs ===
using System.Collections.Generic;
using Sirenix.OdinInspector;
using UnityEngine;

[CreateAssetMenu(menuName = "GGJ/Audio/Audio Entry", fileName = "AudioEntry")]
public class AudioEntrySO : ScriptableObject
{
    [Tooltip("必须与 AudioKey 枚举名一致（通过 ToString 调用）。")]
    [ValueDropdown(nameof(GetAudioKeyNames))]
    public string key;

    public AudioClip clip;

    [Range(0f, 1f)]
    [Tooltip("该资源的默认音量（基准音量）。")]
    public float volume = 1f;

    [Tooltip("BGM 使用：声轨。SFX 可忽略/保持默认值。")]
    public BgmTrack track = BgmTrack.Track1;

    [Tooltip("勾选后启用“同轨排挤/cross-fade 替换逻辑”。默认不勾选：非Background并行叠加，Background直接替换。")]
    public bool useReplaceLogic = false;

    [Tooltip("是否为 Background：StopAll 不会停止 Background。Background 使用独立轨道（BgmTrack.Background）。")]
    public bool isBackground = false;

    private static IEnumerable<string> GetAudioKeyNames()
    {
        return System.Enum.GetNames(typeof(AudioKey));
    }
}






// === Audio\AudioKey.cs ===
public enum AudioKey
{
    // TODO: 由你维护完整列表；先放 1 个占位值用于验证流程
    BGM_TEST_1 = 0,
    BGM_TEST_2 = 1,

    Game_Base_Music = 2,
    Game_Shop_Music = 3,
    Game_Fight_Music = 4,

    FBX_Attack,
    FBX_Cost_Not_Enough,
    FBX_Compose_Met,
    FBX_Click_Met,
    Menu_BGM,
}




// === Audio\AudioManager.cs ===
using System.Collections;
using System.Collections.Generic;
using DG.Tweening;
using UnityEngine;
using Sirenix.OdinInspector;

public class AudioManager : MonoBehaviour
{
    public static AudioManager I { get; private set; }

    [Header("Runtime")]
    [SerializeField] private AudioTimeline timeline;

    [Header("SFX")]
    [SerializeField] private Transform sfxPoolRoot;

    [Header("BGM (Parallel Pool)")]
    [SerializeField] private Transform bgmPoolRoot;

    private readonly Dictionary<string, AudioEntrySO> entries = new();

    // Pending requests (applied at bar boundary)
    private readonly Dictionary<BgmTrack, AudioEntrySO> pendingReplaceByTrack = new();
    private readonly Dictionary<BgmTrack, float> pendingReplaceFadeInByTrack = new();

    private readonly List<AudioEntrySO> pendingParallel = new();
    private readonly List<float> pendingParallelFadeIn = new();

    private AudioEntrySO pendingBackground;
    private float pendingBackgroundFadeIn = -1f;

    // Odin 试音（做法A）
    [FoldoutGroup("Audio Tester"), SerializeField]
    private AudioKey testerKey = AudioKey.BGM_TEST_1;

    [FoldoutGroup("Audio Tester"), SerializeField, Range(0f, 2f)]
    private float testerSfxVolumeMul = 1f;
    [SerializeField] private AudioTimeline audioTimeline;

    void Awake()
    {
        if (I != null)
        {
            Destroy(gameObject);
            return;
        }
        DontDestroyOnLoad(gameObject);
        if (audioTimeline == null)
        {
            var go = new GameObject("AudioTimeline");
            go.transform.SetParent(transform, false);
            audioTimeline = go.AddComponent<AudioTimeline>();
        }
        audioTimeline.Initialize();
        this.Initialize(audioTimeline);
    }
    public void ResetTimeline()
    {
        timeline.Reset();
    }
    public void Initialize(AudioTimeline audioTimeline)
    {
        // 不允许在 AudioManager 自己 Awake 里抢初始化（生命周期强约束：由 GameManager 统一初始化）
        if (I != null && I != this)
        {
            Destroy(gameObject);
            return;
        }
        I = this;

        timeline = audioTimeline;
        if (timeline != null)
        {
            timeline.OnBarBoundary += HandleBarBoundary;
        }

        if (sfxPoolRoot == null)
        {
            var go = new GameObject("SfxPool");
            go.transform.SetParent(transform, false);
            sfxPoolRoot = go.transform;
        }

        if (bgmPoolRoot == null)
        {
            var go = new GameObject("BgmPool");
            go.transform.SetParent(transform, false);
            bgmPoolRoot = go.transform;
        }
        this.LoadAllEntriesFromResources();

    }

    public void LoadAllEntriesFromResources()
    {
        entries.Clear();

        var loaded = Resources.LoadAll<AudioEntrySO>(GameSetting.AudioEntriesResourcesPath);
        foreach (var e in loaded)
        {
            if (e == null) continue;
            if (string.IsNullOrWhiteSpace(e.key))
            {
                Debug.LogError($"[Audio] AudioEntrySO missing key: {e.name}", e);
                continue;
            }
            if (entries.ContainsKey(e.key))
            {
                Debug.LogError($"[Audio] Duplicate key '{e.key}'. Keeping first, ignoring: {e.name}", e);
                continue;
            }
            entries.Add(e.key, e);
        }

        Debug.Log($"[Audio] Loaded AudioEntrySO: {entries.Count} (Resources/{GameSetting.AudioEntriesResourcesPath})");
    }

    // ----------------------
    // Public API
    // ----------------------

    public void Play(AudioKey key) => Play(key.ToString());

    /// <summary>
    /// BGM 专用：key 是资源 key（不是轨道），会进入缓冲池，在小节边界处理。
    /// </summary>
    public void Play(string key)
    {
        if (!TryGetEntry(key, out var entry)) return;
        EnqueueBgm(entry, -1f);
    }

    // 兼容文档 API：自定义 fade 秒数（实现仍按 bar 对齐；会 clamp 到当前 bar 剩余时间）
    public void PlayBgmFadeIn(string key, float fadeInSeconds)
    {
        if (!TryGetEntry(key, out var entry)) return;
        EnqueueBgm(entry, fadeInSeconds);
    }

    public void Stop(AudioKey key) => Stop(key.ToString());

    /// <summary>
    /// BGM 专用：key 是资源 key（不是轨道），停止该 key 对应 BGM（若不在播则忽略）。
    /// </summary>
    public void Stop(string key)
    {
        if (!TryGetEntry(key, out var entry)) return;
        if (timeline == null) return;

        // Background：固定走 Background 轨道
        if (entry.isBackground)
        {
            timeline.StopClipOnTrack(BgmTrack.Background, entry.clip, -1f);
            return;
        }

        // 先尝试停止“替换逻辑”轨道内的 clip
        timeline.StopBgmByKey(entry, -1f);

        // 再停止并行池里所有同 clip 的 source
        StopParallelByClip(entry.clip, -1f);
    }

    public void StopBgmFadeOut(string key, float fadeOutSeconds)
    {
        if (!TryGetEntry(key, out var entry)) return;
        if (timeline == null) return;
        if (entry.isBackground)
        {
            timeline.StopClipOnTrack(BgmTrack.Background, entry.clip, fadeOutSeconds);
            return;
        }

        timeline.StopBgmByKey(entry, fadeOutSeconds);
        StopParallelByClip(entry.clip, fadeOutSeconds);
    }

    public void StopAllBgmFadeOut(float fadeOutSeconds)
    {
        if (timeline == null) return;

        // StopAll 不停止 Background（强约束）
        timeline.StopAllBgm(includeBackground: false, fadeSecondsOverride: fadeOutSeconds);
        StopAllParallel(fadeOutSeconds);

        // 清空 pending
        pendingReplaceByTrack.Clear();
        pendingReplaceFadeInByTrack.Clear();
        pendingParallel.Clear();
        pendingParallelFadeIn.Clear();
    }

    public void PlaySfxOnce(AudioKey key, float volumeMul = 1f) => PlaySfxOnce(key.ToString(), volumeMul);

    /// <summary>
    /// SFX：立即播放，不参与 Timeline。
    /// </summary>
    public void PlaySfxOnce(string key, float volumeMul = 1f)
    {
        if (!TryGetEntry(key, out var entry)) return;
        if (entry.clip == null) return;

        float vol = Mathf.Clamp01(entry.volume) * Mathf.Clamp(volumeMul, 0f, 10f);
        PlaySfxPooled(entry.clip, vol);
    }

    // ----------------------
    // SFX pool (overlap + auto recycle)
    // ----------------------

    private readonly Stack<AudioSource> sfxFree = new();
    private readonly HashSet<AudioSource> sfxInUse = new();
    private readonly Dictionary<AudioSource, Tween> sfxTweens = new();

    private void PlaySfxPooled(AudioClip clip, float volume)
    {
        if (clip == null) return;
        var src = GetSfxSource();
        KillSfxTween(src);

        src.loop = false;
        src.clip = clip;
        src.volume = Mathf.Clamp01(volume);
        src.Play();

        // 用 realtime，保证 TimeScale=0 也能回收
        StartCoroutine(RecycleSfxAfter(src, clip.length));
    }

    private AudioSource GetSfxSource()
    {
        if (sfxFree.Count > 0)
        {
            var src = sfxFree.Pop();
            if (src != null)
            {
                sfxInUse.Add(src);
                return src;
            }
        }

        var go = new GameObject($"SFX_{sfxInUse.Count + sfxFree.Count}");
        go.transform.SetParent(sfxPoolRoot, false);
        var created = go.AddComponent<AudioSource>();
        created.playOnAwake = false;
        created.loop = false;
        sfxInUse.Add(created);
        return created;
    }

    private IEnumerator RecycleSfxAfter(AudioSource src, float clipSeconds)
    {
        if (src == null) yield break;
        // 最小等待，避免 0 长度导致立即回收
        float wait = Mathf.Max(0.01f, clipSeconds);
        yield return new WaitForSecondsRealtime(wait);

        // 若还在播（例如 pitch/时间被改变），再等到真正结束
        while (src != null && src.isPlaying)
            yield return null;

        ReturnSfxSource(src);
    }

    private void ReturnSfxSource(AudioSource src)
    {
        if (src == null) return;
        if (!sfxInUse.Remove(src)) return;

        KillSfxTween(src);
        src.Stop();
        src.clip = null;
        src.volume = 1f;
        sfxFree.Push(src);
    }

    private void KillSfxTween(AudioSource src)
    {
        if (src == null) return;
        if (sfxTweens.TryGetValue(src, out var tw) && tw != null)
            tw.Kill();
        sfxTweens.Remove(src);
    }

    // ----------------------
    // BGM buffer + timeline hook
    // ----------------------

    private void EnqueueBgm(AudioEntrySO entry, float fadeInSecondsOverride)
    {
        if (entry == null) return;

        // Background：单独处理（独立轨道；StopAll 不停）
        if (entry.isBackground)
        {
            pendingBackground = entry;
            pendingBackgroundFadeIn = fadeInSecondsOverride;
            return;
        }

        if (entry.useReplaceLogic)
        {
            // 同一 track 同一小节内多次请求：只保留最后一次
            pendingReplaceByTrack[entry.track] = entry;
            if (fadeInSecondsOverride > 0f) pendingReplaceFadeInByTrack[entry.track] = fadeInSecondsOverride;
            else pendingReplaceFadeInByTrack.Remove(entry.track);
        }
        else
        {
            // 默认：并行叠加（忽略 track）
            pendingParallel.Add(entry);
            pendingParallelFadeIn.Add(fadeInSecondsOverride);
        }
    }

    private void HandleBarBoundary()
    {
        if (timeline == null) return;

        // 1) Background：默认直接替换（不叠加）。若勾选 useReplaceLogic，则走排挤 cross-fade。
        if (pendingBackground != null && pendingBackground.clip != null)
        {
            var bgEntry = pendingBackground;
            float fadeOverride = pendingBackgroundFadeIn;

            if (bgEntry.useReplaceLogic)
                timeline.PlayBgmOnTrack(BgmTrack.Background, bgEntry.clip, bgEntry.volume, fadeOverride);
            else
                timeline.ReplaceBackgroundNoOverlap(bgEntry, fadeOverride);

            pendingBackground = null;
            pendingBackgroundFadeIn = -1f;
        }

        // 2) useReplaceLogic == true：按 track 排挤
        foreach (var kv in pendingReplaceByTrack)
        {
            var track = kv.Key;
            var entry = kv.Value;
            if (entry == null || entry.clip == null) continue;

            if (pendingReplaceFadeInByTrack.TryGetValue(track, out var fadeOverride) && fadeOverride > 0f)
                timeline.PlayBgmOnTrack(entry, fadeOverride);
            else
                timeline.PlayBgmOnTrack(entry);
        }

        pendingReplaceByTrack.Clear();
        pendingReplaceFadeInByTrack.Clear();

        // 3) useReplaceLogic == false & 非Background：并行叠加
        for (int i = 0; i < pendingParallel.Count; i++)
        {
            var entry = pendingParallel[i];
            if (entry == null || entry.clip == null) continue;

            float fadeOverride = pendingParallelFadeIn[i];
            PlayParallelInternal(entry, fadeOverride);
        }
        pendingParallel.Clear();
        pendingParallelFadeIn.Clear();
    }

    // ----------------------
    // Parallel pool (non-background, non-replace)
    // ----------------------

    private readonly List<AudioSource> parallelSources = new();
    private readonly Dictionary<AudioSource, Tween> parallelTweens = new();

    private void PlayParallelInternal(AudioEntrySO entry, float fadeInSecondsOverride)
    {
        if (entry == null || entry.clip == null) return;

        float barRemain = timeline != null ? timeline.GetTimeToNextBar() : GameSetting.BarSeconds;
        if (barRemain <= 0.001f) barRemain = GameSetting.BarSeconds;
        float fadeSeconds = (fadeInSecondsOverride > 0f) ? Mathf.Min(fadeInSecondsOverride, barRemain) : barRemain;

        var src = CreateParallelSource();
        KillParallelTween(src);

        src.loop = true;
        src.clip = entry.clip;
        src.volume = 0f;

        float clipLen = entry.clip.length;
        if (clipLen > 0.001f && timeline != null)
        {
            float offset = Mathf.Repeat(timeline.TimelineTime, clipLen);
            src.time = Mathf.Clamp(offset, 0f, Mathf.Max(0f, clipLen - 0.001f));
        }

        src.Play();
        var tw = src.DOFade(Mathf.Clamp01(entry.volume), Mathf.Max(0.001f, fadeSeconds)).SetUpdate(true);
        parallelTweens[src] = tw;
    }

    private AudioSource CreateParallelSource()
    {
        // Jam 取舍：并行叠加意味着几乎不会“空闲”，因此直接增长池即可
        var go = new GameObject($"BGM_Parallel_{parallelSources.Count}");
        go.transform.SetParent(bgmPoolRoot, false);

        var src = go.AddComponent<AudioSource>();
        src.playOnAwake = false;
        src.loop = true;
        src.volume = 0f;
        parallelSources.Add(src);
        return src;
    }

    private void StopParallelByClip(AudioClip clip, float fadeOutSecondsOverride)
    {
        if (clip == null) return;

        float barRemain = timeline != null ? timeline.GetTimeToNextBar() : GameSetting.BarSeconds;
        if (barRemain <= 0.001f) barRemain = GameSetting.BarSeconds;
        float fadeSeconds = (fadeOutSecondsOverride > 0f) ? Mathf.Min(fadeOutSecondsOverride, barRemain) : barRemain;

        foreach (var src in parallelSources)
        {
            if (src == null || !src.isPlaying) continue;
            if (src.clip != clip) continue;
            FadeOutStopParallel(src, fadeSeconds);
        }
    }

    private void StopAllParallel(float fadeOutSecondsOverride)
    {
        float barRemain = timeline != null ? timeline.GetTimeToNextBar() : GameSetting.BarSeconds;
        if (barRemain <= 0.001f) barRemain = GameSetting.BarSeconds;
        float fadeSeconds = (fadeOutSecondsOverride > 0f) ? Mathf.Min(fadeOutSecondsOverride, barRemain) : barRemain;

        foreach (var src in parallelSources)
        {
            if (src == null || !src.isPlaying) continue;
            FadeOutStopParallel(src, fadeSeconds);
        }
    }

    private void FadeOutStopParallel(AudioSource src, float seconds)
    {
        if (src == null) return;
        KillParallelTween(src);
        var tw = src.DOFade(0f, Mathf.Max(0.001f, seconds)).SetUpdate(true);
        parallelTweens[src] = tw;
        tw.OnComplete(() =>
        {
            if (src == null) return;
            src.Stop();
            src.clip = null;
            src.volume = 0f;
        });
    }

    private void KillParallelTween(AudioSource src)
    {
        if (src == null) return;
        if (parallelTweens.TryGetValue(src, out var tw) && tw != null)
        {
            tw.Kill();
        }
        parallelTweens.Remove(src);
    }

    private bool TryGetEntry(string key, out AudioEntrySO entry)
    {
        entry = null;
        if (string.IsNullOrWhiteSpace(key))
        {
            Debug.LogError("[Audio] key is null/empty");
            return false;
        }

        if (entries.TryGetValue(key, out entry) && entry != null)
            return true;

        Debug.LogError($"[Audio] key not found: '{key}'");
        return false;
    }

    // ----------------------
    // Odin “试音”按钮（做法A）
    // ----------------------

    [FoldoutGroup("Audio Tester"), ShowInInspector, ReadOnly]
    public float DebugTimelineTime => timeline != null ? timeline.TimelineTime : 0f;

    [FoldoutGroup("Audio Tester"), ShowInInspector, ReadOnly]
    public int DebugBarIndex => timeline != null ? timeline.BarIndex : -1;

    [FoldoutGroup("Audio Tester"), ShowInInspector, ReadOnly]
    public float DebugTimeToNextBar => timeline != null ? timeline.GetTimeToNextBar() : 0f;

    [FoldoutGroup("Audio Tester"), Button("Play(BGM)")]
    public void Tester_PlayBgm()
    {
        Play(testerKey);
    }

    [FoldoutGroup("Audio Tester"), Button("Stop(BGM)")]
    public void Tester_StopBgm()
    {
        Stop(testerKey);
    }

    [FoldoutGroup("Audio Tester"), Button("PlayOnce(SFX)")]
    public void Tester_PlaySfxOnce()
    {
        PlaySfxOnce(testerKey, testerSfxVolumeMul);
    }
}


// === Audio\AudioTimeline.cs ===
using System;
using System.Collections.Generic;
using DG.Tweening;
using UnityEngine;

public class AudioTimeline : MonoBehaviour
{
    private sealed class TrackRuntime
    {
        public AudioSource a;
        public AudioSource b;
        public AudioSource active;

        // 每个 source 可能有自己的 fade tween
        public Tween aTween;
        public Tween bTween;
    }

    private readonly Dictionary<BgmTrack, TrackRuntime> tracks = new();

    private int barIndex = -1;
    private float timelineTime;

    public float TimelineTime => timelineTime;
    public int BarIndex => barIndex;

    public event Action OnBarBoundary;

    public void Initialize()
    {
        EnsureTracksCreated();
        barIndex = Mathf.FloorToInt(timelineTime / GameSetting.BarSeconds);
    }

    private void Update()
    {
        // Timeline 不受暂停影响
        timelineTime += Time.unscaledDeltaTime;

        int newBarIndex = Mathf.FloorToInt(timelineTime / GameSetting.BarSeconds);
        if (newBarIndex != barIndex)
        {
            barIndex = newBarIndex;
            OnBarBoundary?.Invoke();
        }
    }

    public float GetTimeToNextBar()
    {
        float t = timelineTime % GameSetting.BarSeconds;
        float remain = GameSetting.BarSeconds - t;
        // t 可能非常接近 0，避免返回 BarSeconds 造成 UI 误解
        return Mathf.Clamp(remain, 0f, GameSetting.BarSeconds);
    }

    public void PlayBgmOnTrack(AudioEntrySO entry, float fadeSecondsOverride = -1f)
    {
        if (entry == null || entry.clip == null) return;
        PlayBgmOnTrack(entry.track, entry.clip, entry.volume, fadeSecondsOverride);
    }

    public void PlayBgmOnTrack(BgmTrack track, AudioClip clip, float volume, float fadeSecondsOverride = -1f)
    {
        if (clip == null) return;

        EnsureTracksCreated();

        if (!tracks.TryGetValue(track, out var tr) || tr == null)
            return;

        float barRemain = GetTimeToNextBar();
        if (barRemain <= 0.001f) barRemain = GameSetting.BarSeconds;
        float fadeSeconds = (fadeSecondsOverride > 0f) ? Mathf.Min(fadeSecondsOverride, barRemain) : barRemain;

        // 选择即将承载新 clip 的 source
        AudioSource newSource = (tr.active == tr.a) ? tr.b : tr.a;
        AudioSource oldSource = tr.active;

        // 旧的在播：并行 cross-fade
        if (oldSource != null && oldSource.isPlaying && oldSource.clip != null)
        {
            FadeOutAndStop(oldSource, fadeSeconds, tr);
        }

        // 设置新 clip + 相位对齐
        newSource.clip = clip;
        newSource.volume = 0f;

        float clipLen = clip.length;
        if (clipLen > 0.001f)
        {
            float offset = Mathf.Repeat(timelineTime, clipLen);
            // Unity 限制：time 不能超过 length
            newSource.time = Mathf.Clamp(offset, 0f, Mathf.Max(0f, clipLen - 0.001f));
        }

        newSource.Play();
        FadeTo(newSource, Mathf.Clamp01(volume), fadeSeconds, tr);

        tr.active = newSource;
    }

    public void StopBgmByKey(AudioEntrySO entry, float fadeSecondsOverride = -1f)
    {
        if (entry == null) return;
        StopClipOnTrack(entry.track, entry.clip, fadeSecondsOverride);
    }

    public void StopClipOnTrack(BgmTrack track, AudioClip clip, float fadeSecondsOverride = -1f)
    {
        if (clip == null) return;
        EnsureTracksCreated();

        if (!tracks.TryGetValue(track, out var tr) || tr == null)
            return;

        float barRemain = GetTimeToNextBar();
        if (barRemain <= 0.001f) barRemain = GameSetting.BarSeconds;
        float fadeSeconds = (fadeSecondsOverride > 0f) ? Mathf.Min(fadeSecondsOverride, barRemain) : barRemain;

        StopIfPlaying(tr.a, clip, fadeSeconds, tr);
        StopIfPlaying(tr.b, clip, fadeSeconds, tr);
    }

    public void StopAllBgm(float fadeSecondsOverride = -1f)
    {
        StopAllBgm(includeBackground: true, fadeSecondsOverride);
    }

    public void StopAllBgm(bool includeBackground, float fadeSecondsOverride = -1f)
    {
        EnsureTracksCreated();

        float barRemain = GetTimeToNextBar();
        if (barRemain <= 0.001f) barRemain = GameSetting.BarSeconds;
        float fadeSeconds = (fadeSecondsOverride > 0f) ? Mathf.Min(fadeSecondsOverride, barRemain) : barRemain;

        foreach (var kv in tracks)
        {
            if (!includeBackground && kv.Key == BgmTrack.Background)
                continue;

            var tr = kv.Value;
            if (tr == null) continue;

            if (tr.a != null && tr.a.isPlaying) FadeOutAndStop(tr.a, fadeSeconds, tr);
            if (tr.b != null && tr.b.isPlaying) FadeOutAndStop(tr.b, fadeSeconds, tr);
            tr.active = null;
        }
    }

    /// <summary>
    /// Background 默认“直接替换”用：不做并行叠加。先硬停轨道内所有 source，再播放新 clip 并淡入。
    /// </summary>
    public void ReplaceBackgroundNoOverlap(AudioEntrySO entry, float fadeInSecondsOverride = -1f)
    {
        if (entry == null || entry.clip == null) return;

        // Background 轨道固定
        EnsureTracksCreated();
        if (!tracks.TryGetValue(BgmTrack.Background, out var tr) || tr == null)
            return;

        // 硬停：避免叠加
        ForceStop(tr.a, tr);
        ForceStop(tr.b, tr);
        tr.active = null;

        // 直接播放并淡入（仍然相位对齐）
        float barRemain = GetTimeToNextBar();
        if (barRemain <= 0.001f) barRemain = GameSetting.BarSeconds;
        float fadeSeconds = (fadeInSecondsOverride > 0f) ? Mathf.Min(fadeInSecondsOverride, barRemain) : barRemain;

        AudioSource src = tr.a;
        src.clip = entry.clip;
        src.volume = 0f;

        float clipLen = entry.clip.length;
        if (clipLen > 0.001f)
        {
            float offset = Mathf.Repeat(timelineTime, clipLen);
            src.time = Mathf.Clamp(offset, 0f, Mathf.Max(0f, clipLen - 0.001f));
        }

        src.Play();
        FadeTo(src, Mathf.Clamp01(entry.volume), fadeSeconds, tr);
        tr.active = src;
    }

    private void ForceStop(AudioSource src, TrackRuntime tr)
    {
        if (src == null) return;
        KillTweenFor(src, tr);
        src.Stop();
        src.clip = null;
        src.volume = 0f;
    }

    private void StopIfPlaying(AudioSource src, AudioClip clip, float fadeOutSeconds, TrackRuntime tr)
    {
        if (src == null || clip == null) return;
        if (!src.isPlaying) return;
        if (src.clip != clip) return;

        FadeOutAndStop(src, fadeOutSeconds, tr);

        if (tr.active == src)
            tr.active = null;
    }

    private void FadeOutAndStop(AudioSource src, float seconds, TrackRuntime tr)
    {
        if (src == null) return;
        KillTweenFor(src, tr);

        // DOTween 需要在 TimeScale=0 也能跑：SetUpdate(true)
        Tween tw = src.DOFade(0f, Mathf.Max(0.001f, seconds)).SetUpdate(true);
        RegisterTweenFor(src, tw, tr);
        tw.OnComplete(() =>
        {
            if (src == null) return;
            src.Stop();
            src.clip = null;
            src.volume = 0f;
        });
    }

    private void FadeTo(AudioSource src, float targetVolume, float seconds, TrackRuntime tr)
    {
        if (src == null) return;
        KillTweenFor(src, tr);

        Tween tw = src.DOFade(targetVolume, Mathf.Max(0.001f, seconds)).SetUpdate(true);
        RegisterTweenFor(src, tw, tr);
    }

    private void RegisterTweenFor(AudioSource src, Tween tw, TrackRuntime tr)
    {
        if (src == tr.a) tr.aTween = tw;
        else if (src == tr.b) tr.bTween = tw;
    }

    private void KillTweenFor(AudioSource src, TrackRuntime tr)
    {
        if (src == tr.a)
        {
            tr.aTween?.Kill();
            tr.aTween = null;
        }
        else if (src == tr.b)
        {
            tr.bTween?.Kill();
            tr.bTween = null;
        }
        else
        {
            // 理论上不会发生：所有 src 都应来自 a/b
            DOTween.Kill(src);
        }
    }

    private void EnsureTracksCreated()
    {
        // 将所有枚举值作为轨道创建出来（Jam：简单粗暴）
        foreach (BgmTrack t in Enum.GetValues(typeof(BgmTrack)))
        {
            if (tracks.ContainsKey(t)) continue;

            var tr = new TrackRuntime();

            tr.a = CreateTrackSource($"{t}_A");
            tr.b = CreateTrackSource($"{t}_B");
            tr.active = null;

            tracks[t] = tr;
        }
    }

    private AudioSource CreateTrackSource(string name)
    {
        var go = new GameObject(name);
        go.transform.SetParent(transform, false);

        var src = go.AddComponent<AudioSource>();
        src.playOnAwake = false;
        src.loop = true; // BGM 默认 loop（若以后需要非 loop，可扩展到 SO）
        src.volume = 0f;
        return src;
    }

    internal void Reset()
    {
        timelineTime = 0;
        StopAllBgm();
    }
}




// === Audio\BgmTrack.cs ===
public enum BgmTrack
{
    // Background 专用独立轨道（StopAll 不会停止）
    Background = 0,

    Track1 = 1,

}




// === Debug\JamMaterialLogicTreeUnityTest.cs ===
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Assertions;

/// <summary>
/// Jam 用的“UnityTest 类”（运行时断言 + Debug.Log）。
/// 目标：验证逻辑树 + Gate_Phase 的算法流程是否符合预期：
/// - 每 1 次行动：攻击 +1
/// - 每 2 次行动：攻击 +3
/// - 结算（PersistentGrowth）：成长攻击 +10
/// </summary>
public sealed class JamMaterialLogicTreeUnityTest : MonoBehaviour
{
    [SerializeField] private bool runOnStart = true;

    private void Start()
    {
        if (!runOnStart) return;
        Run();
    }

    [ContextMenu("Run Jam Material LogicTree UnityTest")]
    public void Run()
    {
        Debug.Log("[JamMaterialLogicTreeUnityTest] Start");

        // ---- Build material prefab instance in memory ----
        var go = new GameObject("tmp_mat_test_go");
        try
        {
            var mat = go.AddComponent<MaterialObj>();

            // Components used by tree
            var phaseAttack = go.AddComponent<Gate_Phase>();
            phaseAttack.Phase = MaterialTraversePhase.AttackModify;

            var every1 = go.AddComponent<Gate_WaitEveryX>();
            every1.EveryX = 1;

            var add1 = go.AddComponent<TestAtk_AddRawAttack>();
            add1.Add = 1f;
            var node1 = go.AddComponent<Node_Effect>();
            node1.Effect = add1;

            var every2 = go.AddComponent<Gate_WaitEveryX>();
            every2.EveryX = 2;

            var add3 = go.AddComponent<TestAtk_AddRawAttack>();
            add3.Add = 3f;
            var node3 = go.AddComponent<Node_Effect>();
            node3.Effect = add3;

            var phaseGrowth = go.AddComponent<Gate_Phase>();
            phaseGrowth.Phase = MaterialTraversePhase.PersistentGrowth;

            var growthAdd = go.AddComponent<TestGrowth_AddAttack>();
            growthAdd.Add = 10f;
            var nodeGrowth = go.AddComponent<Node_Effect>();
            nodeGrowth.Effect = growthAdd;

            // ---- Compose logic tree ----
            var roots = new List<MaterialLogicNode>
            {
                new MaterialLogicNode
                {
                    Component = phaseAttack,
                    Children = new List<MaterialLogicNode>
                    {
                        new MaterialLogicNode
                        {
                            Component = every1,
                            Children = new List<MaterialLogicNode>
                            {
                                new MaterialLogicNode { Component = node1 }
                            }
                        },
                        new MaterialLogicNode
                        {
                            Component = every2,
                            Children = new List<MaterialLogicNode>
                            {
                                new MaterialLogicNode { Component = node3 }
                            }
                        }
                    }
                },
                new MaterialLogicNode
                {
                    Component = phaseGrowth,
                    Children = new List<MaterialLogicNode>
                    {
                        new MaterialLogicNode { Component = nodeGrowth }
                    }
                }
            };

            SetPrivateLogicTreeRoots(mat, roots);

            // ---- Validate AttackModify: action#1 => +1 ----
            var fc = new FightContext
            {
                CurrentAttackerSide = FightSide.Player,
                CurrentActionNumber = 1,
                CurrentAttackerAttackNumber = 1,
                DebugVerbose = false,
            };

            var runner = new MaterialRuntimeRunner(mat);
            var info = new AttackInfo { RawAttack = 0f, BaseValue = 0f, CritChance = 0f, CritMultiplier = 1f, IsCrit = false, FinalDamage = 0f };
            runner.Modify(ref info, fc);
            Assert.AreApproximatelyEqual(1f, info.RawAttack, 0.0001f, "Action#1 应仅触发 +1");

            // ---- Validate AttackModify: action#2 => +1 +3 ----
            fc.CurrentActionNumber = 2;
            fc.CurrentAttackerAttackNumber = 2;
            info.RawAttack = 0f;
            runner.Modify(ref info, fc);
            Assert.AreApproximatelyEqual(4f, info.RawAttack, 0.0001f, "Action#2 应触发 +1 与 +3");

            // ---- Validate AttackModify: action#3 => +1 ----
            fc.CurrentActionNumber = 3;
            fc.CurrentAttackerAttackNumber = 3;
            info.RawAttack = 0f;
            runner.Modify(ref info, fc);
            Assert.AreApproximatelyEqual(1f, info.RawAttack, 0.0001f, "Action#3 应仅触发 +1");

            // ---- Validate PersistentGrowth ----
            var delta = new PlayerGrowthDelta();
            var growthCtx = new MaterialVommandeTreeContext(
                MaterialTraversePhase.PersistentGrowth,
                mask: null,
                maskMaterials: null,
                onMaterialBound: null,
                fight: fc,
                side: FightSide.None,
                defenderSide: FightSide.None,
                actionNumber: 0,
                attackerAttackNumber: 0,
                attackInfo: default,
                damage: 0f,
                player: null,
                growthDelta: delta
            );
            TraverseTree_PersistentGrowth(mat.LogicTreeRoots, in growthCtx, delta, fc);
            Assert.AreApproximatelyEqual(10f, delta.AddAttack, 0.0001f, "PersistentGrowth 应写入 +10 攻击成长");

            Debug.Log("[JamMaterialLogicTreeUnityTest] PASS");
        }
        finally
        {
            Destroy(go);
        }
    }

    private static void SetPrivateLogicTreeRoots(MaterialObj mat, List<MaterialLogicNode> roots)
    {
        var f = typeof(MaterialObj).GetField("logicTreeRoots", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);
        Assert.IsNotNull(f, "找不到 MaterialObj.logicTreeRoots 私有字段（字段名变了？）");
        f.SetValue(mat, roots);
    }

    private static void TraverseTree_PersistentGrowth(IReadOnlyList<MaterialLogicNode> nodes, in MaterialVommandeTreeContext tctx, PlayerGrowthDelta delta, FightContext fight)
    {
        if (nodes == null) return;
        for (int i = 0; i < nodes.Count; i++)
        {
            var n = nodes[i];
            if (n == null) continue;
            var c = n.Component;

            if (c is IMaterialTraversalGate gate && gate.ShouldBreak(in tctx))
            {
                continue;
            }

            if (c is IPersistentGrowthProvider p)
            {
                p.OnCollectPersistentGrowth(null, delta, fight);
            }

            if ((c == null || c is IMaterialTraversalGate) && n.Children != null && n.Children.Count > 0)
            {
                TraverseTree_PersistentGrowth(n.Children, in tctx, delta, fight);
            }
        }
    }

    private sealed class TestAtk_AddRawAttack : MonoBehaviour, IMaterialAttackInfoEffect, IMaterialDescriptionProvider
    {
        public float Add = 1f;

        public void Modify(ref AttackInfo info, in MaterialVommandeTreeContext context)
        {
            info.RawAttack += Add;
        }

        public void AppendDescription(System.Text.StringBuilder sb)
        {
            if (sb == null) return;
            sb.Append($"攻击 {(Add >= 0 ? "+" : "")}{Add:0.##}");
        }
    }

    private sealed class TestGrowth_AddAttack : MonoBehaviour, IMaterialEffect, IMaterialDescriptionProvider
    {
        public float Add = 10f;

        public void Execute(in MaterialVommandeTreeContext context)
        {
            if (context.GrowthDelta == null) return;
            context.GrowthDelta.AddAttack += Add;
        }

        public void AppendDescription(System.Text.StringBuilder sb)
        {
            if (sb == null) return;
            sb.Append($"成长攻击 {(Add >= 0 ? "+" : "")}{Add:0.##}");
        }
    }
}




// === Debug\JamSpawnMaterialToInventoryTool.cs ===
using Sirenix.OdinInspector;
using UnityEngine;

/// <summary>
/// Jam 测试工具：拖入一个 MaterialObj prefab，点击按钮即可实例化并加入材料库存。
/// </summary>
public sealed class JamSpawnMaterialToInventoryTool : MonoBehaviour
{
    [Title("Jam：材料入库测试工具")]
    [InfoBox("拖入一个 MaterialObj prefab，点击“生成并入库”。会走 GameManager.DebugSpawnMaterialToInventory。")]

    [AssetsOnly]
    [InlineEditor(InlineEditorObjectFieldModes.Boxed)]
    [LabelText("材料 Prefab")]
    public MaterialObj MaterialPrefab;

    [Button(ButtonSizes.Large)]
    [LabelText("生成并入库")]
    private void Spawn()
    {
        if (GameManager.I == null)
        {
            Debug.LogError("[JamSpawnMaterialToInventoryTool] GameManager.I 为空，无法入库。", this);
            return;
        }
        if (MaterialPrefab == null)
        {
            Debug.LogWarning("[JamSpawnMaterialToInventoryTool] MaterialPrefab 为空。", this);
            return;
        }

        GameManager.I.DebugSpawnMaterialToInventory(MaterialPrefab);
    }
}




// === Debug\JamTestMonsterSpawnLogic.cs ===
using UnityEngine;

/// <summary>
/// Jam 测试逻辑：当策划还没配置任何怪物列表时，提供一个可跑流程的默认怪物生成。
/// </summary>
public class JamTestMonsterSpawnLogic : MonoBehaviour, IMonsterSpawnLogic
{
    [Header("Base")]
    [SerializeField] private float baseHP = 140f;
    [SerializeField] private float baseATK = 40f;
    [SerializeField] private float baseDEF = 60f;
    [SerializeField] private int baseSpeedRate = 12;

    [Header("Per Round Growth")]
    [SerializeField] private float hpPerRound = 30f;
    [SerializeField] private float atkPerRound = 15f;
    [SerializeField] private float defPerRound = 20f;
    [SerializeField] private int speedPerRound = 5;

    public CharacterConfig TrySpawn(int roundIndex, FightContext context)
    {
        // roundIndex 从 0 开始
        //int r = Mathf.Max(0, roundIndex);
        int r = 0;
        if(roundIndex <= 5 && roundIndex >=1)
        {
           r = (roundIndex + 3) / 3;  
        }
        else if(roundIndex <= 20 && roundIndex > 5)
        {
            r = (roundIndex + 5) / 5;
        }
        else if(roundIndex > 20)
        {
            r = (roundIndex - 1) / 20;
        }
        return new CharacterConfig
        {
            HPBase = baseHP + hpPerRound * r,
            ATKBase = baseATK + atkPerRound * r,
            DEFBase = baseDEF + defPerRound * r,
            CritChance = 0.05f,
            CritMultiplier = 1.5f,
            SpeedRate = Mathf.Max(0, baseSpeedRate + speedPerRound * r),
        };
    }
}





// === Editor\CsprojUniTaskFixer.cs ===
#if UNITY_EDITOR
using System;
using UnityEditor;

/// <summary>
/// Unity 会频繁重生成 csproj，导致 UniTask 的引用丢失，从而影响 IDE/Linter。
/// 这里在生成 Assembly-CSharp.csproj 时自动补一条 UniTask.dll 引用（不使用绝对路径）。
/// </summary>
public class CsprojUniTaskFixer : AssetPostprocessor
{
    private const string UniTaskRef =
@"    <Reference Include=""UniTask"">
      <HintPath>$(MSBuildProjectDirectory)\Library\ScriptAssemblies\UniTask.dll</HintPath>
      <Private>False</Private>
    </Reference>
";

    public static string OnGeneratedCSProject(string path, string content)
    {
        if (string.IsNullOrWhiteSpace(path) || string.IsNullOrWhiteSpace(content)) return content;
        if (!path.EndsWith("Assembly-CSharp.csproj", StringComparison.OrdinalIgnoreCase)) return content;
        if (content.Contains("Include=\"UniTask\"")) return content;

        // 插在 UnityEngine Reference 后面
        var key = "    <Reference Include=\"UnityEngine\">";
        var idx = content.IndexOf(key, StringComparison.Ordinal);
        if (idx < 0) return content;

        // 找到该 Reference 的结束 </Reference>
        var endIdx = content.IndexOf("    </Reference>", idx, StringComparison.Ordinal);
        if (endIdx < 0) return content;

        endIdx += "    </Reference>".Length;
        content = content.Insert(endIdx + Environment.NewLine.Length, UniTaskRef);
        return content;
    }
}
#endif





// === Editor\MaterialEditorWindow.cs ===
#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using Sirenix.OdinInspector;
using Sirenix.OdinInspector.Editor;
using UnityEditor;
using UnityEngine;

public class MaterialEditorWindow : OdinEditorWindow
{
    [MenuItem("GGJ2026/材料编辑器")]
    private static void Open()
    {
        var w = GetWindow<MaterialEditorWindow>();
        w.titleContent = new GUIContent("材料编辑器");
        w.Show();
    }

    [TitleGroup("文件夹", Alignment = TitleAlignments.Left)]
    [InfoBox("选择一个文件夹（默认：Assets/Resources/Mat），左侧会列出其中所有带 MaterialObj 的 Prefab。")]
    [SerializeField] private DefaultAsset folderAsset;

    [TitleGroup("文件夹")]
    [ShowInInspector, ReadOnly]
    private string FolderPath => folderAsset != null ? AssetDatabase.GetAssetPath(folderAsset) : _defaultFolder;

    private const string _defaultFolder = "Assets/Resources/Mat";

    [TitleGroup("左侧列表")]
    [ShowInInspector, ReadOnly]
    private List<PrefabEntry> Prefabs => _prefabs;
    private readonly List<PrefabEntry> _prefabs = new();

    private PrefabEntry _selectedEntry;

    private GameObject _editingInstance;
    private MaterialObj _editingMaterial;
    private string _selectedPrefabPath;

    // Add Component UI
    private string _componentSearch = "";
    private Vector2 _leftScroll;
    private Vector2 _rightScroll;

    private readonly List<Type> _materialComponentTypes = new();

    protected override void OnEnable()
    {
        base.OnEnable();

        if (folderAsset == null)
        {
            folderAsset = AssetDatabase.LoadAssetAtPath<DefaultAsset>(_defaultFolder);
        }

        CacheMaterialComponentTypes();
        Refresh();
    }

    protected override void OnDisable()
    {
        base.OnDisable();
        CleanupEditingInstance();
    }

    [Button("刷新列表", ButtonSizes.Medium)]
    private void Refresh()
    {
        LoadPrefabsFromFolder(FolderPath);
        if (_selectedEntry != null)
        {
            SelectByPath(_selectedEntry.Path);
        }
    }

    [Button("创建新材质（Prefab）", ButtonSizes.Medium)]
    private void CreateNew()
    {
        var folder = FolderPath;
        if (string.IsNullOrWhiteSpace(folder) || !AssetDatabase.IsValidFolder(folder))
        {
            Debug.LogError("[材料编辑器] 文件夹无效，请先选择正确的文件夹。");
            return;
        }

        CleanupEditingInstance();

        var go = new GameObject("NewMaterial");
        // 注意：不能使用 HideAndDontSave，否则 PrefabUtility.SaveAsPrefabAsset 会报：
        // "No objects were found for saving into prefab. Have you marked all objects with DontSave?"
        // 我们只隐藏到 Hierarchy，不使用 DontSave。
        go.hideFlags = HideFlags.HideInHierarchy;
        var mat = go.AddComponent<MaterialObj>();

        mat.Id = GetNextIdOrDefault(folder);
        mat.DisplayName = "新材质";
        mat.ResetInventoryShelfLife();

        _editingInstance = go;
        _editingMaterial = mat;
        _selectedPrefabPath = null;
        _selectedEntry = null;
    }

    protected override void OnGUI()
    {
        if (folderAsset == null)
        {
            // ensure default
            folderAsset = AssetDatabase.LoadAssetAtPath<DefaultAsset>(_defaultFolder);
        }

        EditorGUILayout.BeginHorizontal();
        DrawLeft();
        DrawRight();
        EditorGUILayout.EndHorizontal();
    }

    private void DrawLeft()
    {
        EditorGUILayout.BeginVertical(GUILayout.Width(320));

        EditorGUILayout.LabelField("文件夹", EditorStyles.boldLabel);
        folderAsset = (DefaultAsset)EditorGUILayout.ObjectField(folderAsset, typeof(DefaultAsset), false);

        EditorGUILayout.BeginHorizontal();
        if (GUILayout.Button("刷新", GUILayout.Height(24))) Refresh();
        if (GUILayout.Button("创建", GUILayout.Height(24))) CreateNew();
        EditorGUILayout.EndHorizontal();

        EditorGUILayout.Space(6);
        _leftScroll = EditorGUILayout.BeginScrollView(_leftScroll);

        for (int i = 0; i < _prefabs.Count; i++)
        {
            var e = _prefabs[i];
            bool selected = _selectedEntry != null && _selectedEntry.Path == e.Path;

            using (new EditorGUILayout.HorizontalScope(selected ? EditorStyles.helpBox : GUIStyle.none))
            {
                var label = $"{e.Id}  {e.DisplayName}";
                if (GUILayout.Button(label, GUILayout.ExpandWidth(true)))
                {
                    SelectEntry(e);
                }
            }
        }

        EditorGUILayout.EndScrollView();
        EditorGUILayout.EndVertical();
    }

    private void DrawRight()
    {
        EditorGUILayout.BeginVertical();
        _rightScroll = EditorGUILayout.BeginScrollView(_rightScroll);

        EditorGUILayout.LabelField("材质信息", EditorStyles.boldLabel);

        if (_editingMaterial == null)
        {
            EditorGUILayout.HelpBox("未选择材质。请在左侧选择一个 prefab，或点击“创建”。", MessageType.Info);
            EditorGUILayout.EndScrollView();
            EditorGUILayout.EndVertical();
            return;
        }

        DrawMaterialBaseFields(_editingMaterial);

        EditorGUILayout.Space(10);
        DrawLogicTreeEditor();

        EditorGUILayout.Space(10);
        if (GUILayout.Button("保存到文件夹（按 {id}_{材质名} 命名）", GUILayout.Height(36)))
        {
            Save();
        }

        EditorGUILayout.EndScrollView();
        EditorGUILayout.EndVertical();
    }

    private void DrawMaterialBaseFields(MaterialObj mat)
    {
        using (new EditorGUILayout.VerticalScope(EditorStyles.helpBox))
        {
            EditorGUILayout.LabelField("基础信息", EditorStyles.boldLabel);

            mat.Id = Mathf.Max(0, EditorGUILayout.IntField("ID", mat.Id));
            mat.DisplayName = EditorGUILayout.TextField("材质名", mat.DisplayName);
            mat.Type = (MaterialObj.MaterialType)EditorGUILayout.EnumPopup("类型", mat.Type);
            mat.BaseSprite = (Sprite)EditorGUILayout.ObjectField("Sprite", mat.BaseSprite, typeof(Sprite), false);
            mat.Quality = (MaterialQuality)EditorGUILayout.EnumPopup("品质", mat.Quality);
            mat.ManaCost = Mathf.Max(0, EditorGUILayout.IntField("法力消耗", mat.ManaCost));
            mat.ShelfLifeTurns = Mathf.Max(1, EditorGUILayout.IntField("保质期（回合）", mat.ShelfLifeTurns));

            if (GUILayout.Button("重置剩余保质期（用于测试显示）"))
            {
                mat.ResetInventoryShelfLife();
            }
            EditorGUILayout.LabelField("剩余保质期（运行时）", mat.RemainingShelfLifeTurns.ToString());
        }
    }

    // orderedComponents 链式方案已移除；材质编辑器只保留“逻辑树”配置入口。

    private void DrawLogicTreeEditor()
    {
        using (new EditorGUILayout.VerticalScope(EditorStyles.helpBox))
        {
            EditorGUILayout.LabelField("逻辑树（树状配置）", EditorStyles.boldLabel);
            EditorGUILayout.HelpBox(
                "说明：运行时只使用“树状逻辑”。\n" +
                "条件节点（Gate）不满足时只会跳过该分支，不会终止整个遍历。组件可被多个节点复用（节点只是引用）。",
                MessageType.Info);

            if (_editingMaterial == null) return;

            var so = new SerializedObject(_editingMaterial);
            so.Update();
            var roots = so.FindProperty("logicTreeRoots");
            if (roots == null || !roots.isArray)
            {
                EditorGUILayout.HelpBox("找不到 MaterialObj.logicTreeRoots 字段（序列化）。", MessageType.Error);
                return;
            }

            using (new EditorGUILayout.HorizontalScope())
            {
                if (GUILayout.Button("添加 Root（搜索）", GUILayout.Width(140)))
                {
                    var r = GUILayoutUtility.GetLastRect();
                    ShowAddNodePopup(r, roots.propertyPath);
                }
                if (GUILayout.Button("清空逻辑树", GUILayout.Width(100)))
                {
                    if (EditorUtility.DisplayDialog("清空逻辑树", "确认清空所有逻辑树节点？（不会删除组件本体）", "清空", "取消"))
                    {
                        // 递归清空（保证“清空=清空整棵树”）
                        for (int i = roots.arraySize - 1; i >= 0; i--)
                        {
                            DeleteNodeRecursive(roots, i);
                        }
                    }
                }
            }

            EditorGUILayout.Space(6);
            DrawNodeArray(roots, 0);

            // 树状最终描述预览（\t 代表层级）
            if (_editingMaterial != null)
            {
                EditorGUILayout.Space(10);
                EditorGUILayout.LabelField("最终描述预览（树状，\\t 表示层级）", EditorStyles.boldLabel);
                var desc = _editingMaterial.BuildDescription();
                if (string.IsNullOrWhiteSpace(desc)) desc = "(空)";
                EditorGUILayout.HelpBox(desc, MessageType.None);
            }

            if (so.ApplyModifiedProperties())
            {
                EditorUtility.SetDirty(_editingMaterial);
                Repaint();
            }
        }
    }

    private static void AddNewNodeToArray(SerializedProperty arrayProp)
    {
        if (arrayProp == null || !arrayProp.isArray) return;
        int idx = arrayProp.arraySize;
        arrayProp.InsertArrayElementAtIndex(idx);
        var elem = arrayProp.GetArrayElementAtIndex(idx);
        // 新建节点时把引用清空，避免 Unity 复制上一个元素的值
        elem.FindPropertyRelative("Title").stringValue = "";
        var expanded = elem.FindPropertyRelative("Expanded");
        if (expanded != null) expanded.boolValue = true;
        elem.FindPropertyRelative("Component").objectReferenceValue = null;
        elem.FindPropertyRelative("Role").enumValueIndex = 0; // Auto
        elem.FindPropertyRelative("ActionSide").enumValueIndex = 0; // Both
        var children = elem.FindPropertyRelative("Children");
        if (children != null && children.isArray) children.ClearArray();
    }

    private static void AddNewNodeToArray(SerializedProperty arrayProp, MonoBehaviour comp)
    {
        AddNewNodeToArray(arrayProp);
        if (arrayProp == null || !arrayProp.isArray) return;
        var elem = arrayProp.GetArrayElementAtIndex(arrayProp.arraySize - 1);
        var compProp = elem.FindPropertyRelative("Component");
        if (compProp != null) compProp.objectReferenceValue = comp;
        var titleProp = elem.FindPropertyRelative("Title");
        if (titleProp != null && comp != null && string.IsNullOrWhiteSpace(titleProp.stringValue))
        {
            titleProp.stringValue = comp.GetType().Name;
        }
    }

    private void DrawNodeArray(SerializedProperty arrayProp, int indent)
    {
        if (arrayProp == null || !arrayProp.isArray) return;
        for (int i = 0; i < arrayProp.arraySize; i++)
        {
            var node = arrayProp.GetArrayElementAtIndex(i);
            DrawSingleNode(arrayProp, node, i, indent);
        }
    }

    private void DrawSingleNode(SerializedProperty parentArray, SerializedProperty node, int index, int indent)
    {
        if (node == null) return;

        using (new EditorGUILayout.VerticalScope(EditorStyles.helpBox))
        {
            using (new EditorGUILayout.HorizontalScope())
            {
                GUILayout.Space(indent * 14);

                var titleProp = node.FindPropertyRelative("Title");
                var compProp = node.FindPropertyRelative("Component");
                var roleProp = node.FindPropertyRelative("Role");
                var sideProp = node.FindPropertyRelative("ActionSide");
                var expandedProp = node.FindPropertyRelative("Expanded");

                string title = titleProp != null ? titleProp.stringValue : "";
                var comp = compProp != null ? compProp.objectReferenceValue as MonoBehaviour : null;
                var header = BuildNodeHeader(title, comp);
                bool expanded = expandedProp == null || expandedProp.boolValue;
                expanded = EditorGUILayout.Foldout(expanded, header, true);
                if (expandedProp != null) expandedProp.boolValue = expanded;

                GUI.enabled = index > 0;
                if (GUILayout.Button("↑", GUILayout.Width(28))) parentArray.MoveArrayElement(index, index - 1);
                GUI.enabled = index < parentArray.arraySize - 1;
                if (GUILayout.Button("↓", GUILayout.Width(28))) parentArray.MoveArrayElement(index, index + 1);
                GUI.enabled = true;

                // 只有“逻辑节点（gate/未选组件）”允许添加子节点
                bool isLogicNode = comp == null || comp is IMaterialTraversalGate;
                if (isLogicNode)
                {
                    if (GUILayout.Button("+", GUILayout.Width(28)))
                    {
                        var childArray = node.FindPropertyRelative("Children");
                        if (childArray != null && childArray.isArray)
                        {
                            var r = GUILayoutUtility.GetLastRect();
                            ShowAddNodePopup(r, childArray.propertyPath);
                        }
                    }
                }

                if (GUILayout.Button("删", GUILayout.Width(28)))
                {
                    DeleteNodeRecursive(parentArray, index);
                    // 结构变化，退出避免索引错乱（注意：DeleteNodeRecursive 内部已 Apply）
                    GUIUtility.ExitGUI();
                }
            }

            var expandedNow = node.FindPropertyRelative("Expanded");
            if (expandedNow != null && !expandedNow.boolValue) return;

            GUILayout.Space(2);
            using (new EditorGUILayout.HorizontalScope())
            {
                var titleProp = node.FindPropertyRelative("Title");
                GUILayout.Space(indent * 14);
                if (titleProp != null) EditorGUILayout.PropertyField(titleProp);
            }

            using (new EditorGUILayout.HorizontalScope())
            {
                var compProp = node.FindPropertyRelative("Component");
                GUILayout.Space(indent * 14);
                if (compProp != null) EditorGUILayout.PropertyField(compProp);
            }

            // 严格约束：非逻辑节点不允许挂在树里
            var compCheck = node.FindPropertyRelative("Component")?.objectReferenceValue as MonoBehaviour;
            if (compCheck != null && !(compCheck is IMaterialLogicNode))
            {
                EditorGUILayout.HelpBox("该组件不是逻辑节点（未实现 IMaterialLogicNode），不允许挂在逻辑树里：已自动清空。", MessageType.Error);
                node.FindPropertyRelative("Component").objectReferenceValue = null;
                compCheck = null;
            }

            // 移除 Role/ActionSide 配置入口：逻辑完全由 Gate_Phase 区分事件；作用对象由 effect 自己决定（默认玩家）。

            // 提示：组件应来自当前 editingInstance
            var comp2 = node.FindPropertyRelative("Component")?.objectReferenceValue as MonoBehaviour;
            if (comp2 != null && _editingInstance != null && comp2.gameObject != _editingInstance)
            {
                EditorGUILayout.HelpBox("该节点引用的组件不在当前材质 prefab 上（可能导致运行时无效）。建议只引用当前 prefab 上的组件。", MessageType.Warning);
            }

            // 参数编辑：直接在逻辑树节点内编辑组件参数（组件可复用）
            if (comp2 != null && !(comp2 is MaterialObj))
            {
                EditorGUILayout.Space(4);
                using (new EditorGUILayout.VerticalScope(EditorStyles.helpBox))
                {
                    EditorGUILayout.LabelField("节点参数（编辑组件字段）", EditorStyles.miniBoldLabel);
                    var so2 = new SerializedObject(comp2);
                    so2.Update();
                    var it = so2.GetIterator();
                    bool enterChildren = true;
                    while (it.NextVisible(enterChildren))
                    {
                        enterChildren = false;
                        if (it.name == "m_Script") continue;
                        if (it.propertyType == SerializedPropertyType.String && it.name == "description") continue;
                        EditorGUILayout.PropertyField(it, true);
                    }
                    if (so2.ApplyModifiedProperties())
                    {
                        EditorUtility.SetDirty(comp2);
                    }
                }
            }

            // Node_Effect：额外把 Effect 的参数直接嵌入显示（策划真正需要配置的是 Effect）
            if (comp2 is Node_Effect ne && ne != null && ne.Effect != null)
            {
                EditorGUILayout.Space(4);
                using (new EditorGUILayout.VerticalScope(EditorStyles.helpBox))
                {
                    EditorGUILayout.LabelField($"效果器参数（{ne.Effect.GetType().Name}）", EditorStyles.miniBoldLabel);
                    var soE = new SerializedObject(ne.Effect);
                    soE.Update();
                    var itE = soE.GetIterator();
                    bool enterChildrenE = true;
                    while (itE.NextVisible(enterChildrenE))
                    {
                        enterChildrenE = false;
                        if (itE.name == "m_Script") continue;
                        if (itE.propertyType == SerializedPropertyType.String && itE.name == "description") continue;
                        EditorGUILayout.PropertyField(itE, true);
                    }
                    if (soE.ApplyModifiedProperties())
                    {
                        EditorUtility.SetDirty(ne.Effect);
                    }
                }
            }

            var children = node.FindPropertyRelative("Children");
            using (new EditorGUILayout.HorizontalScope())
            {
                GUILayout.Space(indent * 14);
                // 添加统一走 header 的 “+ 搜索”
                if (GUILayout.Button("添加同级节点", GUILayout.Width(90)))
                {
                    int insertAt = index + 1;
                    parentArray.InsertArrayElementAtIndex(insertAt);
                    var elem = parentArray.GetArrayElementAtIndex(insertAt);
                    elem.FindPropertyRelative("Title").stringValue = "";
                    var expanded = elem.FindPropertyRelative("Expanded");
                    if (expanded != null) expanded.boolValue = true;
                    elem.FindPropertyRelative("Component").objectReferenceValue = null;
                    elem.FindPropertyRelative("Role").enumValueIndex = 0;
                    elem.FindPropertyRelative("ActionSide").enumValueIndex = 0;
                    var ch = elem.FindPropertyRelative("Children");
                    if (ch != null && ch.isArray) ch.ClearArray();
                }
            }

            // 非逻辑节点不显示子节点配置
            if ((comp2 == null || comp2 is IMaterialTraversalGate) && children != null && children.isArray && children.arraySize > 0)
            {
                EditorGUILayout.Space(4);
                DrawNodeArray(children, indent + 1);
            }
        }
    }

    /// <summary>
    /// 删除一个节点，并递归清空其所有子节点。
    /// 关键点：删除后必须立刻 ApplyModifiedProperties，否则如果调用了 ExitGUI 会导致删除“不生效”。
    /// </summary>
    private void DeleteNodeRecursive(SerializedProperty parentArray, int index)
    {
        if (parentArray == null || !parentArray.isArray) return;
        if (index < 0 || index >= parentArray.arraySize) return;

        var so = parentArray.serializedObject;
        if (so == null) return;

        so.Update();

        // 删除节点时，也删除对应的组件（会做引用计数，避免误删“被多个节点复用”的组件）
        // - 删除规则：只有当组件不再被任何树节点引用时才 Destroy
        // - 组件必须在当前 _editingInstance 上（避免误删引用到别处的对象）
        var toMaybeDeleteNodes = new List<MonoBehaviour>(8);
        var toMaybeDeleteEffects = new List<MonoBehaviour>(8);
        try
        {
            var roots = so.FindProperty("logicTreeRoots");
            var nodeForCollect = parentArray.GetArrayElementAtIndex(index);
            CollectComponentsInSubtree(nodeForCollect, toMaybeDeleteNodes, toMaybeDeleteEffects);

            // 先递归清空 Children，确保“删除树节点 = 删除整棵子树”
            var node = parentArray.GetArrayElementAtIndex(index);
            RecursiveClearChildren(node);

            int oldSize = parentArray.arraySize;
            parentArray.DeleteArrayElementAtIndex(index);
            // 某些情况下第一次 Delete 只会置空不缩容，这里做一次兜底
            if (parentArray.arraySize == oldSize && index >= 0 && index < parentArray.arraySize)
            {
                parentArray.DeleteArrayElementAtIndex(index);
            }

            so.ApplyModifiedProperties();

            // 结构更新后：检查引用计数再删组件
            if (_editingInstance != null && roots != null && roots.isArray)
            {
                // 先删 Effect（避免 Node_Effect 先删后引用丢失导致计数误判）
                for (int i = 0; i < toMaybeDeleteEffects.Count; i++)
                {
                    var eff = toMaybeDeleteEffects[i];
                    if (eff == null) continue;
                    if (eff.gameObject != _editingInstance) continue;
                    if (CountEffectRefsInTree(roots, eff) > 0) continue;
                    Undo.DestroyObjectImmediate(eff);
                }

                for (int i = 0; i < toMaybeDeleteNodes.Count; i++)
                {
                    var c = toMaybeDeleteNodes[i];
                    if (c == null) continue;
                    if (c.gameObject != _editingInstance) continue;
                    if (CountComponentRefsInTree(roots, c) > 0) continue;
                    Undo.DestroyObjectImmediate(c);
                }
            }
        }
        catch
        {
            // ignore
        }
        finally
        {
            if (_editingMaterial != null) EditorUtility.SetDirty(_editingMaterial);
            Repaint();
        }

        return;

    }

    private static void CollectComponentsInSubtree(SerializedProperty nodeProp, List<MonoBehaviour> outNodeComps, List<MonoBehaviour> outEffects)
    {
        if (nodeProp == null) return;
        var compProp = nodeProp.FindPropertyRelative("Component");
        var comp = compProp != null ? compProp.objectReferenceValue as MonoBehaviour : null;
        if (comp != null)
        {
            outNodeComps?.Add(comp);
            if (comp is Node_Effect ne && ne != null && ne.Effect != null)
            {
                outEffects?.Add(ne.Effect);
            }
        }

        var children = nodeProp.FindPropertyRelative("Children");
        if (children == null || !children.isArray) return;
        for (int i = 0; i < children.arraySize; i++)
        {
            var child = children.GetArrayElementAtIndex(i);
            CollectComponentsInSubtree(child, outNodeComps, outEffects);
        }
    }

    private static int CountComponentRefsInTree(SerializedProperty nodesArray, MonoBehaviour target)
    {
        if (nodesArray == null || !nodesArray.isArray || target == null) return 0;
        int count = 0;
        for (int i = 0; i < nodesArray.arraySize; i++)
        {
            var node = nodesArray.GetArrayElementAtIndex(i);
            var comp = node.FindPropertyRelative("Component")?.objectReferenceValue as MonoBehaviour;
            if (comp == target) count++;

            var children = node.FindPropertyRelative("Children");
            if (children != null && children.isArray && children.arraySize > 0)
            {
                count += CountComponentRefsInTree(children, target);
            }
        }
        return count;
    }

    private static int CountEffectRefsInTree(SerializedProperty nodesArray, MonoBehaviour targetEffect)
    {
        if (nodesArray == null || !nodesArray.isArray || targetEffect == null) return 0;
        int count = 0;
        for (int i = 0; i < nodesArray.arraySize; i++)
        {
            var node = nodesArray.GetArrayElementAtIndex(i);
            var comp = node.FindPropertyRelative("Component")?.objectReferenceValue as MonoBehaviour;
            if (comp is Node_Effect ne && ne != null && ne.Effect == targetEffect) count++;

            var children = node.FindPropertyRelative("Children");
            if (children != null && children.isArray && children.arraySize > 0)
            {
                count += CountEffectRefsInTree(children, targetEffect);
            }
        }
        return count;
    }

    private static void RecursiveClearChildren(SerializedProperty nodeProp)
    {
        if (nodeProp == null) return;
        var children = nodeProp.FindPropertyRelative("Children");
        if (children == null || !children.isArray) return;

        for (int i = children.arraySize - 1; i >= 0; i--)
        {
            var child = children.GetArrayElementAtIndex(i);
            RecursiveClearChildren(child);
            children.DeleteArrayElementAtIndex(i);
            // managed type 通常一次就能删；这里做一次兜底
            if (i < children.arraySize && children.GetArrayElementAtIndex(i) == null)
            {
                children.DeleteArrayElementAtIndex(i);
            }
        }
        children.ClearArray();
    }

    private void ShowAddNodePopup(Rect activatorRect, string targetArrayPath)
    {
        if (string.IsNullOrWhiteSpace(targetArrayPath)) return;
        if (_editingInstance == null) return;
        if (_editingMaterial == null) return;

        NodeAddPopupWindow.Show(
            activatorRect,
            _editingInstance,
            _materialComponentTypes,
            onPickNew: t =>
            {
                if (t == null) return;
                var added = Undo.AddComponent(_editingInstance, t) as MonoBehaviour;
                if (added == null) return;
                var so = new SerializedObject(_editingMaterial);
                so.Update();
                var arr = so.FindProperty(targetArrayPath);
                if (arr == null || !arr.isArray) return;
                Undo.RecordObject(_editingMaterial, "Add Logic Node");
                AddPickedComponentAsNode(arr, added);
                so.ApplyModifiedProperties();
                EditorUtility.SetDirty(_editingMaterial);
                EditorUtility.SetDirty(added);
                Repaint();
            }
        );
    }

    /// <summary>
    /// 弹窗选择后：把“逻辑节点”直接加入树；把“纯效果器”包装成 Node_Effect 再加入树。
    /// </summary>
    private void AddPickedComponentAsNode(SerializedProperty targetArray, MonoBehaviour picked)
    {
        if (targetArray == null || !targetArray.isArray) return;
        if (picked == null) return;

        // 逻辑节点：可直接进入树
        if (picked is IMaterialLogicNode)
        {
            AddNewNodeToArray(targetArray, picked);
            return;
        }

        // 纯效果器：必须用 Node_Effect 包装后才能进树
        if (picked is IMaterialEffect || picked is IMaterialAttackInfoEffect)
        {
            var node = Undo.AddComponent(_editingInstance, typeof(Node_Effect)) as Node_Effect;
            if (node == null) return;
            node.Effect = picked;
            EditorUtility.SetDirty(node);
            AddNewNodeToArray(targetArray, node);
            return;
        }
    }

    private static string BuildNodeHeader(string title, MonoBehaviour comp)
    {
        var t = comp != null ? comp.GetType().Name : "未选择组件";

        var name = string.IsNullOrWhiteSpace(title) ? t : title;
        var head = $"{name}";

        // 追加中文描述摘要，方便搜索/阅读
        if (comp is IMaterialDescriptionProvider p)
        {
            try
            {
                var sb = new System.Text.StringBuilder(128);
                p.AppendDescription(sb);
                var desc = sb.ToString().Trim().Replace("\r", "").Replace("\n", " | ");
                if (!string.IsNullOrWhiteSpace(desc))
                {
                    head += $"  -  {desc}";
                }
            }
            catch { /* ignore */ }
        }

        return head;
    }

    /// <summary>
    /// 逻辑树节点添加弹窗（内置在同文件，避免 Jam 期间 csproj/Editor Assembly 差异导致的类型不可见问题）。
    /// 支持搜索：类型名 + 中文描述（来自 IMaterialDescriptionProvider 的默认描述）。
    /// </summary>
    private sealed class NodeAddPopupWindow : EditorWindow
    {
        private sealed class Entry
        {
            public bool IsExisting;
            public MonoBehaviour ExistingComp;
            public Type NewType;
            public string Name;
            public string Desc;
            public string Keywords;
            public bool Disabled;
        }

        private readonly List<Entry> _entries = new();
        private Vector2 _scroll;
        private string _search = "";
        private bool _foldLogic = true;
        private bool _foldEffects = true;

        private Action<Type> _onPickNew;

        public static void Show(
            Rect activatorRect,
            GameObject editingInstance,
            IReadOnlyList<Type> candidateTypes,
            Action<Type> onPickNew)
        {
            var w = CreateInstance<NodeAddPopupWindow>();
            w.titleContent = new GUIContent("添加节点");
            w._onPickNew = onPickNew;
            w.BuildEntries(editingInstance, candidateTypes);
            w.ShowAsDropDown(activatorRect, new Vector2(520, 420));
        }

        private void BuildEntries(GameObject editingInstance, IReadOnlyList<Type> candidateTypes)
        {
            _entries.Clear();
            if (candidateTypes == null) return;

            // New component types
            for (int i = 0; i < candidateTypes.Count; i++)
            {
                var t = candidateTypes[i];
                if (t == null) continue;
                bool disallow = Attribute.IsDefined(t, typeof(DisallowMultipleComponent), inherit: true);
                bool hasOne = editingInstance != null && editingInstance.GetComponent(t) != null;
                bool disabled = disallow && hasOne;
                var extra = disabled ? "（该脚本带 DisallowMultipleComponent，不能重复添加）" : "";

                GetCnMeta(t, out var cnName, out var keywords);
                var displayName = string.IsNullOrWhiteSpace(cnName)
                    ? $"{t.Name}（新建）"
                    : $"{cnName}（{t.Name}）（新建）";

                _entries.Add(new Entry
                {
                    IsExisting = false,
                    NewType = t,
                    Name = displayName,
                    Desc = GetDefaultComponentDescription(t) + extra,
                    Keywords = keywords,
                    Disabled = disabled,
                });
            }

            _entries.Sort((a, b) =>
            {
                return string.Compare(a.Name, b.Name, StringComparison.OrdinalIgnoreCase);
            });
        }

        private void OnGUI()
        {
            EditorGUILayout.LabelField("添加节点（搜索支持：类型名 / 中文描述）", EditorStyles.boldLabel);
            using (new EditorGUILayout.HorizontalScope())
            {
                _search = EditorGUILayout.TextField(_search ?? string.Empty);
                if (GUILayout.Button("清空", GUILayout.Width(50))) _search = string.Empty;
            }

            DrawCategoryToggles();

            EditorGUILayout.Space(6);
            _scroll = EditorGUILayout.BeginScrollView(_scroll);

            var s = _search ?? string.Empty;
            for (int i = 0; i < _entries.Count; i++)
            {
                var e = _entries[i];
                if (e == null) continue;
                if (!string.IsNullOrWhiteSpace(s))
                {
                    bool hit = (e.Name != null && e.Name.IndexOf(s, StringComparison.OrdinalIgnoreCase) >= 0) ||
                               (e.Desc != null && e.Desc.IndexOf(s, StringComparison.OrdinalIgnoreCase) >= 0) ||
                               (e.Keywords != null && e.Keywords.IndexOf(s, StringComparison.OrdinalIgnoreCase) >= 0);
                    if (!hit) continue;
                }

                // 分类：逻辑节点 / 纯效果器
                bool isLogic = e.IsExisting
                    ? (e.ExistingComp is IMaterialLogicNode)
                    : (e.NewType != null && typeof(IMaterialLogicNode).IsAssignableFrom(e.NewType));
                if (isLogic && !_foldLogic) continue;
                if (!isLogic && !_foldEffects) continue;

                using (new EditorGUILayout.VerticalScope(EditorStyles.helpBox))
                {
                    using (new EditorGUILayout.HorizontalScope())
                    {
                        GUI.enabled = !e.Disabled;
                        if (GUILayout.Button("选用", GUILayout.Width(60)))
                        {
                            _onPickNew?.Invoke(e.NewType);
                            Close();
                            GUIUtility.ExitGUI();
                        }
                        GUI.enabled = true;

                        EditorGUILayout.LabelField((isLogic ? "[逻辑] " : "[效果器] ") + e.Name, EditorStyles.boldLabel);
                    }

                    if (!string.IsNullOrWhiteSpace(e.Desc))
                    {
                        EditorGUILayout.LabelField(e.Desc, EditorStyles.miniLabel);
                    }
                    if (!string.IsNullOrWhiteSpace(e.Keywords))
                    {
                        EditorGUILayout.LabelField("关键词：" + e.Keywords, EditorStyles.miniLabel);
                    }
                }
            }

            EditorGUILayout.EndScrollView();
        }

        private void OnInspectorUpdate()
        {
            // keep repaint smooth for dropdown
            Repaint();
        }

        private void DrawCategoryToggles()
        {
            using (new EditorGUILayout.HorizontalScope(EditorStyles.helpBox))
            {
                _foldLogic = EditorGUILayout.ToggleLeft("逻辑节点", _foldLogic, GUILayout.Width(100));
                _foldEffects = EditorGUILayout.ToggleLeft("效果器", _foldEffects, GUILayout.Width(100));
                GUILayout.FlexibleSpace();
                EditorGUILayout.LabelField("（可折叠过滤）", EditorStyles.miniLabel, GUILayout.Width(90));
            }
        }

        private static string GetDefaultComponentDescription(Type t)
        {
            if (t == null) return string.Empty;
            var go = new GameObject("tmp_desc_go");
            go.hideFlags = HideFlags.HideAndDontSave;
            try
            {
                var comp = go.AddComponent(t) as MonoBehaviour;
                return BuildComponentDescription(comp);
            }
            catch
            {
                return string.Empty;
            }
            finally
            {
                DestroyImmediate(go);
            }
        }

        private static string BuildComponentDescription(MonoBehaviour comp)
        {
            if (comp == null) return string.Empty;
            try
            {
                if (comp is IMaterialDescriptionProvider p)
                {
                    var sb = new System.Text.StringBuilder(128);
                    p.AppendDescription(sb);
                    return sb.ToString().Trim().Replace("\r", "").Replace("\n", " | ");
                }
            }
            catch { /* ignore */ }
            return string.Empty;
        }

        private static void GetCnMeta(Type t, out string cnName, out string keywords)
        {
            cnName = string.Empty;
            keywords = string.Empty;
            if (t == null) return;
            try
            {
                var a = Attribute.GetCustomAttribute(t, typeof(MaterialCnMetaAttribute), inherit: false) as MaterialCnMetaAttribute;
                if (a == null) return;
                cnName = a.Name ?? string.Empty;
                keywords = a.Keywords ?? string.Empty;
            }
            catch
            {
                // ignore
            }
        }
    }

    // orderedComponents 链式方案已移除：不再提供 “顺序列表” 的初始化/排序/删除 API。

    private void Save()
    {
        var folder = FolderPath;
        if (string.IsNullOrWhiteSpace(folder) || !AssetDatabase.IsValidFolder(folder))
        {
            Debug.LogError("[材料编辑器] 文件夹无效，无法保存。");
            return;
        }
        if (_editingMaterial == null || _editingInstance == null)
        {
            Debug.LogError("[材料编辑器] 当前无可保存对象。");
            return;
        }

        if (_editingMaterial.Id <= 0)
        {
            _editingMaterial.Id = GetNextIdOrDefault(folder);
        }

        var name = string.IsNullOrWhiteSpace(_editingMaterial.DisplayName) ? "Material" : _editingMaterial.DisplayName;
        name = SanitizeFileName(name);
        var fileName = $"{_editingMaterial.Id}_{name}";
        var targetPath = $"{folder}/{fileName}.prefab";

        // Ensure not overwrite other asset unintentionally
        if (!string.IsNullOrWhiteSpace(_selectedPrefabPath) && _selectedPrefabPath != targetPath)
        {
            // Move existing asset to new path (keeps GUID if possible)
            var moveErr = AssetDatabase.MoveAsset(_selectedPrefabPath, targetPath);
            if (!string.IsNullOrWhiteSpace(moveErr))
            {
                // fallback: save new and delete old
                PrefabUtility.SaveAsPrefabAsset(_editingInstance, targetPath);
                AssetDatabase.DeleteAsset(_selectedPrefabPath);
            }
            else
            {
                PrefabUtility.SaveAsPrefabAsset(_editingInstance, targetPath);
            }
        }
        else
        {
            PrefabUtility.SaveAsPrefabAsset(_editingInstance, targetPath);
        }

        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();

        Refresh();
        SelectByPath(targetPath);
    }

    private void SelectEntry(PrefabEntry e)
    {
        _selectedEntry = e;
        SelectByPath(e.Path);
    }

    private void SelectByPath(string path)
    {
        CleanupEditingInstance();

        _selectedPrefabPath = path;
        var prefab = AssetDatabase.LoadAssetAtPath<GameObject>(path);
        if (prefab == null)
        {
            Debug.LogError($"[材料编辑器] 无法加载 prefab：{path}");
            return;
        }

        var inst = (GameObject)PrefabUtility.InstantiatePrefab(prefab);
        // 同 CreateNew：不能 DontSave，否则无法保存回 prefab
        inst.hideFlags = HideFlags.HideInHierarchy;
        _editingInstance = inst;
        _editingMaterial = inst.GetComponent<MaterialObj>();
        if (_editingMaterial == null)
        {
            Debug.LogError("[材料编辑器] 该 prefab 不包含 MaterialObj。");
            CleanupEditingInstance();
        }
    }

    private void CleanupEditingInstance()
    {
        if (_editingInstance != null)
        {
            DestroyImmediate(_editingInstance);
            _editingInstance = null;
            _editingMaterial = null;
        }
    }

    private void LoadPrefabsFromFolder(string folder)
    {
        _prefabs.Clear();
        if (string.IsNullOrWhiteSpace(folder) || !AssetDatabase.IsValidFolder(folder)) return;

        var guids = AssetDatabase.FindAssets("t:Prefab", new[] { folder });
        for (int i = 0; i < guids.Length; i++)
        {
            var path = AssetDatabase.GUIDToAssetPath(guids[i]);
            var go = AssetDatabase.LoadAssetAtPath<GameObject>(path);
            if (go == null) continue;
            var mat = go.GetComponent<MaterialObj>();
            if (mat == null) continue;

            int id = mat.Id;
            if (id <= 0) id = TryParseIdFromName(Path.GetFileNameWithoutExtension(path));
            var displayName = !string.IsNullOrWhiteSpace(mat.DisplayName) ? mat.DisplayName : go.name;
            _prefabs.Add(new PrefabEntry { Path = path, Id = id, DisplayName = displayName, Prefab = go });
        }

        _prefabs.Sort((a, b) => a.Id.CompareTo(b.Id));
    }

    private int GetNextIdOrDefault(string folder)
    {
        int max = 0;
        var guids = AssetDatabase.FindAssets("t:Prefab", new[] { folder });
        for (int i = 0; i < guids.Length; i++)
        {
            var path = AssetDatabase.GUIDToAssetPath(guids[i]);
            var go = AssetDatabase.LoadAssetAtPath<GameObject>(path);
            if (go == null) continue;
            var mat = go.GetComponent<MaterialObj>();
            if (mat == null) continue;
            int id = mat.Id;
            if (id <= 0) id = TryParseIdFromName(Path.GetFileNameWithoutExtension(path));
            if (id > max) max = id;
        }
        return max > 0 ? max + 1 : 100001;
    }

    private static int TryParseIdFromName(string fileName)
    {
        if (string.IsNullOrWhiteSpace(fileName)) return 0;
        int idx = fileName.IndexOf('_');
        if (idx <= 0) return 0;
        var head = fileName.Substring(0, idx);
        return int.TryParse(head, out var id) ? id : 0;
    }

    private void CacheMaterialComponentTypes()
    {
        _materialComponentTypes.Clear();

        // 弹窗候选类型：
        // - 逻辑节点：IMaterialLogicNode（可直接进入树）
        // - 纯效果器：IMaterialEffect / IMaterialAttackInfoEffect（选中后会自动创建 Node_Effect 包装进树）

        foreach (var asm in AppDomain.CurrentDomain.GetAssemblies())
        {
            Type[] types;
            try { types = asm.GetTypes(); }
            catch { continue; }

            for (int i = 0; i < types.Length; i++)
            {
                var t = types[i];
                if (t == null || t.IsAbstract) continue;
                if (!typeof(MonoBehaviour).IsAssignableFrom(t)) continue;
                if (t == typeof(MaterialObj)) continue;
                if (t.Namespace != null && t.Namespace.StartsWith("Unity", StringComparison.Ordinal)) continue;

                bool isLogicNode = typeof(IMaterialLogicNode).IsAssignableFrom(t);
                bool isEffector = typeof(IMaterialEffect).IsAssignableFrom(t) || typeof(IMaterialAttackInfoEffect).IsAssignableFrom(t);
                if (!isLogicNode && !isEffector) continue;

                _materialComponentTypes.Add(t);
            }
        }

        _materialComponentTypes.Sort((a, b) => string.Compare(a.Name, b.Name, StringComparison.Ordinal));
    }

    private void AddComponentToEditing(Type t)
    {
        if (_editingInstance == null || t == null) return;
        // Jam：允许同一材质挂多个“同类型”组件实例（用于逻辑树不同分支复用同类型节点）。
        // 若该组件脚本带 [DisallowMultipleComponent]，Unity 会阻止重复添加（这属于 Unity 规则，而不是编辑器限制）。
        Undo.AddComponent(_editingInstance, t);
    }

    private static string GetDefaultComponentDescription(Type t)
    {
        if (t == null) return string.Empty;
        var go = new GameObject("tmp_desc_go");
        go.hideFlags = HideFlags.HideAndDontSave;
        try
        {
            var comp = go.AddComponent(t) as MonoBehaviour;
            return BuildComponentDescription(comp);
        }
        catch
        {
            return string.Empty;
        }
        finally
        {
            DestroyImmediate(go);
        }
    }

    private static string BuildComponentDescription(MonoBehaviour comp)
    {
        if (comp == null) return string.Empty;
        var sb = new StringBuilder(128);

        if (comp is IMaterialDescriptionProvider p)
        {
            p.AppendDescription(sb);
        }
        else
        {
            // fallback: try a "description" field
            var f = comp.GetType().GetField("description", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
            if (f != null && f.FieldType == typeof(string))
            {
                var v = f.GetValue(comp) as string;
                if (!string.IsNullOrWhiteSpace(v)) sb.Append(v);
            }
        }

        return sb.ToString().Trim();
    }

    private static string SanitizeFileName(string s)
    {
        if (string.IsNullOrEmpty(s)) return "Material";
        foreach (var c in Path.GetInvalidFileNameChars())
        {
            s = s.Replace(c, '_');
        }
        return s.Trim();
    }

    [Serializable]
    private sealed class PrefabEntry
    {
        public string Path;
        public int Id;
        public string DisplayName;
        public GameObject Prefab;
    }
}
#endif




// === Gameplay\Drop\IMaterialDropMethod.cs ===
using System.Collections.Generic;

public interface IMaterialDropMethod
{
    /// <summary>
    /// 掉落入口：根据材料池与幸运值抽取本次掉落。
    /// - luck: 0~100（超出会被夹紧）
    /// - dropCount: 本次掉落数量（<=0 返回空；>100 将被夹紧到 100）
    /// </summary>
    IReadOnlyList<MaterialDropEntry> Roll(MaterialPool pool, int luck, int dropCount);
}





// === Gameplay\Drop\MaterialDropEntry.cs ===
using System;
using UnityEngine;

[Serializable]
public sealed class MaterialDropEntry
{
    public MaterialObj MaterialPrefab;
    [Min(1)] public int Count = 1;
}




// === Gameplay\Drop\MaterialInventory.cs ===
using System;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// 材料库存（Jam 版：直接存 MaterialObj 实例列表）。
/// - 掉落时：Instantiate 出 MaterialObj 实例，ResetInventoryShelfLife 后加入库存
/// - “制造面具回合结束”（StartBattle 前）：对库存内每个实例调用 TickInventory()，过期则 Destroy 并移除
/// - 绑定到面具成功后：从库存移除该实例（它已经成为面具一部分，不再参与库存结算）
/// </summary>
[Serializable]
public sealed class MaterialInventory
{
    [SerializeField] private List<MaterialObj> items = new();
    public IReadOnlyList<MaterialObj> Items => items;

    public void Add(MaterialObj instance)
    {
        if (instance == null) return;
        if (!items.Contains(instance)) items.Add(instance);
    }

    /// <summary>
    /// 制造回合结束：对库存内每个材料 TickInventory()，过期则销毁并移除。
    /// </summary>
    public void TickEndOfMakePhase(Transform inventoryRoot = null)
    {
        for (int i = items.Count - 1; i >= 0; i--)
        {
            var m = items[i];
            if (m == null)
            {
                items.RemoveAt(i);
                continue;
            }

            // 仍在库存根节点下的才算库存（保险）
            if (inventoryRoot != null && m.transform.parent != inventoryRoot) continue;

            if (m.TickInventory())
            {
                UnityEngine.Object.Destroy(m.gameObject);
                items.RemoveAt(i);
            }
        }
    }

    public void Remove(MaterialObj instance)
    {
        if (instance == null) return;
        items.Remove(instance);
    }
}




// === Gameplay\Drop\MaterialPool.cs ===
using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public sealed class MaterialPoolEntry
{
    public MaterialObj MaterialPrefab;
    [Min(1)] public int Weight = 1;
}

/// <summary>
/// 材料池：按品质分组的材料列表（可选权重）。
/// </summary>
[CreateAssetMenu(menuName = "GGJ2026/Drop/MaterialPool", fileName = "MaterialPool")]
public class MaterialPool : ScriptableObject
{
    public List<MaterialPoolEntry> Common = new();
    public List<MaterialPoolEntry> Uncommon = new();
    public List<MaterialPoolEntry> Rare = new();
    public List<MaterialPoolEntry> Epic = new();
    public List<MaterialPoolEntry> Legendary = new();

    public IReadOnlyList<MaterialPoolEntry> GetList(MaterialQuality q)
    {
        return q switch
        {
            MaterialQuality.Common => Common,
            MaterialQuality.Uncommon => Uncommon,
            MaterialQuality.Rare => Rare,
            MaterialQuality.Epic => Epic,
            MaterialQuality.Legendary => Legendary,
            _ => Common
        };
    }
}





// === Gameplay\Drop\MaterialQuality.cs ===
public enum MaterialQuality
{
    // 低 -> 高：枚举值必须是 0..4
    Common = 0,
    Uncommon = 1,
    Rare = 2,
    Epic = 3,
    Legendary = 4,
}





// === Gameplay\Drop\SimpleLuckMaterialDropMethod.cs ===
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// V0 简单掉落方法：luck 影响品质概率（0~100），先抽品质再从该品质池按权重抽材料。
/// </summary>
[CreateAssetMenu(menuName = "GGJ2026/Drop/SimpleLuckDropMethod", fileName = "SimpleLuckDropMethod")]
public class SimpleLuckMaterialDropMethod : ScriptableObject, IMaterialDropMethod
{
    [Header("Quality Weights at Luck=0 (sum doesn't need to be 1)")]
    [Tooltip("Common/Uncommon/Rare/Epic/Legendary 的基础权重（luck=0）。")]
    [SerializeField] private float w0_common = 70f;
    [SerializeField] private float w0_uncommon = 20f;
    [SerializeField] private float w0_rare = 8f;
    [SerializeField] private float w0_epic = 2f;
    [SerializeField] private float w0_legendary = 0f;

    [Header("Quality Weights at Luck=100")]
    [Tooltip("Common/Uncommon/Rare/Epic/Legendary 的目标权重（luck=100）。")]
    [SerializeField] private float w1_common = 35f;
    [SerializeField] private float w1_uncommon = 30f;
    [SerializeField] private float w1_rare = 20f;
    [SerializeField] private float w1_epic = 12f;
    [SerializeField] private float w1_legendary = 3f;

    public IReadOnlyList<MaterialDropEntry> Roll(MaterialPool pool, int luck, int dropCount)
    {
        var results = new List<MaterialDropEntry>();
        if (pool == null) return results;

        luck = Mathf.Clamp(luck, 0, 100);
        dropCount = Mathf.Clamp(dropCount, 0, 100);
        if (dropCount <= 0) return results;

        // 先算出五档品质的权重（线性插值）
        float t = luck / 100f;
        float wc = Mathf.Lerp(w0_common, w1_common, t);
        float wu = Mathf.Lerp(w0_uncommon, w1_uncommon, t);
        float wr = Mathf.Lerp(w0_rare, w1_rare, t);
        float we = Mathf.Lerp(w0_epic, w1_epic, t);
        float wl = Mathf.Lerp(w0_legendary, w1_legendary, t);

        for (int i = 0; i < dropCount; i++)
        {
            var q = RollQuality(wc, wu, wr, we, wl);
            var prefab = RollPrefabByQuality(pool, q);
            if (prefab == null) continue;

            // 合并同一 prefab 的数量
            var existing = results.Find(x => x.MaterialPrefab == prefab);
            if (existing != null) existing.Count += 1;
            else results.Add(new MaterialDropEntry { MaterialPrefab = prefab, Count = 1 });
        }

        return results;
    }

    private static MaterialQuality RollQuality(float wc, float wu, float wr, float we, float wl)
    {
        float sum = Mathf.Max(0f, wc) + Mathf.Max(0f, wu) + Mathf.Max(0f, wr) + Mathf.Max(0f, we) + Mathf.Max(0f, wl);
        if (sum <= 0f) return MaterialQuality.Common;

        float r = Random.value * sum;
        r -= Mathf.Max(0f, wc); if (r <= 0f) return MaterialQuality.Common;
        r -= Mathf.Max(0f, wu); if (r <= 0f) return MaterialQuality.Uncommon;
        r -= Mathf.Max(0f, wr); if (r <= 0f) return MaterialQuality.Rare;
        r -= Mathf.Max(0f, we); if (r <= 0f) return MaterialQuality.Epic;
        return MaterialQuality.Legendary;
    }

    private static MaterialObj RollPrefabByQuality(MaterialPool pool, MaterialQuality q)
    {
        // 如果该品质为空，降级到更低品质（再不行就任意找一个非空池）
        for (int step = 0; step < 5; step++)
        {
            var qq = (MaterialQuality)Mathf.Clamp((int)q - step, 0, 4);
            var list = pool.GetList(qq);
            var picked = RollWeighted(list);
            if (picked != null) return picked;
        }

        // 任意非空
        return RollWeighted(pool.Common) ??
               RollWeighted(pool.Uncommon) ??
               RollWeighted(pool.Rare) ??
               RollWeighted(pool.Epic) ??
               RollWeighted(pool.Legendary);
    }

    private static MaterialObj RollWeighted(IReadOnlyList<MaterialPoolEntry> list)
    {
        if (list == null || list.Count == 0) return null;
        int total = 0;
        for (int i = 0; i < list.Count; i++)
        {
            var w = list[i]?.Weight ?? 0;
            if (w > 0) total += w;
        }
        if (total <= 0) return null;

        int r = Random.Range(0, total);
        for (int i = 0; i < list.Count; i++)
        {
            var e = list[i];
            if (e == null || e.Weight <= 0 || e.MaterialPrefab == null) continue;
            r -= e.Weight;
            if (r < 0) return e.MaterialPrefab;
        }
        return null;
    }
}





// === Gameplay\Fight\AttackInfo.cs ===
using System;

[Serializable]
public struct AttackInfo
{
    /// <summary>基础攻击值（来源于攻击者静态属性 + 其它加成）。</summary>
    public float BaseValue;

    /// <summary>暴击概率（0~1）。</summary>
    public float CritChance;

    /// <summary>暴击乘数（例如 1.5 表示 150%）。</summary>
    public float CritMultiplier;

    /// <summary>未结算暴击的“实际攻击”（主要用于处理链修改）。</summary>
    public float RawAttack;

    /// <summary>本次是否暴击（由数值计算器写入）。</summary>
    public bool IsCrit;

    /// <summary>最终伤害（由数值计算器写入；若未写入则 FightManager 可回退使用 RawAttack）。</summary>
    public float FinalDamage;

    public float PenetrationFixed; // 穿透固定值
    public float PenetrationPercent;

}




// === Gameplay\Fight\AttackInfoProcessorChain.cs ===
using System.Collections.Generic;

/// <summary>
/// 攻击处理器链（玩家/敌人各一套）。材料效果按“链表顺序”注册到链中执行。
/// </summary>
public sealed class AttackInfoProcessorChain
{
    private readonly List<IAttackInfoModifier> _modifiers = new();
    private IAttackInfoModifier _finalizer;

    public IReadOnlyList<IAttackInfoModifier> Modifiers => _modifiers;
    public IAttackInfoModifier Finalizer => _finalizer;

    public void Clear()
    {
        _modifiers.Clear();
        _finalizer = null;
    }

    public void Add(IAttackInfoModifier modifier)
    {
        if (modifier == null) return;
        _modifiers.Add(modifier);
    }

    /// <summary>
    /// 设置“最终结算器”，永远在所有 modifiers 之后执行。
    /// 用于确保“最终伤害/暴击/防御等结算”不会被材料动态 Add 的 modifier 插到后面。
    /// </summary>
    public void SetFinalizer(IAttackInfoModifier finalizer)
    {
        _finalizer = finalizer;

        // 避免同一个对象既在 modifiers 又在 finalizer 里导致重复执行
        if (_finalizer == null) return;
        for (int i = _modifiers.Count - 1; i >= 0; i--)
        {
            if (ReferenceEquals(_modifiers[i], _finalizer)) _modifiers.RemoveAt(i);
        }
    }

    public void Process(ref AttackInfo info, FightContext context)
    {
        if (context != null && context.DebugVerbose && context.DebugLogger != null)
        {
            for (int i = 0; i < _modifiers.Count; i++)
            {
                var m = _modifiers[i];
                if (m == null) continue;
                var before = info;
                m.Modify(ref info, context);
                if (!ApproxEqual(before, info))
                {
                    context.DebugLogger($"[Proc] {m.GetType().Name} {FmtDiff(before, info)}");
                }
                else
                {
                    context.DebugLogger($"[Proc] {m.GetType().Name} (no change)");
                }
            }

            if (_finalizer != null)
            {
                var before = info;
                _finalizer.Modify(ref info, context);
                if (!ApproxEqual(before, info))
                {
                    context.DebugLogger($"[Final] {_finalizer.GetType().Name} {FmtDiff(before, info)}");
                }
                else
                {
                    context.DebugLogger($"[Final] {_finalizer.GetType().Name} (no change)");
                }
            }
            return;
        }

        for (int i = 0; i < _modifiers.Count; i++)
        {
            _modifiers[i].Modify(ref info, context);
        }

        _finalizer?.Modify(ref info, context);
    }

    private static bool ApproxEqual(AttackInfo a, AttackInfo b)
    {
        const float eps = 0.0001f;
        if (System.Math.Abs(a.BaseValue - b.BaseValue) > eps) return false;
        if (System.Math.Abs(a.RawAttack - b.RawAttack) > eps) return false;
        if (System.Math.Abs(a.CritChance - b.CritChance) > eps) return false;
        if (System.Math.Abs(a.CritMultiplier - b.CritMultiplier) > eps) return false;
        if (a.IsCrit != b.IsCrit) return false;
        if (System.Math.Abs(a.FinalDamage - b.FinalDamage) > eps) return false;
        return true;
    }

    private static string FmtDiff(AttackInfo before, AttackInfo after)
    {
        return $"Base {before.BaseValue:0.##}->{after.BaseValue:0.##}, Raw {before.RawAttack:0.##}->{after.RawAttack:0.##}, " +
               $"CritChance {before.CritChance:0.##}->{after.CritChance:0.##}, CritMul {before.CritMultiplier:0.##}->{after.CritMultiplier:0.##}, " +
               $"IsCrit {before.IsCrit}->{after.IsCrit}, Final {before.FinalDamage:0.##}->{after.FinalDamage:0.##}";
    }
}




// === Gameplay\Fight\BasicAttackInfoCalculator.cs ===
using System;
using UnityEngine;

/// <summary>
/// V0 最简数值计算器：支持防御减伤与暴击（公式后续可替换）。
/// 注意：此类为“可序列化的纯数据对象”，用于 Odin 接口序列化注入；不是 MonoBehaviour。
/// </summary>
[Serializable]
public sealed class BasicAttackInfoCalculator : IAttackInfoModifier
{
    [Tooltip("是否启用防御减伤：damage = max(0, raw - defenderDef)")]
    public bool EnableDefenseReduction = true;

    [Tooltip("如果开启暴击：随机 < CritChance 则 damage *= CritMultiplier")]
    public bool EnableCrit = true;

    public void Modify(ref AttackInfo info, FightContext context)
    {
        if (context == null || context.CurrentDefender == null)
        {
            info.FinalDamage = Mathf.Max(0f, info.RawAttack);
            return;
        }

        float damage = info.RawAttack;

        if (EnableDefenseReduction)
        {
            damage = Mathf.Max(0f, damage - context.CurrentDefender.Defense);
        }

        if (EnableCrit)
        {
            bool isCrit = UnityEngine.Random.value < Mathf.Clamp01(info.CritChance);
            info.IsCrit = isCrit;
            if (isCrit)
            {
                damage *= Mathf.Max(1f, info.CritMultiplier);
            }
        }

        info.FinalDamage = damage;
    }
}




// === Gameplay\Fight\CombatantRuntime.cs ===
using UnityEngine;

/// <summary>
/// 战斗中的运行时角色实例数据（注意：不要修改 Config，战斗只改运行时实例）。
/// </summary>
public sealed class CombatantRuntime
{
    public string Name { get; }

    public float MaxHP { get; private set; }
    public float CurrentHP { get; private set; }

    public float Attack { get; private set; }
    public float Defense { get; private set; }

    /// <summary>0~1</summary>
    public float CritChance { get; private set; }

    /// <summary>暴击乘数（例如 1.5）。</summary>
    public float CritMultiplier { get; private set; }

    public int SpeedRate { get; private set; }

    /// <summary>百分比穿透（0~1）</summary>
    public float PenetrationPercent { get; private set; }

    /// <summary>固定穿透（>=0）</summary>
    public float PenetrationFixed { get; private set; }

    public bool IsDead => CurrentHP <= 0f;

    public CombatantRuntime(string name, CharacterConfig config)
    {
        Name = string.IsNullOrWhiteSpace(name) ? "Combatant" : name;
        ApplyConfig(config);
        CurrentHP = MaxHP;
    }

    public void ApplyConfig(CharacterConfig config)
    {
        if (config == null)
        {
            // Jam 容错：缺配置时给个兜底，避免崩溃
            MaxHP = 10f;
            Attack = 1f;
            Defense = 0f;
            CritChance = 0f;
            CritMultiplier = 1.5f;
            SpeedRate = 1;
            return;
        }

        MaxHP = Mathf.Max(1f, config.HPBase);
        Attack = Mathf.Max(0f, config.ATKBase);
        Defense = Mathf.Max(0f, config.DEFBase);
        CritChance = Mathf.Clamp01(config.CritChance);
        CritMultiplier = Mathf.Max(1f, config.CritMultiplier);
        SpeedRate = Mathf.Max(0, config.SpeedRate);
        PenetrationPercent = 0f;
        PenetrationFixed = 0f;
    }

    public static CombatantRuntime FromStats(string name, PlayerStats stats, PlayerGrowthDelta pendingGrowthDelta)
    {
        stats.Clamp();
        var c = new CombatantRuntime(name, null)
        {
            MaxHP = stats.MaxHP+pendingGrowthDelta.AddMaxHP,
            Attack = stats.Attack+pendingGrowthDelta.AddAttack,
            Defense = stats.Defense+pendingGrowthDelta.AddDefense,
            CritChance = stats.CritChance+pendingGrowthDelta.AddCritChance,
            CritMultiplier = stats.CritMultiplier+pendingGrowthDelta.AddCritMultiplier,
            SpeedRate = stats.SpeedRate+pendingGrowthDelta.AddSpeedRate,
            PenetrationPercent = stats.PenetrationPercent+pendingGrowthDelta.AddPenetrationPercent,
            PenetrationFixed = stats.PenetrationFixed+pendingGrowthDelta.AddPenetrationFixed,
        };
        c.CurrentHP = c.MaxHP;
        return c;
    }

    public void ResetHP() => CurrentHP = MaxHP;

    public void AddAttack(float delta)
    {
        Attack = Mathf.Max(0f, Attack + delta);
    }

    public void AddDefense(float delta)
    {
        Defense = Mathf.Max(0f, Defense + delta);
    }

    public void AddCritChance(float delta)
    {
        CritChance = Mathf.Clamp01(CritChance + delta);
    }

    public void AddCritMultiplier(float delta)
    {
        CritMultiplier = Mathf.Max(1f, CritMultiplier + delta);
    }

    public void AddSpeedRate(int delta)
    {
        SpeedRate = Mathf.Max(0, SpeedRate + delta);
    }

    public void AddMaxHP(float delta, bool alsoHeal)
    {
        if (delta == 0f) return;
        var oldMax = MaxHP;
        MaxHP = Mathf.Max(1f, MaxHP + delta);
        if (alsoHeal)
        {
            CurrentHP = Mathf.Min(MaxHP, CurrentHP + (MaxHP - oldMax));
        }
        else
        {
            CurrentHP = Mathf.Min(CurrentHP, MaxHP);
        }
    }

    public void Damage(float amount)
    {
        if (amount <= 0f) return;
        CurrentHP = Mathf.Max(0f, CurrentHP - amount);
    }

    /// <summary>
    /// 改变当前生命值（可正可负）：会 clamp 到 [0, MaxHP]。
    /// 用于“行动后改变当前生命值（百分比/固定值）”等材料效果。
    /// </summary>
    public void AddCurrentHP(float delta)
    {
        if (delta == 0f) return;
        CurrentHP = Mathf.Clamp(CurrentHP + delta, 0f, MaxHP);
    }

    public void AddPenetrationPercent(float delta)
    {
        PenetrationPercent = Mathf.Clamp01(PenetrationPercent + delta);
    }

    public void AddPenetrationFixed(float delta)
    {
        PenetrationFixed = Mathf.Max(0f, PenetrationFixed + delta);
    }
}




// === Gameplay\Fight\FightConfige.cs ===
using System;
using UnityEngine;

/// <summary>
/// 角色静态属性配置（SO）。
/// 注意：战斗中不可修改此配置；战斗只改运行时实例（CombatantRuntime）。
/// </summary>
[Serializable]
public class CharacterConfig 
{
    public float HPBase;
    public float ATKBase;
    public float DEFBase;

    [Range(0f, 1f)] public float CritChance;
    [Min(1f)] public float CritMultiplier = 1.5f;

    [Min(0)] public int SpeedRate = 1;
}


// === Gameplay\Fight\FightContext.cs ===
using System;
using System.Collections.Generic;

/// <summary>
/// 战斗上下文（BattleContext）。
/// 承载战斗共享数据、回调入口、以及玩家/敌人的 AttackInfo 处理链。
/// </summary>
public sealed class FightContext
{
    // ---- Debug ----
    /// <summary>是否输出详细调试日志（GameJam 期间可常开）。</summary>
    public bool DebugVerbose { get; internal set; }

    /// <summary>调试日志输出函数（由 FightManager 注入）。</summary>
    public Action<string> DebugLogger { get; internal set; }

    // ---- Runtime References ----
    public CombatantRuntime Player { get; internal set; }
    public CombatantRuntime Enemy { get; internal set; }

    // ---- Speed Battle ----
    public int ArenaSpeedThreshold { get; internal set; } = 10;
    public float PlayerSpeedValue { get; internal set; }
    public float EnemySpeedValue { get; internal set; }

    /// <summary>
    /// 本场战斗参与生效的面具数量（面具库 + 当前面具）。
    /// 用于“按面具数量缩放”的词条。
    /// </summary>
    public int MaskCount { get; internal set; }

    /// <summary>可选：面具实例（后续材料系统用）。</summary>
    public IMaskBattleInjector MaskInjector { get; internal set; }

    // ---- Current Engagement ----
    public FightSide CurrentAttackerSide { get; internal set; } = FightSide.None;
    public CombatantRuntime CurrentAttacker { get; internal set; }
    public CombatantRuntime CurrentDefender { get; internal set; }

    // ---- Counters (for material gates: 行动/攻击次数) ----
    /// <summary>本场战斗已发生的“行动次数”（每发生一次攻击 +1）。</summary>
    public int BattleActionCount { get; internal set; }

    /// <summary>本场战斗玩家已攻击次数。</summary>
    public int PlayerAttackCount { get; internal set; }

    /// <summary>本场战斗敌人已攻击次数。</summary>
    public int EnemyAttackCount { get; internal set; }

    /// <summary>本次攻击的“行动序号”（从 1 开始；每发生一次攻击事件 +1）。</summary>
    public int CurrentActionNumber { get; internal set; }

    /// <summary>本次攻击方的“第几次攻击”（从 1 开始）。</summary>
    public int CurrentAttackerAttackNumber { get; internal set; }

    // ---- Processors ----
    public AttackInfoProcessorChain PlayerAttackProcessor { get; } = new();
    public AttackInfoProcessorChain EnemyAttackProcessor { get; } = new();

    // ---- Fight Components (optional) ----
    private readonly List<IFightComponent> _fightComponents = new();
    public IReadOnlyList<IFightComponent> FightComponents => _fightComponents;

    public void AddFightComponent(IFightComponent component)
    {
        if (component == null) return;
        _fightComponents.Add(component);
        component.Inject(this);
    }

    // ---- Callbacks ----
    public event Action<FightContext> OnBattleEnter;
    public event Action<FightContext> OnBattleStart;
    public event Action<FightContext> OnBattleEnd;
    public event Action<FightContext> OnVictory;
    public event Action<FightContext> OnDefeat;

    /// <summary>攻击前/后通知（不用于修改；修改请走处理链/Calculator）。</summary>
    public event Action<FightContext, AttackInfo> OnBeforePlayerAttack;
    public event Action<FightContext, AttackInfo> OnAfterPlayerAttack;
    public event Action<FightContext, AttackInfo> OnBeforeEnemyAttack;
    public event Action<FightContext, AttackInfo> OnAfterEnemyAttack;

    /// <summary>
    /// 伤害结算通知：已对 Defender 扣血之后触发（用于 UI 飘字等展示）。
    /// attackerSide/defenderSide：本次攻击方/受击方。
    /// </summary>
    public event Action<FightContext, FightSide, FightSide, AttackInfo, float> OnDamageApplied;

    // ---- Raise helpers ----
    internal void RaiseBattleEnter() => OnBattleEnter?.Invoke(this);
    internal void RaiseBattleStart() => OnBattleStart?.Invoke(this);
    internal void RaiseBattleEnd() => OnBattleEnd?.Invoke(this);
    internal void RaiseVictory() => OnVictory?.Invoke(this);
    internal void RaiseDefeat() => OnDefeat?.Invoke(this);

    internal void RaiseBeforeAttack(FightSide side, AttackInfo info)
    {
        if (side == FightSide.Player) OnBeforePlayerAttack?.Invoke(this, info);
        else if (side == FightSide.Enemy) OnBeforeEnemyAttack?.Invoke(this, info);
    }

    internal void RaiseAfterAttack(FightSide side, AttackInfo info)
    {
        if (side == FightSide.Player) OnAfterPlayerAttack?.Invoke(this, info);
        else if (side == FightSide.Enemy) OnAfterEnemyAttack?.Invoke(this, info);
    }

    internal void RaiseDamageApplied(FightSide attackerSide, FightSide defenderSide, AttackInfo info, float damage)
    {
        OnDamageApplied?.Invoke(this, attackerSide, defenderSide, info, damage);
    }
}


// === Gameplay\Fight\FightManager.cs ===
using System.Collections.Generic;
using Sirenix.OdinInspector;
using Sirenix.Serialization;
using UnityEngine;

public class FightManager : MonoBehaviour
{
    public static FightManager I { get; private set; }

    [Header("Injected (Interface via Odin)")]
    [OdinSerialize] private IAttackInfoModifier finalDamageCalculator = new FinalDamageCalculator();

    [Header("Optional Injection")]
    [Tooltip("如果场景中有面具对象（或面具实例持有者），可在此注入战斗上下文。")]
    [OdinSerialize] private IMaskBattleInjector maskBattleInjector;

    [Tooltip("可选：战斗组件（会在开战时注入 context，订阅回调/注册处理器）。")]
    [OdinSerialize] private List<IFightComponent> fightComponents = new();

    [Header("Loop")]
    [SerializeField] private bool autoStartOnPlay = false;
    [SerializeField] private bool enableLogs = false;
    [SerializeField] private bool forceLogsInJam = true;

    public FightContext Context { get; private set; }

    private bool _isFighting;
    private float _nextPlayerAttackTime;
    private float _nextEnemyAttackTime;

    /// <summary>
    /// 必须由 GameManager.Awake() 调用，符合“所有管理类只能在 GameManager 中实例化与初始化”的强约束。
    /// </summary>
    public void Initialize()
    {
        if (I != null && I != this)
        {
            Destroy(gameObject);
            return;
        }
        I = this;
    }

    public void SetMaskBattleInjector(IMaskBattleInjector injector)
    {
        maskBattleInjector = injector;
    }

    private void Start()
    {
        if (autoStartOnPlay)
        {
            StartFight();
        }
    }

    [Button(ButtonSizes.Medium)]
    public void StartFight()
    {
        if (MonsterSpawnSystem.I == null)
        {
            Debug.LogError("[FightManager] MonsterSpawnSystem 未初始化，无法生成敌人。", this);
            return;
        }

        if (finalDamageCalculator == null)
        {
            Debug.LogError("[FightManager] finalDamageCalculator 未配置（IAttackInfoModifier，用于最终结算且必须最后执行）。", this);
            return;
        }

        if (Player.I == null)
        {
            Debug.LogError("[FightManager] Player 单例未初始化，无法开始战斗。", this);
            return;
        }

        var enemyCfg = MonsterSpawnSystem.I.Spawn(_battleRoundIndex, Context);
        if (enemyCfg == null)
        {
            Debug.LogError("[FightManager] MonsterSpawnSystem 未生成 Enemy 配置。", this);
            return;
        }

        Context = new FightContext
        {
            Player = CombatantRuntime.FromStats("Player", Player.I.BuildBattleStats(),GameManager.I.PendingGrowthDelta),
            Enemy = new CombatantRuntime("Enemy", enemyCfg),
            ArenaSpeedThreshold = (Player.I.BaseStats.SpeedRate+enemyCfg.SpeedRate)/2
        };
        var logs = (enableLogs || forceLogsInJam);
        Context.DebugVerbose = logs;
        Context.DebugLogger = logs ? (System.Action<string>)(msg => Debug.Log(msg)) : null;

        // 注入“战斗组件”
        if (fightComponents != null)
        {
            for (int i = 0; i < fightComponents.Count; i++)
            {
                Context.AddFightComponent(fightComponents[i]);
            }
        }

        // 注入“面具/材料”（占位接口）
        if (maskBattleInjector != null)
        {
            Context.MaskInjector = maskBattleInjector;
            maskBattleInjector.InjectBattleContext(Context);
            Context.MaskCount = (maskBattleInjector as IMaskBattleInjectorWithCount)?.MaskCount ?? 0;
        }

        // 最终结算器：永远最后执行（不允许被材料动态 Add 插到后面）
        Context.PlayerAttackProcessor.SetFinalizer(finalDamageCalculator);
        Context.EnemyAttackProcessor.SetFinalizer(finalDamageCalculator);

        // 速度条初始化
        Context.PlayerSpeedValue = 0f;
        Context.EnemySpeedValue = 0f;
        _nextPlayerAttackTime = Time.time;
        _nextEnemyAttackTime = Time.time;
      

        Context.RaiseBattleEnter();
        Context.RaiseBattleStart();
        GameManager.I.battleUI.ResetHasCreateMonsterFlag();
        if (logs)
        {
            DumpBattleHeader();
        }

        _battleRoundIndex++;
    }

    private int _battleRoundIndex = 0;

    public void StopFight()
    {
        _isFighting = false;

    }
    public void StartFightUpdate(){
        _isFighting = true;
    }
    private void Update()
    {
        if (!_isFighting || Context == null) return;
        if (Context.Player == null || Context.Enemy == null) return;

        if (Context.Player.IsDead || Context.Enemy.IsDead)
        {
            EndFight();
            return;
        }

        // 速度累积
        Context.PlayerSpeedValue += Context.Player.SpeedRate * Time.deltaTime;
        Context.EnemySpeedValue += Context.Enemy.SpeedRate * Time.deltaTime;

        // 尝试触发攻击（允许溢出多次，但受攻击动画间隔限制）
        TryExecuteAttacks(FightSide.Player);
        TryExecuteAttacks(FightSide.Enemy);

        if (Context.Player.IsDead || Context.Enemy.IsDead)
        {
            EndFight();
        }
    }

    private void TryExecuteAttacks(FightSide side)
    {
        int threshold = Mathf.Max(1, Context.ArenaSpeedThreshold);

        if (side == FightSide.Player)
        {
            if (Time.time < _nextPlayerAttackTime) return;
            if (Context.PlayerSpeedValue < threshold) return;

            ExecuteAttack(FightSide.Player);
            Context.PlayerSpeedValue -= threshold;
            _nextPlayerAttackTime = Time.time + GameSetting.AttackAnimIntervalSeconds;
        }
        else
        {
            if (Time.time < _nextEnemyAttackTime) return;
            if (Context.EnemySpeedValue < threshold) return;

            ExecuteAttack(FightSide.Enemy);
            Context.EnemySpeedValue -= threshold;
            _nextEnemyAttackTime = Time.time + GameSetting.AttackAnimIntervalSeconds;
        }
    }

    private void ExecuteAttack(FightSide side)
    {
        var attacker = side == FightSide.Player ? Context.Player : Context.Enemy;
        var defender = side == FightSide.Player ? Context.Enemy : Context.Player;
        var defenderSide = side == FightSide.Player ? FightSide.Enemy : FightSide.Player;

        // 设置本次“交战上下文”，供 Calculator/材料读取
        Context.CurrentAttackerSide = side;
        Context.CurrentAttacker = attacker;
        Context.CurrentDefender = defender;

        // 计数器：供“每X回合/第X攻击/前X回合/前X攻击”类词条使用
        Context.CurrentActionNumber = Context.BattleActionCount + 1;
        if (side == FightSide.Player) Context.CurrentAttackerAttackNumber = Context.PlayerAttackCount + 1;
        else if (side == FightSide.Enemy) Context.CurrentAttackerAttackNumber = Context.EnemyAttackCount + 1;
        else Context.CurrentAttackerAttackNumber = 0;

        // 创建 AttackInfo（每次攻击创建）
        var info = new AttackInfo
        {
            BaseValue = attacker.Attack,
            CritChance = attacker.CritChance,
            CritMultiplier = attacker.CritMultiplier,
            RawAttack = attacker.Attack,
            PenetrationFixed = attacker.PenetrationFixed,
            PenetrationPercent = attacker.PenetrationPercent,
            IsCrit = false,
            FinalDamage = 0f,
        };
        var beforeProc = info;

        // 处理链（材料链表顺序）
        if (side == FightSide.Player) Context.PlayerAttackProcessor.Process(ref info, Context);
        else Context.EnemyAttackProcessor.Process(ref info, Context);
        var afterProc = info;

        // 通知：攻击前（不用于修改）
        Context.RaiseBeforeAttack(side, info);
        
        // 播放攻击音效（玩家攻击时）
        if (side == FightSide.Player && AudioManager.I != null)
        {
            AudioManager.I.PlaySfxOnce(AudioKey.FBX_Attack);
        }

        // 通知：攻击后
        Context.RaiseAfterAttack(side, info);

        // 应用伤害（V0：如果 Calculator 没写 FinalDamage，则回退用 RawAttack）
        var damage = info.FinalDamage > 0f ? info.FinalDamage : info.RawAttack;
        defender.Damage(damage);

        // 通知：伤害已结算（给 UI 飘字等展示用）
        Context.RaiseDamageApplied(side, defenderSide, info, damage);

        // 结算后累加次数
        Context.BattleActionCount += 1;
        if (side == FightSide.Player) Context.PlayerAttackCount += 1;
        else if (side == FightSide.Enemy) Context.EnemyAttackCount += 1;

        if (Context != null && Context.DebugVerbose && Context.DebugLogger != null)
        {
            // afterProc 即“最终结算后”的 info（因为最终结算器在处理链末尾）
            DumpAttackVerbose(side, attacker, defender, beforeProc, afterProc, afterProc, damage);
        }
    }

    private void EndFight()
    {
        if (!_isFighting) return;
        _isFighting = false;

        Context.RaiseBattleEnd();
        if (!Context.Player.IsDead && Context.Enemy.IsDead) Context.RaiseVictory();
        else Context.RaiseDefeat();

        if (Context != null && Context.DebugVerbose && Context.DebugLogger != null)
        {
            var result = (!Context.Player.IsDead && Context.Enemy.IsDead) ? "Victory" : "Defeat";
            Context.DebugLogger($"[Fight] BattleEnd Result={result} PlayerHP={FmtHP(Context.Player)} EnemyHP={FmtHP(Context.Enemy)} Actions={Context.BattleActionCount} PAtk={Context.PlayerAttackCount} EAtk={Context.EnemyAttackCount}");
        }
    }

    private void DumpBattleHeader()
    {
        var c = Context;
        if (c == null || c.DebugLogger == null) return;
        c.DebugLogger($"[Fight] BattleStart ArenaSpeed={c.ArenaSpeedThreshold} " +
                      $"P({FmtCore(c.Player)} SpeedValue={c.PlayerSpeedValue:0.0}) " +
                      $"E({FmtCore(c.Enemy)} SpeedValue={c.EnemySpeedValue:0.0}) " +
                      $"PlayerMods={c.PlayerAttackProcessor.Modifiers.Count} EnemyMods={c.EnemyAttackProcessor.Modifiers.Count} FightComponents={c.FightComponents.Count}");
    }

    private void DumpAttackVerbose(FightSide side, CombatantRuntime attacker, CombatantRuntime defender,
        AttackInfo beforeProc, AttackInfo afterProc, AttackInfo afterCalc, float damage)
    {
        var c = Context;
        if (c == null || c.DebugLogger == null) return;
        string who = side == FightSide.Player ? "Player" : "Enemy";
        c.DebugLogger($"[Fight] ---- Attack {c.CurrentActionNumber} ({who} #{c.CurrentAttackerAttackNumber}) ----");
        c.DebugLogger($"[Fight] SpeedValue P={c.PlayerSpeedValue:0.0}/{c.ArenaSpeedThreshold} E={c.EnemySpeedValue:0.0}/{c.ArenaSpeedThreshold}");
        c.DebugLogger($"[Fight] Attacker {attacker.Name} {FmtCore(attacker)}");
        c.DebugLogger($"[Fight] Defender {defender.Name} {FmtCore(defender)}");
        c.DebugLogger($"[Fight] AttackInfo BeforeProc {FmtInfo(beforeProc)}");
        c.DebugLogger($"[Fight] AttackInfo AfterProc  {FmtInfo(afterProc)}");
        c.DebugLogger($"[Fight] AttackInfo AfterCalc {FmtInfo(afterCalc)}");
        c.DebugLogger($"[Fight] Result damage={damage:0.##} DefenderHP={FmtHP(defender)}");
    }

    private static string FmtHP(CombatantRuntime c)
    {
        if (c == null) return "null";
        return $"{c.CurrentHP:0.##}/{c.MaxHP:0.##}";
    }

    private static string FmtCore(CombatantRuntime c)
    {
        if (c == null) return "null";
        return $"HP={FmtHP(c)} ATK={c.Attack:0.##} DEF={c.Defense:0.##} Crit={c.CritChance:0.##} CritMul={c.CritMultiplier:0.##} SpeedRate={c.SpeedRate}";
    }

    private static string FmtInfo(AttackInfo i)
    {
        return $"Base={i.BaseValue:0.##} Raw={i.RawAttack:0.##} CritChance={i.CritChance:0.##} CritMul={i.CritMultiplier:0.##} IsCrit={i.IsCrit} Final={i.FinalDamage:0.##}";
    }
}


// === Gameplay\Fight\FightSide.cs ===
public enum FightSide
{
    None = 0,
    Player = 1,
    Enemy = 2,
}




// === Gameplay\Fight\FinalDamageCalculator.cs ===
using System;
using UnityEngine;

/// <summary>
/// Final damage settlement. This modifier MUST be executed last in the pipeline.
/// </summary>
[Serializable]
public sealed class FinalDamageCalculator : IAttackInfoModifier
{
    [Tooltip("Enable defense reduction: damage = max(0, raw - defenderDef)")]
    public bool EnableDefenseReduction = true;

    [Tooltip("Enable critical: rand < CritChance => damage *= CritMultiplier")]
    public bool EnableCrit = true;

    private float defValue = 50;

    public void Modify(ref AttackInfo info, FightContext context)
    {
        if (context == null || context.CurrentDefender == null)
        {
            info.FinalDamage = Mathf.Max(0f, info.RawAttack);
            return;
        }

        float damage = info.RawAttack;

        if (EnableCrit)
        {
            bool isCrit = UnityEngine.Random.value < Mathf.Clamp01(info.CritChance);
            info.IsCrit = isCrit;
            if (isCrit)
            {
                damage *= Mathf.Max(1f, info.CritMultiplier);
            }
        }
        if (EnableDefenseReduction)
        {
            //计算有效防御
            float curDef = context.CurrentDefender.Defense*(1-info.PenetrationPercent)-info.PenetrationFixed;
            float reduction;
            if(curDef >= 0)
            {
                reduction = curDef/(curDef+defValue);
            }
            else
            {
                reduction = -(1+Math.Abs(curDef)/defValue);
            }
            damage = Mathf.Max(1f,damage-damage*reduction);
            Debug.Log("damage的伤害是"+damage);
            //damage = Mathf.Max(1f, damage - context.CurrentDefender.Defense);
        }

        info.FinalDamage = damage;
    }
}




// === Gameplay\Fight\IAttackInfoModifier.cs ===
public interface IAttackInfoModifier
{
    /// <summary>
    /// 修改本次攻击信息（材料效果/战斗组件等可实现此接口）。
    /// 注意：修改顺序以“材料链表顺序/注册顺序”为准。
    /// </summary>
    void Modify(ref AttackInfo info, FightContext context);
}




// === Gameplay\Fight\IFightComponent.cs ===
/// <summary>
/// “战斗组件”接口：在开战时注入 FightContext 以订阅回调/注册处理器/做战斗级逻辑。
/// 用于承接文档中“单独抽出来做一个类叫做战斗组件”的要求。
/// </summary>
public interface IFightComponent
{
    void Inject(FightContext context);
}




// === Gameplay\Fight\IPersistentGrowthProvider.cs ===
public interface IPersistentGrowthProvider
{
    /// <summary>
    /// 战后收集持久增值：把增长写入 delta，最后由上层一次性写回到 Player.ActualStats。
    /// </summary>
    void OnCollectPersistentGrowth(Player player, PlayerGrowthDelta delta, FightContext battleContext);
}





// === Gameplay\Mask\BindContext.cs ===
using System;
using System.Collections.Generic;
using UnityEngine;

public readonly struct BindContext
{
    public MaskObj Mask { get; }
    public IReadOnlyList<MaterialObj> Materials { get; }

    /// <summary>
    /// 绑定完成回调入口（用于即时材料的连锁/统计/UI 刷新）。
    /// </summary>
    public Action<MaterialObj> OnMaterialBound { get; }

    public BindContext(MaskObj mask, IReadOnlyList<MaterialObj> materials, Action<MaterialObj> onMaterialBound)
    {
        Mask = mask;
        Materials = materials;
        OnMaterialBound = onMaterialBound;
    }
}




// === Gameplay\Mask\BindFailReason.cs ===
public enum BindFailReason
{
    None = 0,
    InvalidMaterialPrefab = 1,
    NotEnoughMana = 2,
}





// === Gameplay\Mask\BindResult.cs ===
using UnityEngine;

public readonly struct BindResult
{
    public bool Success { get; }
    public BindFailReason FailReason { get; }
    public string Message { get; }
    public MaterialObj Material { get; }

    private BindResult(bool success, BindFailReason failReason, string message, MaterialObj material)
    {
        Success = success;
        FailReason = failReason;
        Message = message;
        Material = material;
    }

    public static BindResult Ok(MaterialObj material) => new(true, BindFailReason.None, null, material);

    public static BindResult Fail(BindFailReason reason, string message) => new(false, reason, message, null);
}




// === Gameplay\Mask\IMaskComponent.cs ===
/// <summary>
/// 面具在进入战斗前的注入接口（V0 占位）。
/// 后续材料系统应在此把“材料链表”上的战斗效果注入到 FightContext 的回调与处理器链中。
/// </summary>
public interface IMaskBattleInjector
{
    void InjectBattleContext(FightContext context);
}

/// <summary>
/// 可选扩展：注入器可提供“面具数量”信息（面具库 + 当前面具）。
/// </summary>
public interface IMaskBattleInjectorWithCount : IMaskBattleInjector
{
    int MaskCount { get; }
}



// === Gameplay\Mask\IMaterialAutoInit.cs ===
public interface IMaterialAutoInit
{
    /// <summary>
    /// MaterialObj.Awake() 中自动调用，用于给子组件一个拿到 owner 的入口（可选）。
    /// </summary>
    void Initialize(MaterialObj owner);
}





// === Gameplay\Mask\IMaterialBattleEndEffect.cs ===
public interface IMaterialBattleEndEffect
{
    void OnBattleEnd(FightContext context);
}





// === Gameplay\Mask\IMaterialBattleStartEffect.cs ===
public interface IMaterialBattleStartEffect
{
    void OnBattleStart(FightContext context);
}





// === Gameplay\Mask\IMaterialBindEffect.cs ===
public interface IMaterialBindEffect
{
    /// <summary>
    /// 绑定到面具阶段执行（即时生效）。
    /// </summary>
    void OnBind(in MaterialVommandeTreeContext context);
}





// === Gameplay\Mask\IMaterialDamageAppliedEffect.cs ===
/// <summary>
/// 行动结算后（已扣血）触发：用于“改变当前生命值”等需要拿到最终伤害的效果。
/// </summary>
public interface IMaterialDamageAppliedEffect
{
    void OnDamageApplied(FightContext context, FightSide attackerSide, FightSide defenderSide, AttackInfo info, float damage);
}




// === Gameplay\Mask\IMaterialDescriptionProvider.cs ===
using System.Text;

/// <summary>
/// 材质描述生成接口：按组件顺序依次写入 StringBuilder。
/// </summary>
public interface IMaterialDescriptionProvider
{
    void AppendDescription(StringBuilder sb);
}





// === Gameplay\Mask\IMaterialLogicNode.cs ===
/// <summary>
/// 逻辑树节点标记接口：
/// - 只有实现该接口的组件，才允许被 MaterialObj.logicTreeRoots 引用并参与运行时注入/执行。
/// - “效果器”不再作为独立注入接口对象存在；它必须以“逻辑节点”的形式出现（即实现本接口，并在内部根据阶段执行）。
/// </summary>
public interface IMaterialLogicNode
{
}

/// <summary>
/// 材质节点/效果器的中文元数据（用于策划友好的显示与中文关键词检索）。
/// - Name：中文名（用于显示）
/// - Keywords：关键词（用于检索，建议用空格分隔）
/// </summary>
[System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
public sealed class MaterialCnMetaAttribute : System.Attribute
{
    public string Name { get; }
    public string Keywords { get; }

    public MaterialCnMetaAttribute(string name, string keywords = "")
    {
        Name = name ?? string.Empty;
        Keywords = keywords ?? string.Empty;
    }
}

/// <summary>
/// 纯“效果器”：只负责根据统一上下文执行效果。
/// - 不实现 IMaterialBindEffect / IMaterialBattleStartEffect 等注入接口
/// - 注入/触发由“逻辑节点（IMaterialLogicNode）”负责
/// </summary>
public interface IMaterialEffect
{
    void Execute(in MaterialVommandeTreeContext context);
}

/// <summary>
/// AttackModify 阶段的纯效果器：允许修改 AttackInfo（ref）。
/// </summary>
public interface IMaterialAttackInfoEffect
{
    void Modify(ref AttackInfo info, in MaterialVommandeTreeContext context);
}




// === Gameplay\Mask\IMaterialTraversalGate.cs ===
/// <summary>
/// 遍历跳出接口：当返回 true 时，MaterialObj 在本次遍历中会提前 break（后续组件不再执行）。
/// </summary>
public interface IMaterialTraversalGate
{
    bool ShouldBreak(in MaterialVommandeTreeContext context);
}





// === Gameplay\Mask\MaskLibraryInjector.cs ===
using System.Collections.Generic;

/// <summary>
/// 将“面具库（多面具）+ 当前面具”统一作为一个注入器交给 FightManager。
/// </summary>
public sealed class MaskLibraryInjector : IMaskBattleInjectorWithCount
{
    private readonly IReadOnlyList<IMaskBattleInjector> _injectors;

    public MaskLibraryInjector(IReadOnlyList<IMaskBattleInjector> injectors)
    {
        _injectors = injectors;
    }

    public int MaskCount => _injectors != null ? _injectors.Count : 0;

    public void InjectBattleContext(FightContext context)
    {
        if (context == null || _injectors == null) return;
        for (int i = 0; i < _injectors.Count; i++)
        {
            _injectors[i]?.InjectBattleContext(context);
        }
    }
}





// === Gameplay\Mask\MaskMakeManager.cs ===
using Sirenix.OdinInspector;
using UnityEngine;

/// <summary>
/// 面具制造管理器：每次制造都从“底板面具 Prefab”生成一个新的 MaskObj，进入材料附加阶段。
/// 约束：必须由 GameManager.Awake() 进行创建与 Initialize（遵循项目初始化规范）。
/// </summary>
public class MaskMakeManager : MonoBehaviour
{
    public static MaskMakeManager I { get; private set; }

    [Header("Base Mask Prefab")]
    [Tooltip("底板面具预制体：每次制造面具时都会先实例化这个对象，然后进行材料附加。")]
    [SerializeField] private MaskObj baseMaskPrefab;

    [Header("Runtime")]
    [SerializeField] private MaskObj currentMask;

    public MaskObj CurrentMask => currentMask;

    public void Initialize()
    {
        if (I != null && I != this)
        {
            Destroy(gameObject);
            return;
        }
        I = this;
    }

    /// <summary>
    /// Jam 测试用：如果未配置 baseMaskPrefab，则在运行时创建一个临时底板面具并作为“模板”使用。
    /// </summary>
    public void EnsureBaseMaskPrefabForTest(int baseMana = 10)
    {
        if (baseMaskPrefab != null) return;

        var go = new GameObject("TempBaseMaskPrefab");
        go.transform.SetParent(transform, false);
        go.hideFlags = HideFlags.HideInHierarchy;

        var mask = go.AddComponent<MaskObj>();
        // MaskObj 自身已有 config 容错；这里确保 baseMana
        mask.RebuildFromConfig(new MaskObj.StaticConfig
        {
            BaseMana = Mathf.Max(0, baseMana),
            DisplayName = "TempMask",
            Description = "Jam 自动生成的底板面具（仅用于测试跑流程）。"
        });

        baseMaskPrefab = mask;
    }

    [Button(ButtonSizes.Medium)]
    public MaskObj MakeNextMask()
    {
        // 如果当前面具还没被上层“入库/接管”，则制造新面具前先销毁旧的（避免泄漏）。
        if (currentMask != null)
        {
            Destroy(currentMask.gameObject);
            currentMask = null;
        }

        if (baseMaskPrefab == null)
        {
            // Jam 容错：尝试自动生成一个临时底板面具，保证流程可跑
            EnsureBaseMaskPrefabForTest(10);
        }
        if (baseMaskPrefab == null)
        {
            Debug.LogError("[MaskMakeManager] baseMaskPrefab 未配置且自动生成失败，无法制造面具。", this);
            return null;
        }

        currentMask = Instantiate(baseMaskPrefab, transform, false);
        currentMask.name = $"MaskObj_RunMask";
        return currentMask;
    }

    /// <summary>
    /// 战斗结束后，上层将当前面具“入库接管”，并清空 currentMask，避免下一次 MakeNextMask 销毁入库面具。
    /// </summary>
    public MaskObj DetachCurrentMaskForLibrary()
    {
        var m = currentMask;
        currentMask = null;
        return m;
    }
}




// === Gameplay\Mask\MaskObj.cs ===
using UnityEngine;

public class MaskObj : MonoBehaviour, IMaskBattleInjector
{
    [System.Serializable]
    public class StaticConfig
    {
        [Min(0)] public int BaseMana;
        public string DisplayName;
        [TextArea] public string Description;
    }

    [Header("Config")]
    [SerializeField] private StaticConfig config;

    [Header("Runtime")]
    [SerializeField] private Transform materialRoot;
    [SerializeField] private Sprite displaySprite;

    public int BaseMana { get; private set; }
    public int CurrentMana { get; private set; }
    public Sprite DisplaySprite
    {
        get => displaySprite;
        set => displaySprite = value;
    }

    private readonly System.Collections.Generic.List<MaterialObj> _materials = new();
    public System.Collections.Generic.IReadOnlyList<MaterialObj> Materials => _materials;

    public event System.Action<MaterialObj> OnMaterialBound;

    private void Awake()
    {
        if (materialRoot == null) materialRoot = transform;
        // Jam 容错：如果没有配置 config，提供一个默认值，避免 NRE
        if (config == null)
        {
            config = new StaticConfig
            {
                BaseMana = 10,
                DisplayName = "Mask",
                Description = string.Empty
            };
        }
        RebuildFromConfig(config);
    }

    /// <summary>
    /// 使用配置重建面具实例（战后“旧面具不保留”的 V0 流程可直接调用该方法重建）。
    /// </summary>
    public void RebuildFromConfig(StaticConfig cfg)
    {
        // Jam 容错：cfg 为空则给一个默认配置
        config = cfg ?? new StaticConfig { BaseMana = 10, DisplayName = "Mask", Description = string.Empty };
        BaseMana = Mathf.Max(0, config.BaseMana);
        CurrentMana = BaseMana;

        // 清理旧材料实例
        for (int i = materialRoot.childCount - 1; i >= 0; i--)
        {
            Destroy(materialRoot.GetChild(i).gameObject);
        }
        _materials.Clear();
    }

    public void AddMana(int delta)
    {
        if (delta == 0) return;
        CurrentMana = Mathf.Max(0, CurrentMana + delta);
    }

    /// <summary>
    /// 绑定一个材料：不会实例化，不会创建新物体，只将其纳入链表并触发 OnBind。
    /// </summary>
    public BindResult BindMaterial(MaterialObj material)
    {
        if (material == null)
        {
            return BindResult.Fail(BindFailReason.InvalidMaterialPrefab, "材料为空。");
        }

        int cost = Mathf.Max(0, material.ManaCost);

        if (CurrentMana < cost)
        {
            return BindResult.Fail(BindFailReason.NotEnoughMana, $"法力值不足：需要 {cost}，当前 {CurrentMana}。");
        }

        CurrentMana -= cost;

        // 加入链表（顺序很重要）
        _materials.Add(material);

        // 绑定到面具（仅做 re-parent，不创建新物体）
        var go = material.gameObject;
        if (materialRoot != null && go != null && go.transform.parent != materialRoot)
        {
            go.transform.SetParent(materialRoot, false);
        }

        // 即时生效：由 MaterialObj 负责 foreach 所有组件（组件自己决定做不做）
        var ctx = new BindContext(this, _materials, OnMaterialBound);
        material.RunBindEffects(in ctx);

        OnMaterialBound?.Invoke(material);
        return BindResult.Ok(material);
    }

    public void InjectBattleContext(FightContext context)
    {
        // 按“材料链表顺序”注入
        if (context == null) return;

        for (int i = 0; i < _materials.Count; i++)
        {
            var mat = _materials[i];
            if (mat == null) continue;
            mat.InjectBattle(context);
        }
    }
}


// === Gameplay\Mask\MaterialObj.cs ===
using System.Collections.Generic;
using System.Text;
using UnityEngine;

/// <summary>
/// 材料对象（挂在“材料 Prefab”根节点上）。
/// 在 Awake 中自动 GetComponents 并缓存，后续由 MaskObj 直接调用 MaterialObj 完成：
/// - 绑定阶段即时效果
/// - 进入战斗前注入 FightContext（回调/处理链）
/// </summary>
public class MaterialObj : MonoBehaviour
{
    public enum MaterialType
    {
        Cost = 0,
        Attack = 1,
        Survival = 2,
        Special = 3,
    }

    [Header("Base Data")]
    [Min(0)] public int Id = 0;
    [Tooltip("材质名（用于 UI 与保存命名）。")]
    public string DisplayName;

    [Tooltip("材质类型。")]
    public MaterialType Type = MaterialType.Attack;

    [Min(0)] public int ManaCost = 0;

    public MaterialQuality Quality = MaterialQuality.Common;

    [Tooltip("用于 UI 显示的基础图像。")]
    public Sprite BaseSprite;

    [Header("Inventory")]
    [Tooltip("保质期（回合）：从获取开始算，经过多少个“制造面具回合结束”后会在材料库中销毁。")]
    [Min(1)] public int ShelfLifeTurns = 1;

    [SerializeField, Min(0)] private int remainingShelfLifeTurns = 0;
    public int RemainingShelfLifeTurns => remainingShelfLifeTurns;

    /// <summary>
    /// 入库时调用：把 RemainingShelfLifeTurns 重置为 ShelfLifeTurns。
    /// </summary>
    public void ResetInventoryShelfLife()
    {
        remainingShelfLifeTurns = Mathf.Max(1, ShelfLifeTurns);
    }

    /// <summary>
    /// 库存回合结算：Remaining--，返回是否过期（<=0）。
    /// 注意：仅库存中的材料会被调用；已绑定到面具的材料不参与库存结算。
    /// </summary>
    public bool TickInventory()
    {
        remainingShelfLifeTurns = Mathf.Max(0, remainingShelfLifeTurns - 1);
        return remainingShelfLifeTurns <= 0;
    }

    [Header("Logic Tree (Editor)")]
    [Tooltip("材质逻辑树：条件节点可挂子节点；条件不满足时仅跳过该分支。运行时只使用树状逻辑（不再兼容旧链式）。")]
    [SerializeField] private List<MaterialLogicNode> logicTreeRoots = new();

    public IReadOnlyList<MaterialLogicNode> LogicTreeRoots => logicTreeRoots;

    private bool HasLogicTree => logicTreeRoots != null && logicTreeRoots.Count > 0;

    /// <summary>
    /// 按“配置好的顺序”生成描述：依次调用 IMaterialDescriptionProvider；遇到 Gate 跳出则提前结束。
    /// </summary>
    public string BuildDescription()
    {
        var sb = new StringBuilder(128);
        BuildDescription(sb);
        return sb.ToString();
    }

    public void BuildDescription(StringBuilder sb)
    {
        if (sb == null) return;
        if (!HasLogicTree)
        {
            sb.Append("（该材质未配置逻辑树）");
            return;
        }

        // 树状描述：逻辑节点用红色标记，组件间用逗号分隔，每个 tree（根节点分支）结束时用句号和换行。
        // 注意：组件允许复用，因此这里不做去重，保证结构可读。
        for (int i = 0; i < logicTreeRoots.Count; i++)
        {
            var root = logicTreeRoots[i];
            if (root == null) continue;
            
            // 遍历当前根节点及其所有子节点
            BuildTreeDescriptionForNode(sb, root);
            
            // 每个 tree 结束时添加句号和换行
            if (sb.Length > 0)
            {
                // 检查末尾是否是"。\n"
                bool endsWithPeriodAndNewline = sb.Length >= 2 && 
                    sb[sb.Length - 1] == '\n' && 
                    sb[sb.Length - 2] == '。';
                
                if (!endsWithPeriodAndNewline)
                {
                    // 如果末尾是句号但没有换行，先移除句号再添加"。\n"
                    if (sb.Length > 0 && sb[sb.Length - 1] == '。')
                    {
                        sb.Length--; // 移除句号
                    }
                    sb.Append("。\n");
                }
            }
        }
    }

    private static void BuildTreeDescriptionForNode(StringBuilder sb, MaterialLogicNode node)
    {
        if (node == null) return;
        
        var c = node.Component;
        if (c != null && c is IMaterialDescriptionProvider p)
        {
            bool isLogicNode = c is IMaterialLogicNode;
            bool notNodeEffect = c as Node_Effect ==null;
            if (isLogicNode && notNodeEffect)
            {
                sb.Append($"<color=red>");
                p.AppendDescription(sb);
                sb.Append($"</color>");
            }
            else{
                p.AppendDescription(sb);
                char lastChar = sb[sb.Length - 1];
                if (lastChar != '，' && lastChar != '。' && lastChar != '\n')
                {
                    sb.Append(" ");
                }
            }
        }
        
        // 递归处理子节点
        if (node.Children != null && node.Children.Count > 0)
        {
            for (int i = 0; i < node.Children.Count; i++)
            {
                BuildTreeDescriptionForNode(sb, node.Children[i]);
            }
        }
    }

    public void RunBindEffects(in BindContext context)
    {
        if (!HasLogicTree)
        {
            Debug.LogWarning($"[MaterialObj] {name} 未配置 logicTreeRoots，无法执行 Bind。", this);
            return;
        }

        var tctx = new MaterialVommandeTreeContext(
            MaterialTraversePhase.Bind,
            mask: context.Mask,
            maskMaterials: context.Materials,
            onMaterialBound: context.OnMaterialBound,
            fight: null,
            side: FightSide.None,
            defenderSide: FightSide.None,
            actionNumber: 0,
            attackerAttackNumber: 0,
            attackInfo: default,
            damage: 0f,
            player: null,
            growthDelta: null
        );
        TraverseTreeBind(logicTreeRoots, in tctx);
    }

    private void TraverseTreeBind(List<MaterialLogicNode> nodes, in MaterialVommandeTreeContext tctx)
    {
        if (nodes == null) return;
        for (int i = 0; i < nodes.Count; i++)
        {
            var n = nodes[i];
            if (n == null) continue;
            var c = n.Component;

            // 条件节点：break 仅影响该分支（跳过 Children），不影响兄弟节点
            if (c is IMaterialTraversalGate gate)
            {
                if (gate.ShouldBreak(in tctx)) continue;
            }

            if (c is IMaterialAutoInit init) init.Initialize(this);
            if (c is IMaterialBindEffect bind) bind.OnBind(in tctx);

            if ((c == null || c is IMaterialTraversalGate) && n.Children != null && n.Children.Count > 0)
            {
                TraverseTreeBind(n.Children, in tctx);
            }
        }
    }

    public void InjectBattle(FightContext context)
    {
        if (context == null) return;
        if (!HasLogicTree)
        {
            Debug.LogWarning($"[MaterialObj] {name} 未配置 logicTreeRoots，无法注入战斗。", this);
            return;
        }

        // 每个材料注入一个“运行时执行器”，它会遍历逻辑树并触发对应阶段的逻辑节点
        var runner = new MaterialRuntimeRunner(this);
        context.AddFightComponent(runner);
        context.PlayerAttackProcessor.Add(runner);
        context.EnemyAttackProcessor.Add(runner);
    }
}




// === Gameplay\Mask\MaterialRuntimeRunner.cs ===
using System.Collections.Generic;
using System.Text;
using UnityEngine;

/// <summary>
/// 材质运行时执行器：遍历 MaterialObj.logicTreeRoots，并触发各阶段逻辑节点。
/// - 作为 IFightComponent：订阅战斗回调（BattleStart/BattleEnd/DamageApplied）
/// - 作为 IAttackInfoModifier：在攻击处理链中触发 “玩家/敌人攻击前” 阶段
/// </summary>
public sealed class MaterialRuntimeRunner : IFightComponent, IAttackInfoModifier
{
    private readonly MaterialObj _material;

    public MaterialRuntimeRunner(MaterialObj material)
    {
        _material = material;
    }

    public void Inject(FightContext context)
    {
        if (context == null) return;
        context.OnBattleStart += OnBattleStart;
        context.OnBattleEnd += OnBattleEnd;
        context.OnDamageApplied += OnDamageApplied;
    }

    private void OnBattleStart(FightContext context)
    {
        if (_material == null) return;
        if (_material.LogicTreeRoots == null || _material.LogicTreeRoots.Count == 0)
        {
            if (context != null && context.DebugVerbose)
            {
                context.DebugLogger?.Invoke($"[MaterialRuntimeRunner] {_material.name} 未配置 logicTreeRoots，跳过 BattleStart。");
            }
            return;
        }

        var treeCtx = new MaterialVommandeTreeContext(
            MaterialTraversePhase.BattleStart,
            mask: null,
            maskMaterials: null,
            onMaterialBound: null,
            fight: null,
            side: FightSide.None,
            defenderSide: FightSide.None,
            actionNumber: 0,
            attackerAttackNumber: 0,
            attackInfo: default,
            damage: 0f,
            player: null,
            growthDelta: null
        );
        TraverseTree_BattleStart(_material.LogicTreeRoots, in treeCtx);
    }

    private void TraverseTree_BattleStart(IReadOnlyList<MaterialLogicNode> nodes, in MaterialVommandeTreeContext tctx)
    {
        if (nodes == null) return;
        for (int i = 0; i < nodes.Count; i++)
        {
            var n = nodes[i];
            if (n == null) continue;
            var c = n.Component;

            if (c is IMaterialTraversalGate g && g.ShouldBreak(in tctx))
            {
                LogGateBreak(tctx.Fight, "BattleStart(Tree)", g, tctx);
                continue; // break 仅影响分支：跳过 Children
            }

            if (c is IMaterialBattleStartEffect start)
            {
                LogEffect(tctx.Fight, "BattleStart(Tree)", c);
                start.OnBattleStart(tctx.Fight);
            }

            // 只有“逻辑节点（gate/空节点）”允许有子节点；效果节点不遍历 children
            if ((c == null || c is IMaterialTraversalGate) && n.Children != null && n.Children.Count > 0)
            {
                TraverseTree_BattleStart(n.Children, in tctx);
            }
        }
    }

    private void OnBattleEnd(FightContext context)
    {
        if (_material == null) return;
        if (_material.LogicTreeRoots == null || _material.LogicTreeRoots.Count == 0)
        {
            if (context != null && context.DebugVerbose)
            {
                context.DebugLogger?.Invoke($"[MaterialRuntimeRunner] {_material.name} 未配置 logicTreeRoots，跳过 BattleEnd。");
            }
            return;
        }

        var treeCtx = new MaterialVommandeTreeContext(
            MaterialTraversePhase.BattleEnd,
            mask: null,
            maskMaterials: null,
            onMaterialBound: null,
            fight: null,
            side: FightSide.None,
            defenderSide: FightSide.None,
            actionNumber: context != null ? context.BattleActionCount : 0,
            attackerAttackNumber: 0,
            attackInfo: default,
            damage: 0f,
            player: null,
            growthDelta: null
        );
        TraverseTree_BattleEnd(_material.LogicTreeRoots, in treeCtx);
    }

    private void TraverseTree_BattleEnd(IReadOnlyList<MaterialLogicNode> nodes, in MaterialVommandeTreeContext tctx)
    {
        if (nodes == null) return;
        for (int i = 0; i < nodes.Count; i++)
        {
            var n = nodes[i];
            if (n == null) continue;
            var c = n.Component;

            if (c is IMaterialTraversalGate g && g.ShouldBreak(in tctx))
            {
                LogGateBreak(tctx.Fight, "BattleEnd(Tree)", g, tctx);
                continue;
            }

            if (c is IMaterialBattleEndEffect end)
            {
                LogEffect(tctx.Fight, "BattleEnd(Tree)", c);
                end.OnBattleEnd(tctx.Fight);
            }

            if ((c == null || c is IMaterialTraversalGate) && n.Children != null && n.Children.Count > 0)
            {
                TraverseTree_BattleEnd(n.Children, in tctx);
            }
        }
    }

    public void Modify(ref AttackInfo info, FightContext context)
    {
        if (_material == null || context == null) return;
        if (_material.LogicTreeRoots == null || _material.LogicTreeRoots.Count == 0)
        {
            if (context != null && context.DebugVerbose)
            {
                context.DebugLogger?.Invoke($"[MaterialRuntimeRunner] {_material.name} 未配置 logicTreeRoots，跳过 AttackModify。");
            }
            return;
        }

        var phase = context.CurrentAttackerSide == FightSide.Enemy
            ? MaterialTraversePhase.EnemyAttackBefore
            : MaterialTraversePhase.PlayerAttackBefore;

        var treeCtx = new MaterialVommandeTreeContext(
            phase,
            mask: null,
            maskMaterials: null,
            onMaterialBound: null,
            fight: null,
            side: context.CurrentAttackerSide,
            actionNumber: context.CurrentActionNumber,
            attackerAttackNumber: context.CurrentAttackerAttackNumber,
            defenderSide: context.CurrentAttackerSide == FightSide.Player ? FightSide.Enemy : FightSide.Player,
            attackInfo: info,
            damage: 0f,
            player: null,
            growthDelta: null
        );
        TraverseTree_AttackModify(_material.LogicTreeRoots, ref info, in treeCtx);
    }

    private void TraverseTree_AttackModify(IReadOnlyList<MaterialLogicNode> nodes, ref AttackInfo info, in MaterialVommandeTreeContext tctx)
    {
        if (nodes == null) return;
        for (int i = 0; i < nodes.Count; i++)
        {
            var n = nodes[i];
            if (n == null) continue;
            var c = n.Component;

            if (c is IMaterialTraversalGate g && g.ShouldBreak(in tctx))
            {
                LogGateBreak(tctx.Fight, "AttackModify(Tree)", g, tctx);
                continue;
            }

            if (n.ActionSide == MaterialActionSideFilter.PlayerOnly && tctx.Side != FightSide.Player) continue;
            if (n.ActionSide == MaterialActionSideFilter.EnemyOnly && tctx.Side != FightSide.Enemy) continue;

            if (c is IAttackInfoModifier mod2)
            {
                LogEffect(tctx.Fight, "AttackModify(Tree)", c);
                mod2.Modify(ref info, tctx.Fight);
            }

            if ((c == null || c is IMaterialTraversalGate) && n.Children != null && n.Children.Count > 0)
            {
                TraverseTree_AttackModify(n.Children, ref info, in tctx);
            }
        }
    }

    private void OnDamageApplied(FightContext context, FightSide attackerSide, FightSide defenderSide, AttackInfo info, float damage)
    {
        if (_material == null || context == null) return;
        if (_material.LogicTreeRoots == null || _material.LogicTreeRoots.Count == 0) return;

        var phase = attackerSide == FightSide.Enemy
            ? MaterialTraversePhase.EnemyAttackAfter
            : MaterialTraversePhase.PlayerAttackAfter;

        var tctx = new MaterialVommandeTreeContext(
            phase,
            mask: null,
            maskMaterials: null,
            onMaterialBound: null,
            fight: null,
            side: attackerSide,
            defenderSide: defenderSide,
            actionNumber: context.CurrentActionNumber,
            attackerAttackNumber: context.CurrentAttackerAttackNumber,
            attackInfo: info,
            damage: damage,
            player: null,
            growthDelta: null
        );
        TraverseTree_DamageApplied(_material.LogicTreeRoots, attackerSide, defenderSide, info, damage, in tctx);
    }

    private void TraverseTree_DamageApplied(IReadOnlyList<MaterialLogicNode> nodes, FightSide attackerSide, FightSide defenderSide, AttackInfo info, float damage, in MaterialVommandeTreeContext tctx)
    {
        if (nodes == null) return;
        for (int i = 0; i < nodes.Count; i++)
        {
            var n = nodes[i];
            if (n == null) continue;
            var c = n.Component;

            if (c is IMaterialTraversalGate g && g.ShouldBreak(in tctx))
            {
                LogGateBreak(tctx.Fight, "DamageApplied(Tree)", g, tctx);
                continue;
            }

            // 行动侧筛选
            if (n.ActionSide == MaterialActionSideFilter.PlayerOnly && attackerSide != FightSide.Player) continue;
            if (n.ActionSide == MaterialActionSideFilter.EnemyOnly && attackerSide != FightSide.Enemy) continue;

            if (c is IMaterialDamageAppliedEffect e)
            {
                LogEffect(tctx.Fight, "DamageApplied(Tree)", c);
                e.OnDamageApplied(tctx.Fight, attackerSide, defenderSide, info, damage);
            }
            if ((c == null || c is IMaterialTraversalGate) && n.Children != null && n.Children.Count > 0)
            {
                TraverseTree_DamageApplied(n.Children, attackerSide, defenderSide, info, damage, in tctx);
            }
        }
    }

    private void LogGateBreak(FightContext context, string phase, IMaterialTraversalGate gate, in MaterialVommandeTreeContext tctx)
    {
        if (context == null || !context.DebugVerbose || context.DebugLogger == null) return;
        var name = _material != null ? (!string.IsNullOrWhiteSpace(_material.DisplayName) ? _material.DisplayName : _material.name) : "nullMaterial";
        context.DebugLogger($"[MatGate] {name} phase={phase}({ToCnPhase(tctx.Phase, tctx.Side)}) gate={gate.GetType().Name} BREAK action={tctx.ActionNumber} atk#{tctx.AttackerAttackNumber} side={tctx.Side}");
    }

    private static string ToCnPhase(MaterialTraversePhase phase, FightSide side)
    {
        switch (phase)
        {
            case MaterialTraversePhase.Bind:
                return "绑定";
            case MaterialTraversePhase.BattleStart:
                return "战斗开始";
            case MaterialTraversePhase.AttackModify:
                return "攻击前（Legacy）";
            case MaterialTraversePhase.DamageApplied:
                return "攻击后（Legacy）";
            case MaterialTraversePhase.PlayerAttackBefore:
                return "玩家攻击前";
            case MaterialTraversePhase.PlayerAttackAfter:
                return "玩家攻击后";
            case MaterialTraversePhase.EnemyAttackBefore:
                return "敌人攻击前";
            case MaterialTraversePhase.EnemyAttackAfter:
                return "敌人攻击后";
            case MaterialTraversePhase.BattleEnd:
                return "战斗结束";
            case MaterialTraversePhase.PersistentGrowth:
                return "持久成长结算";
            case MaterialTraversePhase.Description:
                return "描述";
            default:
                return phase.ToString();
        }
    }

    private void LogEffect(FightContext context, string phase, MonoBehaviour comp)
    {
        if (context == null || !context.DebugVerbose || context.DebugLogger == null) return;
        if (comp == null) return;

        var matName = _material != null ? (!string.IsNullOrWhiteSpace(_material.DisplayName) ? _material.DisplayName : _material.name) : "nullMaterial";
        var desc = BuildComponentDesc(comp);
        if (string.IsNullOrWhiteSpace(desc))
        {
            context.DebugLogger($"[MatFx] {matName} phase={phase} comp={comp.GetType().Name}");
        }
        else
        {
            context.DebugLogger($"[MatFx] {matName} phase={phase} comp={comp.GetType().Name} desc={desc}");
        }
    }

    private static string BuildComponentDesc(MonoBehaviour comp)
    {
        try
        {
            if (comp is IMaterialDescriptionProvider p)
            {
                var sb = new StringBuilder(128);
                p.AppendDescription(sb);
                return sb.ToString().Trim().Replace("\n", " | ").Replace("\r", "");
            }
        }
        catch { /* ignore */ }
        return string.Empty;
    }
}




// === Gameplay\Mask\MaterialTraverseContext.cs ===
/// <summary>
/// 仅保留阶段枚举（旧的 TraverseContext 结构体已移除，统一使用 MaterialVommandeTreeContext）。
/// </summary>
public enum MaterialTraversePhase
{
    Bind = 0,
    BattleStart = 1,
    // Legacy（旧配置仍可能使用，运行时会映射到 Player/Enemy 具体事件）
    AttackModify = 2,
    DamageApplied = 3,
    BattleEnd = 4,
    PersistentGrowth = 5,
    Description = 6,

    // 新阶段：明确区分玩家/敌人的“攻击前/攻击后”
    PlayerAttackBefore = 7,
    PlayerAttackAfter = 8,
    EnemyAttackBefore = 9,
    EnemyAttackAfter = 10,
}




// === Gameplay\Mask\MaterialVommandeTreeContext.cs ===
using System;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// 统一的材料逻辑树上下文（所有阶段共用）。
/// 设计目标：
/// - 不再拆分 BindContext/TraverseContext 等多套上下文
/// - 逻辑节点基于该上下文判断 Gate、并驱动效果器执行
/// </summary>
public readonly struct MaterialVommandeTreeContext
{
    public readonly MaterialTraversePhase Phase;

    // ---- Make/Bind ----
    public readonly MaskObj Mask;
    public readonly IReadOnlyList<MaterialObj> MaskMaterials;
    public readonly Action<MaterialObj> OnMaterialBound;

    // ---- Battle ----
    private readonly FightContext _fightOverride;
    public FightContext Fight => _fightOverride ?? FightManager.I?.Context;
    /// <summary>本次动作发起方（通常是 attackerSide）。</summary>
    public readonly FightSide Side;
    /// <summary>本次动作目标方（通常是 defenderSide；仅在 DamageApplied 等阶段有效）。</summary>
    public readonly FightSide DefenderSide;
    public readonly int ActionNumber;
    public readonly int AttackerAttackNumber;
    public readonly AttackInfo AttackInfo;
    public readonly float Damage;

    // ---- Settlement / Growth ----
    private readonly Player _playerOverride;
    public Player Player => _playerOverride ?? Player.I;
    public readonly PlayerGrowthDelta GrowthDelta => GameManager.I.PendingGrowthDelta;

    public MaterialVommandeTreeContext(
        MaterialTraversePhase phase,
        MaskObj mask,
        IReadOnlyList<MaterialObj> maskMaterials,
        Action<MaterialObj> onMaterialBound,
        FightContext fight,
        FightSide side,
        FightSide defenderSide,
        int actionNumber,
        int attackerAttackNumber,
        AttackInfo attackInfo,
        float damage,
        Player player,
        PlayerGrowthDelta growthDelta)
    {
        Phase = phase;
        Mask = mask;
        MaskMaterials = maskMaterials;
        OnMaterialBound = onMaterialBound;
        _fightOverride = fight;
        Side = side;
        DefenderSide = defenderSide;
        ActionNumber = Mathf.Max(0, actionNumber);
        AttackerAttackNumber = Mathf.Max(0, attackerAttackNumber);
        AttackInfo = attackInfo;
        Damage = damage;
        _playerOverride = player;
    }

    public static MaterialVommandeTreeContext ForDescription()
    {
        return new MaterialVommandeTreeContext(
            MaterialTraversePhase.Description,
            mask: null,
            maskMaterials: null,
            onMaterialBound: null,
            fight: null,
            side: FightSide.None,
            defenderSide: FightSide.None,
            actionNumber: 0,
            attackerAttackNumber: 0,
            attackInfo: default,
            damage: 0f,
            player: null,
            growthDelta: null
        );
    }
}




// === Gameplay\Mask\Effects\AddByMaskCountMaterial.cs ===
using System.Text;
using UnityEngine;

public enum AttackInfoNumericField
{
    RawAttack = 0,
    BaseValue = 1,
    CritChance = 2,
    CritMultiplier = 3,
}

/// <summary>
/// 行动阶段（AttackModify）：按面具数量缩放数值。
/// 例：每有 1 个面具，RawAttack +2。
/// </summary>
[MaterialCnMeta("按面具数量加成", "面具数量 缩放 叠加 攻击 暴击 爆伤")]
public sealed class AddByMaskCountMaterial : MonoBehaviour, IMaterialAttackInfoEffect, IMaterialDescriptionProvider
{
    [SerializeField] private AttackInfoNumericField field = AttackInfoNumericField.RawAttack;
    [Tooltip("每个面具提供的加成（可负数）。")]
    [SerializeField] private float addPerMask = 1f;

    public void Modify(ref AttackInfo info, in MaterialVommandeTreeContext context)
    {
        if (context.Fight == null) return;
        int count = Mathf.Max(0, context.Fight.MaskCount);
        if (count <= 0) return;

        var add = count * addPerMask;
        if (add == 0f) return;

        switch (field)
        {
            case AttackInfoNumericField.BaseValue:
                info.BaseValue += add;
                return;
            case AttackInfoNumericField.CritChance:
                info.CritChance = Mathf.Clamp01(info.CritChance + add);
                return;
            case AttackInfoNumericField.CritMultiplier:
                info.CritMultiplier = Mathf.Max(1f, info.CritMultiplier + add);
                return;
            case AttackInfoNumericField.RawAttack:
            default:
                info.RawAttack += add;
                return;
        }
    }

    public void AppendDescription(StringBuilder sb)
    {
        if (sb == null) return;
        var name = field switch
        {
            AttackInfoNumericField.RawAttack => "攻击",
            AttackInfoNumericField.BaseValue => "基础攻击",
            AttackInfoNumericField.CritChance => "暴击率",
            AttackInfoNumericField.CritMultiplier => "爆伤倍率",
            _ => field.ToString()
        };
        sb.Append($"每有 1 个面具，{name} {(addPerMask >= 0 ? "+" : "")}{addPerMask:0.##}");
    }
}




// === Gameplay\Mask\Effects\Battle_StatPercentAttachMaterial.cs ===
using System.Text;
using UnityEngine;

/// <summary>
/// 战斗开始时：将“来源属性 * 百分比”附加到“目标属性”。
/// 例：将 玩家攻击 的 50% 附加到 玩家防御。
/// </summary>
public sealed class Battle_StatPercentAttachMaterial : MonoBehaviour, IMaterialEffect, IMaterialDescriptionProvider
{
    [Header("Source")]
    [SerializeField] private FightSide sourceSide = FightSide.Player;
    [SerializeField] private StatKey sourceStat = StatKey.Attack;

    [Header("Target")]
    [SerializeField] private FightSide targetSide = FightSide.Player;
    [SerializeField] private StatKey targetStat = StatKey.Defense;

    [Header("Formula")]
    [Tooltip("百分比系数：0.2=20%，1=100%，可填负数")]
    [SerializeField] private float percent = 0.5f;

    [Tooltip("当目标为 MaxHP 时，是否同时治疗（保持血量比例/补差值）。")]
    [SerializeField] private bool maxHpAlsoHeal = true;

    public void Execute(in MaterialVommandeTreeContext context)
    {
        if (context.Fight == null) return;

        var src = ApplyTo(sourceSide, context.Fight);
        var dst = ApplyTo(targetSide, context.Fight);
        if (src == null || dst == null) return;

        if (sourceStat == StatKey.Luck || targetStat == StatKey.Luck)
        {
            if (context.Fight.DebugVerbose)
                Debug.LogWarning($"[BattleStart_StatPercentAttachMaterial] 战斗运行时不支持 Luck；source={sourceStat}, target={targetStat}", this);
            return;
        }

        var srcValue = StatMathUtil.GetFromCombatant(src, sourceStat);
        var add = srcValue * percent;
        StatMathUtil.AddToCombatant(dst, targetStat, add, maxHpAlsoHeal);

        if (context.Fight.DebugVerbose)
        {
            Debug.Log(
                $"[BattleStart_StatPercentAttachMaterial] {sourceSide}.{sourceStat}({srcValue}) * {percent:P0} => add {add} to {targetSide}.{targetStat}",
                this);
        }
    }

    private static CombatantRuntime ApplyTo(FightSide side, FightContext context)
    {
        if (context == null) return null;
        if (side == FightSide.Player) return context.Player;
        if (side == FightSide.Enemy) return context.Enemy;
        return null;
    }

    public void AppendDescription(StringBuilder sb)
    {
        if (sb == null) return;

        var srcWho = sourceSide == FightSide.Enemy ? "敌人" : "玩家";
        var dstWho = targetSide == FightSide.Enemy ? "敌人" : "玩家";

        if (sourceStat == StatKey.Luck || targetStat == StatKey.Luck)
        {
            sb.Append("（战斗内不支持 幸运 属性转换）");
            return;
        }

        sb.Append($"将 {srcWho}{StatMathUtil.ToCnName(sourceStat)} 的 {percent:P0} 附加到 {dstWho}{StatMathUtil.ToCnName(targetStat)}");
    }
}




// === Gameplay\Mask\Effects\DamageApplied_ModifyCurrentHPMaterial.cs ===
using System.Text;
using UnityEngine;

public enum CurrentHpModifyTarget
{
    Attacker = 0,
    Defender = 1,
}

public enum CurrentHpModifyMode
{
    Flat = 0,
    PercentOfMaxHP = 1,
}

/// <summary>
/// 行动结算后（已扣血）：改变某一方的当前生命值（可正可负）。
/// - Flat：直接加/减固定值
/// - Percent：按目标 MaxHP 的百分比加/减
/// </summary>
[MaterialCnMeta("行动后改当前生命", "吸血 反伤 治疗 生命 行动后 结算后")]
public sealed class DamageApplied_ModifyCurrentHPMaterial : MonoBehaviour, IMaterialEffect, IMaterialDescriptionProvider
{
    [SerializeField] private CurrentHpModifyTarget target = CurrentHpModifyTarget.Attacker;
    [SerializeField] private CurrentHpModifyMode mode = CurrentHpModifyMode.Flat;

    [Tooltip("固定值变化（可负数）。")]
    [SerializeField] private float flatDelta = 0f;

    [Tooltip("按 MaxHP 的百分比变化（可负数）。0.1=+10%，-0.2=-20%。")]
    [SerializeField] private float percentOfMaxHpDelta = 0f;

    public void Execute(in MaterialVommandeTreeContext context)
    {
        if (context.Fight == null) return;

        CombatantRuntime t;
        if (target == CurrentHpModifyTarget.Defender)
        {
            t = context.DefenderSide == FightSide.Player ? context.Fight.Player : context.Fight.Enemy;
        }
        else
        {
            t = context.Side == FightSide.Player ? context.Fight.Player : context.Fight.Enemy;
        }

        if (t == null) return;

        float delta = 0f;
        switch (mode)
        {
            case CurrentHpModifyMode.PercentOfMaxHP:
                delta = t.MaxHP * percentOfMaxHpDelta;
                break;
            case CurrentHpModifyMode.Flat:
            default:
                delta = flatDelta;
                break;
        }

        if (delta != 0f) t.AddCurrentHP(delta);
    }

    public void AppendDescription(StringBuilder sb)
    {
        if (sb == null) return;
        var who = target == CurrentHpModifyTarget.Defender ? "受击者" : "攻击者";
        if (mode == CurrentHpModifyMode.PercentOfMaxHP)
        {
            sb.Append($"{who} 当前生命 {(percentOfMaxHpDelta >= 0 ? "+" : "")}{percentOfMaxHpDelta:P0}（按最大生命）");
        }
        else
        {
            sb.Append($"{who} 当前生命 {(flatDelta >= 0 ? "+" : "")}{flatDelta:0.##}");
        }
    }
}




// === Gameplay\Mask\Effects\Effect_AddStatsMaterial.cs ===
using System.Text;
using UnityEngine;

/// <summary>
/// 统一“加属性”效果器：
/// - ApplyAsPersistentGrowth=false：战斗开始时把数值加到 BattleStats（CombatantRuntime）
/// - ApplyAsPersistentGrowth=true：战斗结束结算时把数值写入 PlayerGrowthDelta（持久成长）
///
/// 注意：
/// - 触发时机建议由逻辑树的 Gate_Phase 决定；
///   本组件自身不负责“阶段逻辑”，只负责“效果”。
/// </summary>
[MaterialCnMeta("加属性", "加属性 增加属性 攻击 防御 血量 暴击 爆伤 速度 幸运 成长")]
public sealed class Effect_AddStatsMaterial : MonoBehaviour, IMaterialEffect, IMaterialDescriptionProvider
{
    [Header("Mode")]
    [Tooltip(
        "运行模式（重要）：\n" +
        "- 不勾选：把数值加到 FightContext 的 CombatantRuntime（战斗临时值）。(只有战斗相关流程生效)\n" +
        "- 勾选：把数值写入 MaterialVommandeTreeContext.GrowthDelta（战后持久成长）。\n" +
        "注意：本组件本身不做阶段判断；阶段由逻辑树的 Gate_Phase 控制。"
    )]
    public bool ApplyAsPersistentGrowth = false;

    [Header("Battle Target (when NOT persistent)")]
    [SerializeField] private FightSide appliesTo = FightSide.Player;

    [Header("Stat Deltas")]
    [SerializeField] private float addAttack = 0f;
    [SerializeField] private float addDefense = 0f;
    [SerializeField] private float addCritChance = 0f;
    [SerializeField] private float addCritMultiplier = 0f;
    [SerializeField] private float addMaxHP = 0f;
    [SerializeField] private int addSpeedRate = 0;
    [SerializeField] private int addLuck = 0;
    [SerializeField] private float addPenetrationPercent = 0f;
    [SerializeField] private float addPenetrationFixed = 0f;

    public void Execute(in MaterialVommandeTreeContext context)
    {
        if (!ApplyAsPersistentGrowth)
        {
            if (context.Fight == null) return;

            var c = ApplyTo(appliesTo, context.Fight);
            if (c == null) return;

            if (addAttack != 0f) c.AddAttack(addAttack);
            if (addDefense != 0f) c.AddDefense(addDefense);
            if (addCritChance != 0f) c.AddCritChance(addCritChance);
            if (addCritMultiplier != 0f) c.AddCritMultiplier(addCritMultiplier);
            if (addMaxHP != 0f) c.AddMaxHP(addMaxHP, alsoHeal: true);
            if (addSpeedRate != 0) c.AddSpeedRate(addSpeedRate);
            if (addPenetrationPercent != 0f) c.AddPenetrationPercent(addPenetrationPercent);
            if (addPenetrationFixed != 0f) c.AddPenetrationFixed(addPenetrationFixed);

            // Luck 不属于 CombatantRuntime（战斗内不支持）
            if (addLuck != 0 && context.Fight.DebugVerbose)
            {
                context.Fight.DebugLogger?.Invoke("[Effect_AddStatsMaterial] 战斗增益模式下忽略 Luck（CombatantRuntime 不包含 Luck）。");
            }

            return;
        }

        // PersistentGrowth（写入 GrowthDelta；阶段由 Gate_Phase(PersistentGrowth) 控制）
        if (context.GrowthDelta == null) return;

        context.GrowthDelta.AddMaxHP += addMaxHP;
        context.GrowthDelta.AddAttack += addAttack;
        context.GrowthDelta.AddDefense += addDefense;
        context.GrowthDelta.AddCritChance += addCritChance;
        context.GrowthDelta.AddCritMultiplier += addCritMultiplier;
        context.GrowthDelta.AddSpeedRate += addSpeedRate;
        context.GrowthDelta.AddLuck += addLuck;
        context.GrowthDelta.AddPenetrationPercent += addPenetrationPercent;
        context.GrowthDelta.AddPenetrationFixed += addPenetrationFixed;
    }

    private static CombatantRuntime ApplyTo(FightSide side, FightContext context)
    {
        if (context == null) return null;
        if (side == FightSide.Player) return context.Player;
        if (side == FightSide.Enemy) return context.Enemy;
        return null;
    }

    public void AppendDescription(StringBuilder sb)
    {
        if (sb == null) return;

        // 这里不写“战斗开始/战斗结束”，交给 Gate_Phase 等逻辑节点表达
        var who = ApplyAsPersistentGrowth ? "玩家" : (appliesTo == FightSide.Enemy ? "敌人" : "玩家");

        var any = false;
        if (addMaxHP != 0f) { sb.Append($"{who} 最大生命 {(addMaxHP >= 0 ? "+" : "")}{addMaxHP}"); any = true; }
        if (addAttack != 0f) { sb.Append($"{who} 攻击 {(addAttack >= 0 ? "+" : "")}{addAttack}"); any = true; }
        if (addDefense != 0f) { sb.Append($"{who} 防御 {(addDefense >= 0 ? "+" : "")}{addDefense}"); any = true; }
        if (addCritChance != 0f) { sb.Append($"{who} 暴击率 {(addCritChance >= 0 ? "+" : "")}{addCritChance:P0}"); any = true; }
        if (addCritMultiplier != 0f) { sb.Append($"{who} 爆伤倍率 {(addCritMultiplier >= 0 ? "+" : "")}{addCritMultiplier}"); any = true; }
        if (addSpeedRate != 0) { sb.Append($"{who} 速度成长 {(addSpeedRate >= 0 ? "+" : "")}{addSpeedRate}/秒"); any = true; }
        if (ApplyAsPersistentGrowth && addLuck != 0) { sb.Append($"{who} 幸运 {(addLuck >= 0 ? "+" : "")}{addLuck}"); any = true; }
        if (addPenetrationPercent != 0f) { sb.Append($"{who} 百分比穿透 {(addPenetrationPercent >= 0 ? "+" : "")}{addPenetrationPercent:P0}"); any = true; }
        if (addPenetrationFixed != 0f) { sb.Append($"{who} 固定穿透 {(addPenetrationFixed >= 0 ? "+" : "")}{addPenetrationFixed}"); any = true; }

        if (!any) sb.Append($"{who} 属性无变化");
    }
}




// === Gameplay\Mask\Effects\PersistentGrowth_StatPercentAttachMaterial.cs ===
using System.Text;
using UnityEngine;

public enum PersistentGrowthSourceDomain
{
    /// <summary>读取玩家当前 ActualStats（不包含本场战斗临时增益）。</summary>
    ActualStats = 0,

    /// <summary>读取 battleContext.Player（包含战斗开始等临时增益后的 BattleStats）。</summary>
    BattleStats = 1,
}

/// <summary>
/// 战后成长：将“来源属性 * 百分比”附加到“目标属性”（写入 PlayerGrowthDelta）。
/// 例：将 最大生命 的 10% 附加到 攻击（按当前 ActualStats 计算）。
/// </summary>
public sealed class PersistentGrowth_StatPercentAttachMaterial : MonoBehaviour, IMaterialEffect, IMaterialDescriptionProvider
{
    [Header("Source")]
    [SerializeField] private PersistentGrowthSourceDomain sourceDomain = PersistentGrowthSourceDomain.ActualStats;
    [SerializeField] private StatKey sourceStat = StatKey.MaxHP;

    [Header("Target")]
    [SerializeField] private StatKey targetStat = StatKey.Attack;

    [Header("Formula")]
    [Tooltip("百分比系数：0.2=20%，1=100%，可填负数")]
    [SerializeField] private float percent = 0.1f;

    public void Execute(in MaterialVommandeTreeContext context)
    {
        if (context.GrowthDelta == null) return;
        if (context.Player == null) return;

        float srcValue;
        switch (sourceDomain)
        {
            case PersistentGrowthSourceDomain.BattleStats:
                srcValue = StatMathUtil.GetFromCombatant(context.Fight == null ? null : context.Fight.Player, sourceStat);
                break;
            case PersistentGrowthSourceDomain.ActualStats:
            default:
                srcValue = StatMathUtil.GetFromPlayerStats(context.Player.ActualStats, sourceStat);
                break;
        }

        var add = srcValue * percent;
        StatMathUtil.AddToGrowth(context.GrowthDelta, targetStat, add);

        if (context.Fight != null && context.Fight.DebugVerbose)
        {
            Debug.Log(
                $"[PersistentGrowth_StatPercentAttachMaterial] {sourceDomain}.{sourceStat}({srcValue}) * {percent:P0} => add {add} to Growth.{targetStat}",
                this);
        }
    }

    public void AppendDescription(StringBuilder sb)
    {
        if (sb == null) return;
        // 去掉“战后/永久提高”等修饰；时间点交给 Gate_Phase(PersistentGrowth) 表达
        sb.Append($"将 {StatMathUtil.ToCnName(sourceStat)} 的 {percent:P0} 附加到 {StatMathUtil.ToCnName(targetStat)}");
    }
}




// === Gameplay\Mask\Effects\RestoreManaImmediateEffect.cs ===
using System.Text;
using UnityEngine;

/// <summary>
/// 示例：即时生效材料效果 - 恢复面具法力值。
/// </summary>
[MaterialCnMeta("恢复法力", "回蓝 法力 恢复 绑定")]
public sealed class RestoreManaImmediateEffect : MonoBehaviour, IMaterialEffect, IMaterialDescriptionProvider
{
    [Min(1)] public int RestoreAmount = 1;

    public void Execute(in MaterialVommandeTreeContext context)
    {
        context.Mask?.AddMana(RestoreAmount);
    }

    public void AppendDescription(StringBuilder sb)
    {
        if (sb == null) return;
        sb.Append($"绑定时：恢复法力值 +{RestoreAmount}");
    }
}




// === Gameplay\Mask\Effects\StatKey.cs ===
using System;

/// <summary>
/// 角色属性枚举：用于“将 A 的百分之 X 附加到 B”这类词条。
/// 注意：战斗运行时（CombatantRuntime）不包含 Luck；若在战斗效果里选择 Luck 会被忽略并输出提示。
/// </summary>
[Serializable]
public enum StatKey
{
    MaxHP = 0,
    Attack = 1,
    Defense = 2,
    CritChance = 3,
    CritMultiplier = 4,
    SpeedRate = 5,
    Luck = 6,
}




// === Gameplay\Mask\Effects\StatMathUtil.cs ===
using UnityEngine;

public static class StatMathUtil
{
    public static string ToCnName(StatKey key)
    {
        switch (key)
        {
            case StatKey.MaxHP: return "最大生命";
            case StatKey.Attack: return "攻击";
            case StatKey.Defense: return "防御";
            case StatKey.CritChance: return "暴击率";
            case StatKey.CritMultiplier: return "爆伤倍率";
            case StatKey.SpeedRate: return "速度成长";
            case StatKey.Luck: return "幸运";
            default: return key.ToString();
        }
    }

    public static float GetFromCombatant(CombatantRuntime c, StatKey key)
    {
        if (c == null) return 0f;
        switch (key)
        {
            case StatKey.MaxHP: return c.MaxHP;
            case StatKey.Attack: return c.Attack;
            case StatKey.Defense: return c.Defense;
            case StatKey.CritChance: return c.CritChance;
            case StatKey.CritMultiplier: return c.CritMultiplier;
            case StatKey.SpeedRate: return c.SpeedRate;
            case StatKey.Luck: return 0f; // 战斗运行时无 Luck
            default: return 0f;
        }
    }

    public static float GetFromPlayerStats(PlayerStats stats, StatKey key)
    {
        switch (key)
        {
            case StatKey.MaxHP: return stats.MaxHP;
            case StatKey.Attack: return stats.Attack;
            case StatKey.Defense: return stats.Defense;
            case StatKey.CritChance: return stats.CritChance;
            case StatKey.CritMultiplier: return stats.CritMultiplier;
            case StatKey.SpeedRate: return stats.SpeedRate;
            case StatKey.Luck: return stats.Luck;
            default: return 0f;
        }
    }

    public static void AddToCombatant(CombatantRuntime c, StatKey key, float delta, bool maxHpAlsoHeal)
    {
        if (c == null) return;
        if (delta == 0f) return;

        switch (key)
        {
            case StatKey.MaxHP:
                c.AddMaxHP(delta, alsoHeal: maxHpAlsoHeal);
                return;
            case StatKey.Attack:
                c.AddAttack(delta);
                return;
            case StatKey.Defense:
                c.AddDefense(delta);
                return;
            case StatKey.CritChance:
                c.AddCritChance(delta);
                return;
            case StatKey.CritMultiplier:
                c.AddCritMultiplier(delta);
                return;
            case StatKey.SpeedRate:
                c.AddSpeedRate(Mathf.RoundToInt(delta));
                return;
            case StatKey.Luck:
                // 战斗运行时无 Luck：忽略
                return;
        }
    }

    public static void AddToGrowth(PlayerGrowthDelta delta, StatKey key, float add)
    {
        if (delta == null) return;
        if (add == 0f) return;

        switch (key)
        {
            case StatKey.MaxHP: delta.AddMaxHP += add; return;
            case StatKey.Attack: delta.AddAttack += add; return;
            case StatKey.Defense: delta.AddDefense += add; return;
            case StatKey.CritChance: delta.AddCritChance += add; return;
            case StatKey.CritMultiplier: delta.AddCritMultiplier += add; return;
            case StatKey.SpeedRate: delta.AddSpeedRate += Mathf.RoundToInt(add); return;
            case StatKey.Luck: delta.AddLuck += Mathf.RoundToInt(add); return;
        }
    }
}




// === Gameplay\Mask\Gates\Gate_AfterXHits.cs ===
using System.Text;
using UnityEngine;

/// <summary>
/// Gate：某一方“受击次数”达到 X 次后才允许执行后续效果（否则跳过该分支）。
/// - 受击次数来源：FightContext 的攻击计数（受击方=对方攻击次数）
/// - 在 DamageApplied/AttackModify 等“当前动作存在受击方”阶段，会把本次受击计入判定（使用 context.AttackerAttackNumber）
/// </summary>
[MaterialCnMeta("受击X次后触发", "受击 挨打 被攻击 X次 后触发 条件")]
public sealed class Gate_AfterXHits : MonoBehaviour, IMaterialLogicNode, IMaterialTraversalGate, IMaterialDescriptionProvider
{
    [Tooltip("要统计受击次数的一方。")]
    public FightSide Target = FightSide.Player;

    [Min(1)]
    public int AfterXHits = 2;

    [Tooltip("取反：受击次数达到 X 次后不执行（未达到时执行）。")]
    public bool Invert = false;

    public bool ShouldBreak(in MaterialVommandeTreeContext context)
    {
        if (context.Phase == MaterialTraversePhase.Description) return false;
        if (AfterXHits <= 0) return false;
        if (context.Fight == null) return true; // 没有战斗上下文无法判断：保守跳过

        int received = GetReceivedHitsSoFar(in context);
        bool allow = received >= AfterXHits;
        if (Invert) allow = !allow;
        return !allow;
    }

    private int GetReceivedHitsSoFar(in MaterialVommandeTreeContext context)
    {
        // 基础：受击次数 = “对方攻击次数”
        int baseReceived = 0;
        if (Target == FightSide.Player) baseReceived = context.Fight.EnemyAttackCount;
        else if (Target == FightSide.Enemy) baseReceived = context.Fight.PlayerAttackCount;

        // 若当前动作正好击中 Target，则把“本次攻击序号”计入（因为 FightManager 在 RaiseDamageApplied 前还没累加计数）
        bool isCurrentHitTarget = (context.DefenderSide == Target);
        if (isCurrentHitTarget && context.AttackerAttackNumber > baseReceived)
        {
            baseReceived = context.AttackerAttackNumber;
        }

        return Mathf.Max(0, baseReceived);
    }

    public void AppendDescription(StringBuilder sb)
    {
        if (sb == null) return;
        var who = Target == FightSide.Enemy ? "敌人" : "玩家";
        sb.Append(Invert
            ? $"{who} 受击达到 {AfterXHits} 次后不执行后续效果"
            : $"{who} 受击达到 {AfterXHits} 次后执行后续效果");
    }
}




// === Gameplay\Mask\Gates\Gate_AtXAttack.cs ===
using System.Text;
using UnityEngine;

/// <summary>
/// Gate：第 X 次攻击允许执行（否则跳出）。
/// 取反：第 X 次攻击不执行（其它攻击执行）。
/// </summary>
public class Gate_AtXAttack : MonoBehaviour, IMaterialLogicNode, IMaterialTraversalGate, IMaterialDescriptionProvider
{
    [Min(1)] public int AttackIndex = 1;
    [Tooltip("取反：第X次攻击不执行。")]
    public bool Invert = false;

    public bool ShouldBreak(in MaterialVommandeTreeContext context)
    {
        if (context.Phase == MaterialTraversePhase.Description) return false;
        if (AttackIndex <= 0) return false;
        if (context.AttackerAttackNumber <= 0) return false;

        bool allow = context.AttackerAttackNumber == AttackIndex;
        if (Invert) allow = !allow;
        return !allow;
    }

    public void AppendDescription(StringBuilder sb)
    {
        if (sb == null) return;
        sb.Append(Invert ? $"第{AttackIndex}次攻击不执行后续效果" : $"第{AttackIndex}次攻击执行后续效果");
    }
}




// === Gameplay\Mask\Gates\Gate_MaxTriggerCount.cs ===
using System.Text;
using UnityEngine;

/// <summary>
/// Gate：最多允许通过 X 次（超过后跳过该分支）。
/// - “通过次数”是运行时计数（每次 ShouldBreak 返回 false 都会 +1）
/// - 默认在 BattleStart 时自动重置计数（避免跨战斗污染）
/// </summary>
[MaterialCnMeta("最多触发X次", "最多 触发 次数 上限 条件")]
public sealed class Gate_MaxTriggerCount : MonoBehaviour, IMaterialLogicNode, IMaterialTraversalGate, IMaterialDescriptionProvider
{
    [Min(1)]
    public int MaxTimes = 1;

    [Tooltip("取反：前 X 次不执行，之后执行。")]
    public bool Invert = false;

    [SerializeField, Min(0)]
    private int _passedCount = 0;

    public bool ShouldBreak(in MaterialVommandeTreeContext context)
    {
        if (context.Phase == MaterialTraversePhase.Description) return false;

        // Jam：每场战斗开始重置一次，避免跨战斗残留
        if (context.Phase == MaterialTraversePhase.BattleStart)
        {
            _passedCount = 0;
            return false;
        }

        if (MaxTimes <= 0) return false;

        bool allow = _passedCount < MaxTimes;
        if (Invert) allow = !allow;

        if (allow)
        {
            // 注意：取反模式下 allow=true 代表“超过 X 次之后执行”，这里也会计数，但不影响逻辑（Jam 简化）
            _passedCount += 1;
        }

        return !allow;
    }

    public void AppendDescription(StringBuilder sb)
    {
        if (sb == null) return;
        sb.Append(Invert
            ? $"前 {MaxTimes} 次不执行后续效果（之后执行）"
            : $"最多触发 {MaxTimes} 次后续效果");
    }
}




// === Gameplay\Mask\Gates\Gate_Phase.cs ===
using System.Text;
using UnityEngine;

/// <summary>
/// 通用阶段 Gate：用于把“战斗/绑定/结算”等回调显式做成逻辑树节点。
/// 约定：
/// - 描述阶段不跳出（避免截断文案）
/// - 其它阶段：仅当 context.Phase == Phase 时允许继续执行本分支
/// </summary>
public sealed class Gate_Phase : MonoBehaviour, IMaterialLogicNode, IMaterialTraversalGate, IMaterialDescriptionProvider
{
    [Tooltip("当遍历上下文处于该阶段时，允许执行该分支。")]
    public MaterialTraversePhase Phase = MaterialTraversePhase.BattleStart;

    [Tooltip("取反：当处于该阶段时不执行（其它阶段执行）。")]
    public bool Invert = false;

    public bool ShouldBreak(in MaterialVommandeTreeContext context)
    {
        if (context.Phase == MaterialTraversePhase.Description) return false;
        bool allow = IsPhaseMatch(context.Phase, Phase);
        if (Invert) allow = !allow;
        return !allow;
    }

    private static bool IsPhaseMatch(MaterialTraversePhase actual, MaterialTraversePhase configured)
    {
        if (actual == configured) return true;

        // Legacy 兼容：
        // - 旧配置 AttackModify 视为“玩家/敌人攻击前”
        // - 旧配置 DamageApplied 视为“玩家/敌人攻击后”
        if (configured == MaterialTraversePhase.AttackModify)
        {
            return actual == MaterialTraversePhase.PlayerAttackBefore || actual == MaterialTraversePhase.EnemyAttackBefore;
        }
        if (configured == MaterialTraversePhase.DamageApplied)
        {
            return actual == MaterialTraversePhase.PlayerAttackAfter || actual == MaterialTraversePhase.EnemyAttackAfter;
        }

        // 反向兼容：如果运行时仍在某些节点里用 Legacy 阶段构造上下文，也应当能命中“新阶段 Gate”
        if (actual == MaterialTraversePhase.AttackModify)
        {
            return configured == MaterialTraversePhase.PlayerAttackBefore || configured == MaterialTraversePhase.EnemyAttackBefore;
        }
        if (actual == MaterialTraversePhase.DamageApplied)
        {
            return configured == MaterialTraversePhase.PlayerAttackAfter || configured == MaterialTraversePhase.EnemyAttackAfter;
        }

        return false;
    }

    public void AppendDescription(StringBuilder sb)
    {
        if (sb == null) return;
        var name = Phase switch
        {
            MaterialTraversePhase.Bind => "绑定时",
            MaterialTraversePhase.BattleStart => "战斗开始时",
            MaterialTraversePhase.AttackModify => "攻击前（Legacy：等价于玩家攻击前/敌人攻击前）",
            MaterialTraversePhase.DamageApplied => "攻击后（Legacy：等价于玩家攻击后/敌人攻击后）",
            MaterialTraversePhase.PlayerAttackBefore => "玩家攻击前",
            MaterialTraversePhase.PlayerAttackAfter => "玩家攻击后",
            MaterialTraversePhase.EnemyAttackBefore => "敌人攻击前",
            MaterialTraversePhase.EnemyAttackAfter => "敌人攻击后",
            MaterialTraversePhase.BattleEnd => "战斗结束时",
            MaterialTraversePhase.PersistentGrowth => "持久成长结算时",
            _ => Phase.ToString()
        };

        sb.Append(Invert ? $"{name}不执行后续效果" : $"{name}：");
    }
}




// === Gameplay\Mask\Gates\Gate_RandomChance.cs ===
using System.Text;
using UnityEngine;

/// <summary>
/// Gate：按概率决定是否执行后续分支（否则跳过该分支）。
/// </summary>
public sealed class Gate_RandomChance : MonoBehaviour, IMaterialLogicNode, IMaterialTraversalGate, IMaterialDescriptionProvider
{
    [Range(0f, 1f)]
    [Tooltip("通过概率：0~1。每次触发都会重新抽一次。")]
    public float Chance01 = 0.5f;

    [Tooltip("取反：在未通过时执行（通过时不执行）。")]
    public bool Invert = false;

    public bool ShouldBreak(in MaterialVommandeTreeContext context)
    {
        if (context.Phase == MaterialTraversePhase.Description) return false;
        var c = Mathf.Clamp01(Chance01);
        bool allow = Random.value <= c;
        if (Invert) allow = !allow;
        return !allow;
    }

    public void AppendDescription(StringBuilder sb)
    {
        if (sb == null) return;
        var c = Mathf.Clamp01(Chance01);
        sb.Append(Invert ? $"未触发（{c:P0}）时执行后续效果" : $"{c:P0} 概率执行后续效果");
    }
}




// === Gameplay\Mask\Gates\Gate_WaitEveryX.cs ===
using System.Text;
using UnityEngine;

/// <summary>
/// Wait 节点：进入该 Gate 会计数；每累计到 X 次，放行 1 次并重置计数。
/// 用途：替代“每X次行动/前X次攻击”等依赖外部计数的 Gate，改为本节点自身计数（Jam 简化）。
///
/// 约定：
/// - 在 BattleStart 时自动 Reset（避免跨战斗污染）
/// - Description 阶段不拦截（避免截断文案）
/// </summary>
[MaterialCnMeta("等待每X次触发", "等待 计数 每X 次触发 节点")]
public sealed class Gate_WaitEveryX : MonoBehaviour, IMaterialLogicNode, IMaterialTraversalGate, IMaterialDescriptionProvider
{
    [Min(1)] public int EveryX = 2;
    public bool Invert = false;

    [SerializeField, Min(0)] private int _counter = 0;

    public bool ShouldBreak(in MaterialVommandeTreeContext context)
    {
        if (context.Phase == MaterialTraversePhase.Description) return false;

        // 每场战斗开始重置一次（Bind 阶段也可能使用，但 Jam 默认按战斗维度重置即可）
        if (context.Phase == MaterialTraversePhase.BattleStart)
        {
            _counter = 0;
            return false;
        }

        if (EveryX <= 0) return false;

        _counter += 1;
        bool allow = (_counter >= EveryX);
        if (allow) _counter = 0;

        if (Invert) allow = !allow;
        return !allow;
    }

    public void AppendDescription(StringBuilder sb)
    {
        if (sb == null) return;
        sb.Append(Invert
            ? $"等待每 {EveryX} 次（本节点计数）不执行后续效果"
            : $"等待每 {EveryX} 次（本节点计数）执行后续效果");
    }
}




// === Gameplay\Mask\LogicTree\MaterialActionSideFilter.cs ===
using System;

[Serializable]
public enum MaterialActionSideFilter
{
    Both = 0,
    PlayerOnly = 1,
    EnemyOnly = 2,
}




// === Gameplay\Mask\LogicTree\MaterialLogicNode.cs ===
using System;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// 材料逻辑节点（树状）：条件节点可挂子节点；条件不满足时仅跳过该分支，不影响其它分支。
/// 说明：
/// - 节点可引用同一个组件（组件复用），因为 node 只是“引用 + 结构”。
/// - 具体执行能力由引用的组件接口决定（Gate / BattleStart / AttackModify / DamageApplied / BattleEnd / Bind）。
/// </summary>
[Serializable]
public sealed class MaterialLogicNode
{
    [Tooltip("仅用于编辑器显示/备注，不参与逻辑。")]
    public string Title;

    [Tooltip("编辑器折叠状态（仅用于编辑器显示）。")]
    public bool Expanded = true;

    [Tooltip("节点引用的组件（通常是材料 prefab 上的某个 MonoBehaviour）。")]
    public MonoBehaviour Component;

    [Tooltip("节点角色：Auto=自动推断；Condition=条件节点；Action=行动节点。")]
    public MaterialLogicNodeRole Role = MaterialLogicNodeRole.Auto;

    [Tooltip("行动侧筛选：仅在“行动/攻击事件相关阶段”（AttackModify/DamageApplied）生效。")]
    public MaterialActionSideFilter ActionSide = MaterialActionSideFilter.Both;

    [Tooltip("子节点（条件通过时/行动执行后继续遍历）。")]
    public List<MaterialLogicNode> Children = new();
}




// === Gameplay\Mask\LogicTree\MaterialLogicNodeRole.cs ===
using System;

[Serializable]
public enum MaterialLogicNodeRole
{
    /// <summary>自动：根据 Component 是否实现 IMaterialTraversalGate 推断为 Condition，否则为 Action。</summary>
    Auto = 0,
    Condition = 1,
    Action = 2,
}




// === Gameplay\Mask\LogicTree\Node_Effect.cs ===
using System.Text;
using UnityEngine;

/// <summary>
/// 逻辑节点：负责“注入接口/触发”，并把统一上下文转发给纯效果器（IMaterialEffect / IMaterialAttackInfoEffect）。
/// 该组件应当作为树节点被引用；纯效果器本身不应直接进入树。
/// </summary>
public sealed class Node_Effect : MonoBehaviour,
    IMaterialLogicNode,
    IMaterialBindEffect,
    IMaterialBattleStartEffect,
    IMaterialBattleEndEffect,
    IMaterialDamageAppliedEffect,
    IPersistentGrowthProvider,
    IAttackInfoModifier,
    IMaterialDescriptionProvider
{
    [Tooltip("要执行的纯效果器（必须挂在同一个 MaterialObj 上）。")]
    public MonoBehaviour Effect;

    public void OnBind(in MaterialVommandeTreeContext context)
    {
        TryExecute(in context);
    }

    public void OnBattleStart(FightContext context)
    {
        var ctx = new MaterialVommandeTreeContext(
            MaterialTraversePhase.BattleStart,
            mask: null,
            maskMaterials: null,
            onMaterialBound: null,
            fight: null,
            side: FightSide.None,
            defenderSide: FightSide.None,
            actionNumber: 0,
            attackerAttackNumber: 0,
            attackInfo: default,
            damage: 0f,
            player: null,
            growthDelta: null
        );
        TryExecute(in ctx);
    }

    public void OnBattleEnd(FightContext context)
    {
        var ctx = new MaterialVommandeTreeContext(
            MaterialTraversePhase.BattleEnd,
            mask: null,
            maskMaterials: null,
            onMaterialBound: null,
            fight: null,
            side: FightSide.None,
            defenderSide: FightSide.None,
            actionNumber: context != null ? context.BattleActionCount : 0,
            attackerAttackNumber: 0,
            attackInfo: default,
            damage: 0f,
            player: null,
            growthDelta: null
        );
        TryExecute(in ctx);
    }

    public void OnDamageApplied(FightContext context, FightSide attackerSide, FightSide defenderSide, AttackInfo info, float damage)
    {
        var ctx = new MaterialVommandeTreeContext(
            MaterialTraversePhase.DamageApplied,
            mask: null,
            maskMaterials: null,
            onMaterialBound: null,
            fight: null,
            side: attackerSide,
            defenderSide: defenderSide,
            actionNumber: context != null ? context.CurrentActionNumber : 0,
            attackerAttackNumber: context != null ? context.CurrentAttackerAttackNumber : 0,
            attackInfo: info,
            damage: damage,
            player: null,
            growthDelta: null
        );
        TryExecute(in ctx);
    }

    public void OnCollectPersistentGrowth(Player player, PlayerGrowthDelta delta, FightContext battleContext)
    {
        var ctx = new MaterialVommandeTreeContext(
            MaterialTraversePhase.PersistentGrowth,
            mask: null,
            maskMaterials: null,
            onMaterialBound: null,
            fight: null,
            side: FightSide.None,
            defenderSide: FightSide.None,
            actionNumber: battleContext != null ? battleContext.BattleActionCount : 0,
            attackerAttackNumber: 0,
            attackInfo: default,
            damage: 0f,
            player: null,
            growthDelta: delta
        );
        TryExecute(in ctx);
    }

    public void Modify(ref AttackInfo info, FightContext context)
    {
        if (Effect == null) return;

        // 攻击前上下文：把当前 info 快照塞进 ctx（便于 gate/描述/日志），真正修改走 ref 参数
        // 注意：这里使用“新阶段（玩家/敌人攻击前）”，同时保持 Gate_Phase 对 Legacy 的兼容映射。
        var phase = context != null && context.CurrentAttackerSide == FightSide.Enemy
            ? MaterialTraversePhase.EnemyAttackBefore
            : MaterialTraversePhase.PlayerAttackBefore;

        var ctx = new MaterialVommandeTreeContext(
            phase,
            mask: null,
            maskMaterials: null,
            onMaterialBound: null,
            fight: context,
            side: context != null ? context.CurrentAttackerSide : FightSide.None,
            defenderSide: context != null
                ? (context.CurrentAttackerSide == FightSide.Player ? FightSide.Enemy : FightSide.Player)
                : FightSide.None,
            actionNumber: context != null ? context.CurrentActionNumber : 0,
            attackerAttackNumber: context != null ? context.CurrentAttackerAttackNumber : 0,
            attackInfo: info,
            damage: 0f,
            player: null,
            growthDelta: null
        );

        if (Effect is IMaterialAttackInfoEffect atk)
        {
            atk.Modify(ref info, in ctx);
            return;
        }

        // 允许在“攻击前”触发不修改 AttackInfo 的效果（例如播特效/SFX/计数等）
        // 这能让 Gate_Phase.PlayerAttackBefore 下挂普通 IMaterialEffect 正常工作。
        if (Effect is IMaterialEffect e)
        {
            e.Execute(in ctx);
        }
    }

    private void TryExecute(in MaterialVommandeTreeContext context)
    {
        if (Effect == null) return;
        if (Effect is IMaterialEffect e)
        {
            e.Execute(in context);
        }
    }

    public void AppendDescription(StringBuilder sb)
    {
        if (sb == null) return;
        if (Effect is IMaterialDescriptionProvider p)
        {
            p.AppendDescription(sb);
            return;
        }
        if (Effect != null)
        {
            sb.Append($"执行效果：{Effect.GetType().Name}");
        }
        else
        {
            sb.Append("（未绑定效果器）");
        }
    }
}




// === Gameplay\Player\Player.cs ===
using UnityEngine;

/// <summary>
/// 玩家单例：持有 BaseStats / ActualStats，并可构建 BattleStats。
/// </summary>
public sealed class Player
{
    public static Player I { get; private set; }

    public PlayerStats BaseStats { get; private set; }
    public PlayerStats ActualStats { get; private set; }

    public static void CreateSingleton(PlayerStats baseStats)
    {
        if (I != null) return;
        baseStats.Clamp();
        I = new Player
        {
            BaseStats = baseStats,
            ActualStats = baseStats
        };
    }

    public void ApplyGrowth(PlayerGrowthDelta delta)
    {
        if (delta == null) return;

        var a = ActualStats;
        a.MaxHP += delta.AddMaxHP;
        a.Attack += delta.AddAttack;
        a.Defense += delta.AddDefense;
        a.CritChance += delta.AddCritChance;
        a.CritMultiplier += delta.AddCritMultiplier;
        a.SpeedRate += delta.AddSpeedRate;
        a.Luck += delta.AddLuck;
        a.PenetrationPercent += delta.AddPenetrationPercent;
        a.PenetrationFixed += delta.AddPenetrationFixed;
        a.Clamp();
        ActualStats = a;
    }

    public PlayerStats BuildBattleStats()
    {
        // BattleStats = ActualStats 的复制；材料战斗增益在开战时叠加到 BattleStats（由战斗系统/材料组件修改）。
        return ActualStats;
    }
}




// === Gameplay\Player\PlayerConfigSO.cs ===
using UnityEngine;

[CreateAssetMenu(menuName = "GGJ2026/Player/PlayerConfig", fileName = "PlayerConfig")]
public class PlayerConfigSO : ScriptableObject
{
    public PlayerStats BaseStats;
}





// === Gameplay\Player\PlayerGrowthDelta.cs ===
using System;

[Serializable]
public class PlayerGrowthDelta
{
    public float AddMaxHP;
    public float AddAttack;
    public float AddDefense;
    public float AddCritChance;
    public float AddCritMultiplier;
    public int AddSpeedRate;
    public int AddLuck;
    public float AddPenetrationPercent;
    public float AddPenetrationFixed;
}





// === Gameplay\Player\PlayerStats.cs ===
using System;
using UnityEngine;

[Serializable]
public struct PlayerStats
{
    public float MaxHP;
    public float Attack;
    public float Defense;

    [Range(0f, 1f)] public float CritChance;
    [Min(1f)] public float CritMultiplier;

    [Min(0)] public int SpeedRate;

    [Range(0, 100)] public int Luck;

    /// <summary>百分比穿透（0~1，例如 0.3 表示 30% 穿透）</summary>
    [Range(0f, 1f)] public float PenetrationPercent;

    /// <summary>固定穿透（>=0，直接减少防御值）</summary>
    [Min(0f)] public float PenetrationFixed;

    public void Clamp()
    {
        MaxHP = Mathf.Max(1f, MaxHP);
        Attack = Mathf.Max(0f, Attack);
        Defense = Mathf.Max(0f, Defense);
        CritChance = Mathf.Clamp01(CritChance);
        CritMultiplier = Mathf.Max(1f, CritMultiplier);
        SpeedRate = Mathf.Max(0, SpeedRate);
        Luck = Mathf.Clamp(Luck, 0, 100);
        PenetrationPercent = Mathf.Clamp01(PenetrationPercent);
        PenetrationFixed = Mathf.Max(0f, PenetrationFixed);
    }
}





// === Gameplay\RundMask\RoundFace.cs ===
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class RoundFace : MonoBehaviour
{
    
}


// === Gameplay\Spawn\IMonsterSpawnLogic.cs ===
public interface IMonsterSpawnLogic
{
    /// <summary>
    /// 返回 null 表示本逻辑不处理，交给链路后续逻辑。
    /// roundIndex：第几场战斗（从 0 开始）
    /// </summary>
    CharacterConfig TrySpawn(int roundIndex, FightContext context);
}




// === Gameplay\Spawn\MonsterSpawnSystem.cs ===
using System.Collections.Generic;
using Sirenix.OdinInspector;
using UnityEngine;

/// <summary>
/// 怪物生成系统：内部维护“生成逻辑链”，按顺序尝试生成，返回第一个非空结果。
/// 初始化必须由 GameManager.Awake() 完成。
/// </summary>
public class MonsterSpawnSystem : MonoBehaviour
{
    public static MonsterSpawnSystem I { get; private set; }

    private readonly List<IMonsterSpawnLogic> _logics = new();

    public void Initialize()
    {
        if (I != null && I != this)
        {
            Destroy(gameObject);
            return;
        }
        I = this;

        _logics.Clear();
    
        // Jam 容错：如果没有任何逻辑，就自动挂一个“顺序取列表”的逻辑（由该组件自己持有怪物列表）
        if (_logics.Count == 0)
        {
            var seq= gameObject.AddComponent<JamTestMonsterSpawnLogic>();
            _logics.Add(seq);
        }
    }

    public CharacterConfig Spawn(int roundIndex, FightContext context)
    {
        for (int i = 0; i < _logics.Count; i++)
        {
            var cfg = _logics[i]?.TrySpawn(roundIndex, context);
            if (cfg != null) return cfg;
        }
        return null;
    }
}




// === Gameplay\Spawn\Logics\SequentialEnemySpawnLogic.cs ===


// === JamDefaults\JamDefaultSettings.cs ===
using UnityEngine;

/// <summary>
/// GameJam 默认配置（纯代码，避免创建/维护大量 ScriptableObject 资产）。
/// 约定：
/// - 这里的值就是“当前 Jam 的默认玩法参数”，需要调参就直接改这里。
/// - 正式版再把这些拆回 SO/关卡配置/策划表。
/// </summary>
public static class JamDefaultSettings
{
    // ---- Player ----
    public static PlayerStats DefaultPlayerBaseStats => new PlayerStats
    {
        MaxHP = 120f,
        Attack = 50f,
        Defense = 80f,
        CritChance = 0.10f,
        CritMultiplier = 1.2f,
        SpeedRate = 10,
        Luck = 10,
        PenetrationPercent = 0f,
        PenetrationFixed = 0f
    };

    // ---- Drop ----
    /// <summary>Resources 下材质 prefab 的文件夹名（相对 Resources 根）。</summary>
    public const string ResourcesMatFolder = "Mat";

    /// <summary>每场战斗掉落次数（抽几次）。</summary>
    public const int DropCountPerBattle = 3;

    /// <summary>开局发放的 Common 材质数量（用于第一回合能做面具）。</summary>
    public const int InitialCommonMaterialCount = 4;

    // ---- Persistent Growth (Post Battle) ----
    /// <summary>
    /// 持久成长结算器（战后把 PlayerGrowthDelta 套公式后再实际加到玩家身上）。
    /// Jam 默认实现为“直接加上去”；策划要改成长公式，就改 JamPersistentGrowthCalculator_Default.Apply。
    /// </summary>
    public static readonly IJamPersistentGrowthCalculator PersistentGrowthCalculator = new JamPersistentGrowthCalculator_Default();
}




// === JamDefaults\JamPersistentGrowthCalculator.cs ===
using System.Linq;

/// <summary>
/// 持久成长结算器（Jam 版，纯代码可改公式）。
///
/// 设计目标：
/// - 材料树只负责“往 PlayerGrowthDelta 写入增量”
/// - 战后结算时由这里统一“处理增量/套公式/再实际加到玩家身上”
///
/// 为什么要单独一层：
/// - 避免每个效果器各自 Clamp/倍率/上限，导致规则分散
/// - 策划只需要改这一处的公式，就能整体调平衡
/// </summary>
public interface IJamPersistentGrowthCalculator
{
    /// <summary>
    /// 输入：本场战斗收集到的 delta 与玩家。
    /// 输出：对玩家实际应用（默认实现=直接加），并可在内部 Reset delta（避免误复用）。
    /// </summary>
    void Apply(Player player, PlayerGrowthDelta delta, FightContext fightContext);
}

/// <summary>
/// 默认实现：直接把 delta 加到玩家 ActualStats（等价于 Player.ApplyGrowth）。
/// 策划改公式就改这里。
/// </summary>
public sealed class JamPersistentGrowthCalculator_Default : IJamPersistentGrowthCalculator
{
    public void Apply(Player player, PlayerGrowthDelta delta, FightContext fightContext)
    {
        if (player == null || delta == null) return;

        // 这里就是"公式入口"，你可以在 ApplyGrowth 之前对 delta 做任意处理：
        // - 倍率、上限、衰减
        // - 基于玩家当前 ActualStats 或 battle stats（fightContext.Player）做缩放
        // - 例如：delta.AddAttack = Mathf.Floor(delta.AddAttack * 0.5f);
        var delta2 = new PlayerGrowthDelta();
       int allQuality= 0;
       foreach(var item in GameManager.I.GetMaskLibrary().Last().Materials)
        {
            allQuality += (int)item.Quality;
        }
        int value = allQuality/300;

        delta2.AddAttack = delta.AddAttack*value;
        delta2.AddDefense = delta.AddDefense*value;
        delta2.AddMaxHP = delta.AddMaxHP*value;
        delta2.AddCritChance = delta.AddCritChance*value;
        delta2.AddCritMultiplier = delta.AddCritMultiplier*value;
        delta2.AddSpeedRate = delta.AddSpeedRate*value;
        delta2.AddPenetrationFixed = delta.AddPenetrationFixed*value;
        delta2.AddPenetrationPercent = delta.AddPenetrationPercent*value;
       
        player.ApplyGrowth(delta2);

        // 注意：不再进行 reset，允许成长值累积
        // 如果需要清零，由调用方负责（例如在 GameManager 中创建新的 delta 对象）
    }

    // ---- 辅助方法：统一写 delta（让公式代码更好读）----
    public static void AddAttack(PlayerGrowthDelta delta, float value) { if (delta != null) delta.AddAttack += value; }
    public static void AddDefense(PlayerGrowthDelta delta, float value) { if (delta != null) delta.AddDefense += value; }
    public static void AddMaxHP(PlayerGrowthDelta delta, float value) { if (delta != null) delta.AddMaxHP += value; }
    public static void AddCritChance(PlayerGrowthDelta delta, float value) { if (delta != null) delta.AddCritChance += value; }
    public static void AddCritMultiplier(PlayerGrowthDelta delta, float value) { if (delta != null) delta.AddCritMultiplier += value; }
    public static void AddSpeedRate(PlayerGrowthDelta delta, int value) { if (delta != null) delta.AddSpeedRate += value; }
    public static void AddLuck(PlayerGrowthDelta delta, int value) { if (delta != null) delta.AddLuck += value; }
    public static void AddPenetrationPercent(PlayerGrowthDelta delta, float value) { if (delta != null) delta.AddPenetrationPercent += value; }
    public static void AddPenetrationFixed(PlayerGrowthDelta delta, float value) { if (delta != null) delta.AddPenetrationFixed += value; }

    public static void Reset(PlayerGrowthDelta delta)
    {
        if (delta == null) return;
        delta.AddMaxHP = 0f;
        delta.AddAttack = 0f;
        delta.AddDefense = 0f;
        delta.AddCritChance = 0f;
        delta.AddCritMultiplier = 0f;
        delta.AddSpeedRate = 0;
        delta.AddLuck = 0;
        delta.AddPenetrationPercent = 0f;
        delta.AddPenetrationFixed = 0f;
    }
}




// === UI\PlayerInfoUI.cs ===
using UnityEngine;

/// <summary>
/// 玩家信息 UI：显示玩家的各种数值（当前数值、提升数值、战斗实时数值）。
/// </summary>
public class PlayerInfoUI : MonoBehaviour
{
    public enum DisplayMode
    {
        /// <summary>玩家现在的数值（ActualStats）。</summary>
        Current = 0,
        /// <summary>提升的数值（还未运用，即 PlayerGrowthDelta）。</summary>
        PendingGrowth = 1,
        /// <summary>战斗实时的数值（FightContext.Player）。</summary>
        BattleRuntime = 2,
    }

    [Header("显示模式")]
    [Tooltip("当前显示模式：当前数值、提升数值、战斗实时数值。")]
    [SerializeField] private DisplayMode displayMode = DisplayMode.Current;

    [Header("数值显示框")]
    [Tooltip("最大生命值")]
    [SerializeField] private SmallInfoBox maxHPBox;
    [Tooltip("攻击力")]
    [SerializeField] private SmallInfoBox attackBox;
    [Tooltip("防御力")]
    [SerializeField] private SmallInfoBox defenseBox;
    [Tooltip("暴击率")]
    [SerializeField] private SmallInfoBox critChanceBox;
    [Tooltip("爆伤倍率")]
    [SerializeField] private SmallInfoBox critMultiplierBox;
    [Tooltip("速度成长")]
    [SerializeField] private SmallInfoBox speedRateBox;
    [Tooltip("幸运")]
    [SerializeField] private SmallInfoBox luckBox;
    [Tooltip("百分比穿透")]
    [SerializeField] private SmallInfoBox penetrationPercentBox;
    [Tooltip("固定穿透")]
    [SerializeField] private SmallInfoBox penetrationFixedBox;

    /// <summary>
    /// 设置显示模式并刷新。
    /// </summary>
    public void SetDisplayMode(DisplayMode mode)
    {
        displayMode = mode;
        Refresh();
    }

    /// <summary>
    /// 刷新所有数值显示。
    /// </summary>
    public void Refresh()
    {
        switch (displayMode)
        {
            case DisplayMode.Current:
                RefreshCurrentStats();
                break;
            case DisplayMode.PendingGrowth:
                RefreshPendingGrowth();
                break;
            case DisplayMode.BattleRuntime:
                RefreshBattleRuntime();
                break;
        }
    }

    private void RefreshCurrentStats()
    {
        if (Player.I == null)
        {
            ClearAll();
            return;
        }

        var stats = Player.I.ActualStats;
        RefreshBox(maxHPBox, FormatFloat(stats.MaxHP));
        RefreshBox(attackBox, FormatFloat(stats.Attack));
        RefreshBox(defenseBox, FormatFloat(stats.Defense));
        RefreshBox(critChanceBox, FormatPercent(stats.CritChance));
        RefreshBox(critMultiplierBox, FormatFloat(stats.CritMultiplier, 2));
        RefreshBox(speedRateBox, stats.SpeedRate.ToString());
        RefreshBox(luckBox, stats.Luck.ToString());
        RefreshBox(penetrationPercentBox, FormatPercent(stats.PenetrationPercent));
        RefreshBox(penetrationFixedBox, FormatFloat(stats.PenetrationFixed));
    }

    private void RefreshPendingGrowth()
    {
        // 获取未应用的提升值（从 GameManager 或全局存储）
        // 注意：如果 GameManager 没有存储未应用的提升值，这里需要先添加
        var delta = GetPendingGrowthDelta();
        if (delta == null)
        {
            ClearAll();
            return;
        }

        RefreshBox(maxHPBox, FormatDelta(delta.AddMaxHP));
        RefreshBox(attackBox, FormatDelta(delta.AddAttack));
        RefreshBox(defenseBox, FormatDelta(delta.AddDefense));
        RefreshBox(critChanceBox, FormatDelta(delta.AddCritChance, true));
        RefreshBox(critMultiplierBox, FormatDelta(delta.AddCritMultiplier));
        RefreshBox(speedRateBox, FormatDelta(delta.AddSpeedRate));
        RefreshBox(luckBox, FormatDelta(delta.AddLuck));
        RefreshBox(penetrationPercentBox, FormatDelta(delta.AddPenetrationPercent, true));
        RefreshBox(penetrationFixedBox, FormatDelta(delta.AddPenetrationFixed));
    }

    private void RefreshBattleRuntime()
    {
        var ctx = FightManager.I?.Context;
        if (ctx == null || ctx.Player == null)
        {
            ClearAll();
            return;
        }

        var player = ctx.Player;
        RefreshBox(maxHPBox, FormatFloat(player.MaxHP));
        RefreshBox(attackBox, FormatFloat(player.Attack));
        RefreshBox(defenseBox, FormatFloat(player.Defense));
        RefreshBox(critChanceBox, FormatPercent(player.CritChance));
        RefreshBox(critMultiplierBox, FormatFloat(player.CritMultiplier, 2));
        RefreshBox(speedRateBox, player.SpeedRate.ToString());
        // 战斗运行时无 Luck
        RefreshBox(luckBox, "-");
        RefreshBox(penetrationPercentBox, FormatPercent(player.PenetrationPercent));
        RefreshBox(penetrationFixedBox, FormatFloat(player.PenetrationFixed));
    }

    private void ClearAll()
    {
        RefreshBox(maxHPBox, "-");
        RefreshBox(attackBox, "-");
        RefreshBox(defenseBox, "-");
        RefreshBox(critChanceBox, "-");
        RefreshBox(critMultiplierBox, "-");
        RefreshBox(speedRateBox, "-");
        RefreshBox(luckBox, "-");
        RefreshBox(penetrationPercentBox, "-");
        RefreshBox(penetrationFixedBox, "-");
    }

    private void RefreshBox(SmallInfoBox box, string text)
    {
        if (box != null)
        {
            box.Refresh(text);
        }
    }

    private string FormatFloat(float value, int decimals = 1)
    {
        return value.ToString($"F{decimals}");
    }

    private string FormatPercent(float value)
    {
        return (value * 100f).ToString("F1") + "%";
    }

    private string FormatDelta(float delta, bool isPercent = false)
    {
        if (delta == 0f) return "0";
        string sign = delta > 0f ? "+" : "";
        if (isPercent)
        {
            return sign + (delta * 100f).ToString("F1") + "%";
        }
        return sign + delta.ToString("F1");
    }

    private string FormatDelta(int delta)
    {
        if (delta == 0) return "0";
        string sign = delta > 0 ? "+" : "";
        return sign + delta.ToString();
    }

    /// <summary>
    /// 获取未应用的提升值。
    /// </summary>
    private PlayerGrowthDelta GetPendingGrowthDelta()
    {
        if (GameManager.I != null)
        {
            return GameManager.I.PendingGrowthDelta;
        }
        return null;
    }

    // Unity 生命周期：在 Inspector 中修改 displayMode 时自动刷新
    private void OnValidate()
    {
        if (Application.isPlaying)
        {
            Refresh();
        }
    }
    private void Update(){
        Refresh();
    }
}



// === UI\RoundFace.cs ===
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class RoundFace : MonoBehaviour
{
    public RectTransform center; // 玩家角色的UI锚点
    public float radius = 100f;   // 旋转半径
    public float rotationSpeed = 50f; // 旋转速度
    public GameObject maskPrefab; // 面具预制体

    private List<RectTransform> masks = new List<RectTransform>();

    // 添加新面具并重新分布位置
    public void AddMask()
    {
        GameObject newMask = Instantiate(maskPrefab, transform);
        RectTransform maskRect = newMask.GetComponent<RectTransform>();
        masks.Add(maskRect);
        UpdatePositions();
    }

    private void Update()
    {
        float angleOffset = Time.time * rotationSpeed * Mathf.Deg2Rad;
        int count = masks.Count;
        
        for (int i = 0; i < count; i++)
        {
            float angle = angleOffset + i * (Mathf.PI * 2f / count);
            float x = Mathf.Cos(angle) * radius;
            float y = Mathf.Sin(angle) * radius;
            masks[i].anchoredPosition = new Vector2(x, y) + center.anchoredPosition;
        }
    }

    // 初始化/更新所有面具的分布位置
    private void UpdatePositions()
    {
        int count = masks.Count;
        for (int i = 0; i < count; i++)
        {
            float angle = i * (Mathf.PI * 2f / count);
            float x = Mathf.Cos(angle) * radius;
            float y = Mathf.Sin(angle) * radius;
            masks[i].anchoredPosition = new Vector2(x, y) + center.anchoredPosition;
        }
    }
}

// === UI\Battle\BattleUI.cs ===
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using TMPro;
using UnityEngine;

/// <summary>
/// 战斗阶段 UI：血条/速度条/伤害飘字（纯 UI，不走 WorldSpace）。
/// 依赖：FightManager/FightContext。
/// </summary>
public sealed class BattleUI : MonoBehaviour
{
    [Header("Bars")]
    [SerializeField] private UIBarFillImage playerHPBar;
    [SerializeField] private UIBarFillImage playerSpeedBar;
    [SerializeField] private UIBarFillImage enemyHPBar;
    [SerializeField] private UIBarFillImage enemySpeedBar;

    [Header("Optional Text")]
    [SerializeField] private TextMeshProUGUI playerHPText;
    [SerializeField] private TextMeshProUGUI enemyHPText;
    [SerializeField] private TextMeshProUGUI playerSpeedText;
    [SerializeField] private TextMeshProUGUI enemySpeedText;

    [Header("Damage Text")]
    [SerializeField] private UIDamageText damageTextPrefab;
    [SerializeField] private RectTransform damageTextRoot;
    [SerializeField] private RectTransform playerDamageAnchor;
    [SerializeField] private RectTransform enemyDamageAnchor;

    [SerializeField] private RectTransform playerRect;
    [SerializeField] private RectTransform enemyRect;

    [SerializeField] private Vector2 damageSpawnOffset = new Vector2(0f, 60f);

    [SerializeField] private float attackHitDistance = 50f;

    [Header("Monster Spawn")]
    [Tooltip("怪物 Prefab 池：每次战斗开始时随机选择一个并生成到怪物节点位置。")]
    [SerializeField] private List<GameObject> monsterPrefabs = new List<GameObject>();
    [Tooltip("怪物生成位置节点（Transform 或 RectTransform）。")]
    [SerializeField] private Transform monsterSpawnNode;

    [Header("Monster Kill Drop")]
    [Tooltip("怪物死亡掉落物 Prefab（MonsterKillDrop 组件）。")]
    [SerializeField] private MonsterKillDrop monsterKillDropPrefab;
    [Tooltip("掉落物生成根节点（通常是 Canvas 或 UI 根节点）。")]
    [SerializeField] private Transform dropRoot;

    [SerializeField] private RoundFace roundFace;
    private FightContext _bound;
    private Vector2 _playerInitialPos;
    private Vector2 _enemyInitialPos;
    private Tween _playerAttackTween;
    private Tween _enemyAttackTween;
    private bool _warnedMissingAttackAnimRefs;
    private GameObject _currentMonsterInstance;
    private FightContext _lastSpawnedContext; // 跟踪已为哪个 Context 生成过怪物
    private readonly List<MonsterKillDrop> _activeDrops = new List<MonsterKillDrop>();
    private int _pendingDropCount; // 等待完成的掉落物数量
    private UniTaskCompletionSource _dropAnimationTcs; // 掉落动画完成的 UniTask 信号

    private void OnEnable()
    {
        TryRebind();
    }

    private void OnDisable()
    {
        Unbind();
    }

    private void Update()
    {
        TryRebind();
        RefreshBars();
        
        // 检查是否需要生成怪物（不依赖事件注入）
        if (_bound != null && _bound.Player != null && _bound.Enemy != null)
        {
            TrySpawnMonsterIfNeeded();
        }
    }

    private void TryRebind()
    {
        var fm = FightManager.I;
        var ctx = fm == null ? null : fm.Context;
        if (ctx == _bound) return;
        Bind(ctx);
    }

    private void Bind(FightContext ctx)
    {
        Unbind();
        _bound = ctx;
        if (_bound == null) return;
        _bound.OnDamageApplied += OnDamageApplied;
        _bound.OnBeforePlayerAttack += OnBeforePlayerAttack;
        _bound.OnBeforeEnemyAttack += OnBeforeEnemyAttack;
        _bound.OnBattleEnd += OnBattleEnd;
        // 保存初始位置
        if (playerRect != null) _playerInitialPos = playerRect.anchoredPosition;
        if (enemyRect != null) _enemyInitialPos = enemyRect.anchoredPosition;
        
        // 如果 Context 已存在且有效，立即尝试生成怪物（不等待事件）
        if (_bound != null && _bound.Player != null && _bound.Enemy != null)
        {
            TrySpawnMonsterIfNeeded();
        }
    }

    private void Unbind()
    {
        if (_bound != null)
        {
            _bound.OnDamageApplied -= OnDamageApplied;
            _bound.OnBeforePlayerAttack -= OnBeforePlayerAttack;
            _bound.OnBeforeEnemyAttack -= OnBeforeEnemyAttack;
            _bound.OnBattleEnd -= OnBattleEnd;
        }
        _bound = null;
        _lastSpawnedContext = null;

        // 停止并清理动画
        _playerAttackTween?.Kill();
        _enemyAttackTween?.Kill();
        _playerAttackTween = null;
        _enemyAttackTween = null;

        // 清理怪物实例
        ClearMonsterInstance();
    }

    private void RefreshBars()
    {
        var c = _bound;
        if (c == null || c.Player == null || c.Enemy == null) return;

        var p = c.Player;
        var e = c.Enemy;
        var threshold = Mathf.Max(1, c.ArenaSpeedThreshold);

        var pHp01 = p.MaxHP <= 0f ? 0f : Mathf.Clamp01(p.CurrentHP / p.MaxHP);
        var eHp01 = e.MaxHP <= 0f ? 0f : Mathf.Clamp01(e.CurrentHP / e.MaxHP);
        var pSp01 = Mathf.Clamp01(c.PlayerSpeedValue / threshold);
        var eSp01 = Mathf.Clamp01(c.EnemySpeedValue / threshold);

        if (playerHPBar != null) playerHPBar.SetFill01(pHp01);
        if (enemyHPBar != null) enemyHPBar.SetFill01(eHp01);
        if (playerSpeedBar != null) playerSpeedBar.SetFill01(pSp01);
        if (enemySpeedBar != null) enemySpeedBar.SetFill01(eSp01);

        if (playerHPText != null) playerHPText.text = $"HP {p.CurrentHP:0}/{p.MaxHP:0}";
        if (enemyHPText != null) enemyHPText.text = $"HP {e.CurrentHP:0}/{e.MaxHP:0}";
        if (playerSpeedText != null) playerSpeedText.text = $"{pSp01:P0}";
        if (enemySpeedText != null) enemySpeedText.text = $"{eSp01:P0}";
    }

    private void OnDamageApplied(FightContext ctx, FightSide attackerSide, FightSide defenderSide, AttackInfo info, float damage)
    {
        if (damageTextPrefab == null || damageTextRoot == null) return;

        var anchor = defenderSide == FightSide.Player ? playerDamageAnchor : enemyDamageAnchor;
        if (anchor == null) return;

        var inst = Instantiate(damageTextPrefab, damageTextRoot);
        var rt = inst.transform as RectTransform;
        if (rt != null)
        {
            // 纯 UI：直接用屏幕/世界坐标对齐（同一 Canvas 下最稳妥）
            rt.position = anchor.position;
            rt.anchoredPosition += damageSpawnOffset;
        }

        inst.Play(damage, info.IsCrit);
    }

    private void OnBeforePlayerAttack(FightContext ctx, AttackInfo info)
    {
        // 容错：很多场景只配置了 enemyRect，而没配置 enemyDamageAnchor（飘字锚点）
        // 这会让动画“看起来像回调没触发”。这里做 fallback。
        var target = enemyDamageAnchor != null ? enemyDamageAnchor : enemyRect;
        PlayAttackAnimation(playerRect, target, _playerInitialPos, isPlayer: true);
    }

    private void OnBeforeEnemyAttack(FightContext ctx, AttackInfo info)
    {
        var target = playerDamageAnchor != null ? playerDamageAnchor : playerRect;
        PlayAttackAnimation(enemyRect, target, _enemyInitialPos, isPlayer: false);
    }

    private void PlayAttackAnimation(RectTransform attackerRect, RectTransform targetAnchor, Vector2 initialPos, bool isPlayer)
    {
        if (attackerRect == null || targetAnchor == null)
        {
            if (!_warnedMissingAttackAnimRefs)
            {
                _warnedMissingAttackAnimRefs = true;
                Debug.LogWarning("[BattleUI] 攻击前动画缺少引用：请检查 BattleUI 的 playerRect/enemyRect 以及 playerDamageAnchor/enemyDamageAnchor（可缺锚点但至少要有 Rect）。", this);
            }
            return;
        }

        // 停止之前的动画
        if (isPlayer)
        {
            _playerAttackTween?.Kill();
        }
        else
        {
            _enemyAttackTween?.Kill();
        }

        // 计算目标位置：从目标锚点向攻击者方向偏移 AttackHitDistance
        // 使用世界坐标计算方向
        Vector3 targetWorldPos = targetAnchor.position;
        Vector3 attackerWorldPos = attackerRect.position;
        Vector3 direction = (targetWorldPos - attackerWorldPos).normalized;

        // 将世界坐标转换为本地坐标（相对于父节点）
        RectTransform parent = attackerRect.parent as RectTransform;
        if (parent == null) return;

        Vector3 targetLocalPos3D = parent.InverseTransformPoint(targetWorldPos);
        Vector2 targetLocalPos = new Vector2(targetLocalPos3D.x, targetLocalPos3D.y);

        // 将方向向量转换为本地坐标空间
        Vector3 localDirection3D = parent.InverseTransformDirection(direction);
        Vector2 localDirection = new Vector2(localDirection3D.x, localDirection3D.y).normalized;

        // 计算命中位置：从目标位置向攻击者方向偏移
        float hitDistance = attackHitDistance > 0f ? attackHitDistance : GameSetting.AttackHitDistance;
        Vector2 hitLocalPos = targetLocalPos - localDirection * hitDistance;

        // 动画：去程（50% 时间）+ 回程（50% 时间）
        float halfDuration = GameSetting.AttackTweenTotalSeconds * 0.5f;

        var sequence = DOTween.Sequence()
            .SetUpdate(true) // 即使 TimeScale=0 也能播 UI
            .Append(attackerRect.DOAnchorPos(hitLocalPos, halfDuration).SetEase(Ease.OutQuad))
            .Append(attackerRect.DOAnchorPos(initialPos, halfDuration).SetEase(Ease.InQuad));

        // 根据攻击者类型设置对应的 tween 引用
        if (isPlayer)
        {
            _playerAttackTween = sequence;
            sequence.OnComplete(() => _playerAttackTween = null);
        }
        else
        {
            _enemyAttackTween = sequence;
            sequence.OnComplete(() => _enemyAttackTween = null);
        }
    }
    public void ResetHasCreateMonsterFlag()
    {
        _hasCreateMonsterInThisAttack = false;
    }
    private void OnBattleEnd(FightContext ctx)
    {
        // 先不清理怪物实例，等掉落动画完成后再清理
        // ClearMonsterInstance();
        _lastSpawnedContext = null;
        
        // 重置掉落动画完成信号
        _dropAnimationTcs?.TrySetCanceled();
        _dropAnimationTcs = new UniTaskCompletionSource();
        
        // 生成掉落物
        SpawnDropItems(ctx);
    }
    
    /// <summary>
    /// 等待掉落动画完成（供 GameManager 调用）。
    /// </summary>
    public UniTask WaitForDropAnimationAsync()
    {
        if (_dropAnimationTcs == null)
        {
            // 如果没有掉落动画（可能没有掉落物或 Prefab 未设置），立即完成
            return UniTask.CompletedTask;
        }
        return _dropAnimationTcs.Task;
    }
    
    
    
    private bool _hasCreateMonsterInThisAttack;
    /// <summary>
    /// 检查是否需要生成怪物：如果当前 Context 有效且还没有为它生成过怪物，就生成。
    /// </summary>
    private void TrySpawnMonsterIfNeeded()
    {
        if (_bound == null) return;
        if(_hasCreateMonsterInThisAttack) return;
        // 如果已经为当前 Context 生成过怪物，跳过
        if (_lastSpawnedContext == _bound) return;
        
        // 确保战斗上下文有效（有玩家和敌人）
        if (_bound.Player == null || _bound.Enemy == null) return;
        
        // 生成怪物并记录
        SpawnRandomMonster();
        _lastSpawnedContext = _bound;
    }

    private void SpawnRandomMonster()
    {
        // 先清理之前的怪物
        _hasCreateMonsterInThisAttack = true;
        ClearMonsterInstance();

        // 检查是否有可用的 Prefab
        if (monsterPrefabs == null || monsterPrefabs.Count == 0)
        {
            Debug.LogWarning("[BattleUI] 怪物 Prefab 池为空，无法生成怪物。", this);
            return;
        }

        // 检查生成节点
        if (monsterSpawnNode == null)
        {
            Debug.LogWarning("[BattleUI] 怪物生成节点未设置，无法生成怪物。", this);
            return;
        }

        // 过滤掉 null 的 Prefab
        var validPrefabs = new System.Collections.Generic.List<GameObject>();
        for (int i = 0; i < monsterPrefabs.Count; i++)
        {
            if (monsterPrefabs[i] != null)
            {
                validPrefabs.Add(monsterPrefabs[i]);
            }
        }

        if (validPrefabs.Count == 0)
        {
            Debug.LogWarning("[BattleUI] 怪物 Prefab 池中没有有效的 Prefab。", this);
            return;
        }

        // 随机选择一个 Prefab
        int randomIndex = Random.Range(0, validPrefabs.Count);
        GameObject selectedPrefab = validPrefabs[randomIndex];

        // 实例化到指定位置
        _currentMonsterInstance = Instantiate(selectedPrefab, monsterSpawnNode);
        
        // 重置位置和旋转（确保对齐到生成节点）
        _currentMonsterInstance.transform.localPosition = Vector3.zero;
        _currentMonsterInstance.transform.localRotation = Quaternion.identity;
        _currentMonsterInstance.transform.localScale = Vector3.one;
    }

    private void ClearMonsterInstance()
    {
        if (_currentMonsterInstance != null)
        {
            Destroy(_currentMonsterInstance);
            _currentMonsterInstance = null;
        }
    }

    /// <summary>
    /// 生成掉落物：从怪物位置掉落材料，使用贝塞尔曲线动画。
    /// </summary>
    private void SpawnDropItems(FightContext ctx)
    {
        if (monsterKillDropPrefab == null)
        {
            Debug.LogWarning("[BattleUI] MonsterKillDrop Prefab 未设置，跳过掉落物生成。", this);
            // 如果没有掉落物 Prefab，直接清理怪物并执行掉落逻辑
            ClearMonsterInstance();
            if (GameManager.I != null)
            {
                var directDrops = GameManager.I.GetBattleDrops();
                if (directDrops != null)
                {
                    GameManager.I.AddDropsToInventory(directDrops);
                }
            }
            // 立即完成掉落动画等待
            _dropAnimationTcs?.TrySetResult();
            _dropAnimationTcs = null;
            return;
        }

        if (dropRoot == null)
        {
            Debug.LogWarning("[BattleUI] Drop Root 未设置，使用当前 Transform 作为父节点。", this);
            dropRoot = transform;
        }

        // 获取掉落列表
        var drops = GameManager.I != null ? GameManager.I.GetBattleDrops() : null;
        if (drops == null || drops.Count == 0)
        {
            // 没有掉落物，直接清理
            ClearMonsterInstance();
            return;
        }

        // 获取怪物位置（用于掉落起始点）
        Vector3 monsterPosition = GetMonsterPosition();

        // 统计总掉落物数量
        _pendingDropCount = 0;
        foreach (var entry in drops)
        {
            if (entry != null && entry.MaterialPrefab != null)
            {
                _pendingDropCount += Mathf.Max(0, entry.Count);
            }
        }

        if (_pendingDropCount == 0)
        {
            ClearMonsterInstance();
            // 没有掉落物，立即完成掉落动画等待
            _dropAnimationTcs?.TrySetResult();
            _dropAnimationTcs = null;
            return;
        }

        // 为每个掉落物创建 MonsterKillDrop
        foreach (var entry in drops)
        {
            if (entry == null || entry.MaterialPrefab == null) continue;

            int count = Mathf.Max(0, entry.Count);
            Sprite materialSprite = entry.MaterialPrefab.BaseSprite;

            for (int i = 0; i < count; i++)
            {
                var drop = Instantiate(monsterKillDropPrefab, dropRoot, false);
                _activeDrops.Add(drop);
                
                drop.Initialize(materialSprite, monsterPosition, dropRoot, OnDropComplete);
            }
        }
    }

    /// <summary>
    /// 获取怪物位置（用于掉落起始点）。
    /// </summary>
    private Vector3 GetMonsterPosition()
    {
        // 优先使用怪物实例的位置
        if (_currentMonsterInstance != null)
        {
            return _currentMonsterInstance.transform.position;
        }

        // 回退到怪物生成节点
        if (monsterSpawnNode != null)
        {
            return monsterSpawnNode.position;
        }

        // 最后回退到 enemyRect 或 enemyDamageAnchor
        if (enemyDamageAnchor != null)
        {
            return enemyDamageAnchor.position;
        }

        if (enemyRect != null)
        {
            return enemyRect.position;
        }

        // 默认位置（屏幕中心）
        return new Vector3(Screen.width * 0.5f, Screen.height * 0.5f, 0f);
    }

    List<GameObject> desList=new List<GameObject>();
    /// <summary>
    /// 掉落物动画完成回调。
    /// </summary>
    private void OnDropComplete(MonsterKillDrop drop)
    {
        if (drop != null && _activeDrops.Contains(drop))
        {
            _activeDrops.Remove(drop);
            desList.Add(drop.gameObject);
        }

        _pendingDropCount--;
        
        // 所有掉落物动画完成后，清理怪物并执行掉落逻辑
        if (_pendingDropCount <= 0)
        {
            ClearMonsterInstance();
            
            // 执行掉落逻辑（将材料加入库存）
            if (GameManager.I != null)
            {
                var drops = GameManager.I.GetBattleDrops();
                if (drops != null)
                {
                    GameManager.I.AddDropsToInventory(drops);
                }
            }
            
            // 通知掉落动画完成
            _dropAnimationTcs?.TrySetResult();
            _dropAnimationTcs = null;
            for(int i = 0; i < desList.Count; i++)
            {
                Destroy(desList[i]);
                desList[i] = null;
            }
        }
    }
}


// === UI\Battle\MonsterKillDrop.cs ===
using DG.Tweening;
using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// 怪物死亡掉落物表现类：从怪物位置移动到附近随机点，使用贝塞尔曲线，带有旋转动画。
/// </summary>
public sealed class MonsterKillDrop : MonoBehaviour
{
    [Header("References")]
    [SerializeField] private Image materialImage;
    
    [Header("Drop Animation")]
    [Tooltip("掉落动画持续时间（秒）。")]
    [SerializeField] private float dropDuration = 1.5f;
    [Tooltip("掉落随机范围（从怪物位置向四周随机偏移的最大距离）。")]
    [SerializeField] private Vector2 randomRange = new Vector2(200f, 150f);
    [Tooltip("贝塞尔曲线控制点高度（相对于起始和终点连线的垂直偏移）。")]
    [SerializeField] private float bezierHeight = 100f;
    [Tooltip("Z 轴旋转幅度（随机范围）。")]
    [SerializeField] private float zRotationRange = 15f;
    [Tooltip("Y 轴持续旋转速度（度/秒）。")]
    [SerializeField] private float yRotationSpeed = 180f;

    private RectTransform _rectTransform;
    private Vector3 _startPosition;
    private Vector3 _targetPosition;
    private Tween _moveTween;
    private Tween _yRotationTween;
    private System.Action<MonsterKillDrop> _onComplete;

    private void Awake()
    {
        _rectTransform = GetComponent<RectTransform>();
        if (_rectTransform == null)
        {
            _rectTransform = gameObject.AddComponent<RectTransform>();
        }
    }

    private void OnDestroy()
    {
        _moveTween?.Kill();
        _yRotationTween?.Kill();
    }

    /// <summary>
    /// 初始化掉落物：设置材料 sprite 并开始掉落动画。
    /// </summary>
    /// <param name="materialSprite">材料的 sprite</param>
    /// <param name="startPos">起始位置（怪物位置）</param>
    /// <param name="parent">父节点（通常是 Canvas 或 UI 根节点）</param>
    /// <param name="onComplete">动画完成回调</param>
    public void Initialize(Sprite materialSprite, Vector3 startPos, Transform parent, System.Action<MonsterKillDrop> onComplete = null)
    {
        if (materialImage != null && materialSprite != null)
        {
            materialImage.sprite = materialSprite;
        }

        if (parent != null)
        {
            transform.SetParent(parent, false);
        }

        _startPosition = startPos;
        _onComplete = onComplete;

        // 计算随机目标位置
        CalculateRandomTarget();

        // 设置初始位置和旋转
        if (_rectTransform != null)
        {
            _rectTransform.position = _startPosition;
        }
        
        // 随机 Z 轴旋转
        float randomZRotation = Random.Range(-zRotationRange, zRotationRange);
        transform.rotation = Quaternion.Euler(0f, 0f, randomZRotation);

        // 开始动画
        StartDropAnimation();
    }

    private void CalculateRandomTarget()
    {
        // 在起始位置附近随机一个目标点
        float randomX = Random.Range(-randomRange.x, randomRange.x);
        float randomY = Random.Range(-randomRange.y, randomRange.y);
        _targetPosition = _startPosition + new Vector3(randomX, randomY, 0f);
    }

    private void StartDropAnimation()
    {
        if (_rectTransform == null) return;

        // 贝塞尔曲线移动
        Vector3 p0 = _startPosition;
        Vector3 p2 = _targetPosition;
        Vector3 p1 = (p0 + p2) * 0.5f + Vector3.up * bezierHeight; // 控制点在中间上方

        // 使用 DOTween 的路径动画实现贝塞尔曲线
        _moveTween = DOTween.To(
            () => 0f,
            t =>
            {
                // 二次贝塞尔曲线：B(t) = (1-t)²P₀ + 2(1-t)tP₁ + t²P₂
                float u = 1f - t;
                Vector3 pos = u * u * p0 + 2f * u * t * p1 + t * t * p2;
                _rectTransform.position = pos;
            },
            1f,
            dropDuration
        ).SetEase(Ease.OutQuad).OnComplete(OnDropComplete);

        // Y 轴持续旋转
        float currentY = transform.eulerAngles.y;
        _yRotationTween = DOTween.To(
            () => currentY,
            y =>
            {
                Vector3 euler = transform.eulerAngles;
                euler.y = y;
                transform.eulerAngles = euler;
            },
            currentY + yRotationSpeed * dropDuration,
            dropDuration
        ).SetEase(Ease.Linear);
    }

    private void OnDropComplete()
    {
        _onComplete?.Invoke(this);
    }

    /// <summary>
    /// 手动完成动画（用于提前结束）。
    /// </summary>
    public void Complete()
    {
        _moveTween?.Kill();
        _yRotationTween?.Kill();
        OnDropComplete();
    }
}



// === UI\Battle\PlayerMask.cs ===
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using DG.Tweening;

/// <summary>
/// 玩家面具显示组件：显示当前佩戴面具和面具库中其它面具的环绕效果。
/// </summary>
public sealed class PlayerMask : MonoBehaviour
{
    [Header("中心面具（当前佩戴）")]
    [Tooltip("显示当前佩戴面具的 Image。")]
    [SerializeField] private Image currentMaskImage;

    [Header("环绕配置")]
    [Tooltip("环绕半径（像素）。")]
    [SerializeField] private float orbitRadius = 100f;
    [Tooltip("环绕角速度（度/秒）。")]
    [SerializeField] private float angularSpeed = 45f;
    [Tooltip("环绕面具的 Image 预制体。")]
    [SerializeField] private Image orbitMaskImagePrefab;
    [Tooltip("环绕面具的父节点。")]
    [SerializeField] private Transform orbitRoot;

    private Player _player;
    private readonly List<Image> _orbitImages = new();
    private float _currentAngle;
    private Tween _rotationTween;

    /// <summary>
    /// 初始化：传入 Player 对象。
    /// </summary>
    public void Initialize(Player player)
    {
        _player = player;
        RefreshMaskDisplay();
    }

    private void OnEnable()
    {
        if (_player != null)
        {
            RefreshMaskDisplay();
        }
    }

    private void OnDisable()
    {
        StopRotation();
    }

    private void OnDestroy()
    {
        StopRotation();
        ClearOrbitImages();
    }

    /// <summary>
    /// 刷新面具显示：更新中心面具和环绕面具。
    /// </summary>
    public void RefreshMaskDisplay()
    {
        if (_player == null || GameManager.I == null) return;

        // 更新中心面具（当前佩戴）
        var currentMask = GameManager.I.GetCurrentMask();
        if (currentMaskImage != null && currentMask != null)
        {
            currentMaskImage.sprite = currentMask.DisplaySprite;
        }

        // 更新环绕面具（面具库中其它面具）
        RefreshOrbitMasks();
    }

    private void RefreshOrbitMasks()
    {
        if (GameManager.I == null) return;

        // 获取面具库（排除当前面具）
        var currentMask = GameManager.I.GetCurrentMask();
        var maskLibrary = GameManager.I.GetMaskLibrary();
        if (maskLibrary == null) return;

        // 清理旧的环绕 Image
        ClearOrbitImages();

        // 创建环绕 Image
        if (orbitMaskImagePrefab == null || orbitRoot == null) return;

        int validMaskCount = 0;
        for (int i = 0; i < maskLibrary.Count; i++)
        {
            var mask = maskLibrary[i];
            if (mask == null || mask == currentMask) continue;

            var sprite = mask.DisplaySprite;
            if (sprite == null) continue;

            var img = Instantiate(orbitMaskImagePrefab, orbitRoot, false);
            img.sprite = sprite;
            _orbitImages.Add(img);
            validMaskCount++;
        }

        // 如果有效面具数量 > 0，开始旋转动画
        if (validMaskCount > 0)
        {
            StartRotation();
        }
    }

    private void StartRotation()
    {
        StopRotation();

        if (_orbitImages.Count == 0) return;

        // 计算每个面具的角度间隔
        float angleStep = 360f / _orbitImages.Count;
        _currentAngle = 0f;

        // 使用 DOTween 持续旋转
        _rotationTween = DOTween.To(
            () => _currentAngle,
            angle =>
            {
                _currentAngle = angle;
                UpdateOrbitPositions();
            },
            360f,
            360f / angularSpeed
        )
        .SetLoops(-1, LoopType.Incremental)
        .SetEase(Ease.Linear)
        .SetUpdate(true);
    }

    private void StopRotation()
    {
        _rotationTween?.Kill();
        _rotationTween = null;
    }

    private void UpdateOrbitPositions()
    {
        if (_orbitImages.Count == 0) return;

        float angleStep = 360f / _orbitImages.Count;

        for (int i = 0; i < _orbitImages.Count; i++)
        {
            var img = _orbitImages[i];
            if (img == null || img.transform == null) continue;

            float angle = (_currentAngle + angleStep * i) * Mathf.Deg2Rad;
            Vector2 offset = new Vector2(
                Mathf.Cos(angle) * orbitRadius,
                Mathf.Sin(angle) * orbitRadius
            );

            var rt = img.transform as RectTransform;
            if (rt != null)
            {
                rt.anchoredPosition = offset;
            }
        }
    }

    private void ClearOrbitImages()
    {
        foreach (var img in _orbitImages)
        {
            if (img != null) Destroy(img.gameObject);
        }
        _orbitImages.Clear();
    }
}



// === UI\Battle\UIBarFillImage.cs ===
using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// 给 UI Image 套用 `UI/BarFill` shader，并以材质参数控制 0~1 完整度。
/// 注意：每个 bar 会实例化一份 Material，避免多个 Image 互相串值。
/// </summary>
[RequireComponent(typeof(Image))]
public sealed class UIBarFillImage : MonoBehaviour
{
    private static readonly int Fill01Id = Shader.PropertyToID("_Fill01");
    private static readonly int ReverseId = Shader.PropertyToID("_Reverse");

    [SerializeField] private Image image;
    [Range(0f, 1f)][SerializeField] private float fill01 = 1f;
    [SerializeField] private bool reverse = false;

    private Material _runtimeMat;

    private void Awake()
    {
        if (image == null) image = GetComponent<Image>();
        EnsureMaterial();
        Apply();
    }

    private void OnDestroy()
    {
        if (_runtimeMat != null)
        {
            Destroy(_runtimeMat);
            _runtimeMat = null;
        }
    }

    private void EnsureMaterial()
    {
        if (image == null) return;
        if (_runtimeMat != null) return;

        // 优先用当前 Image 上配置的材质（例如你在 UI 里手动拖了材质）
        var src = image.material;
        if (src == null || src.shader == null || src.shader.name != "UI/BarFill")
        {
            var shader = Shader.Find("UI/BarFill");
            if (shader != null) src = new Material(shader);
        }

        if (src == null) return;

        _runtimeMat = new Material(src);
        image.material = _runtimeMat;
    }

    private void Apply()
    {
        if (_runtimeMat == null) return;
        _runtimeMat.SetFloat(Fill01Id, fill01);
        _runtimeMat.SetFloat(ReverseId, reverse ? 1f : 0f);
    }

    public void SetFill01(float v)
    {
        fill01 = Mathf.Clamp01(v);
        Apply();
    }

    public void SetReverse(bool v)
    {
        reverse = v;
        Apply();
    }
}




// === UI\Battle\UIDamageText.cs ===
using DG.Tweening;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// 纯 UI 伤害飘字：上飘 + 淡出，暴击时红色描边。
/// </summary>
public sealed class UIDamageText : MonoBehaviour
{
    [Header("Refs")]
    [SerializeField] private TextMeshProUGUI text;
    [SerializeField] private CanvasGroup canvasGroup;
    [SerializeField] private Outline outline;
    [SerializeField] private RectTransform rect;

    [Header("Style")]
    [SerializeField] private Color normalTextColor = Color.white;
    [SerializeField] private Color critTextColor = Color.white;
    [SerializeField] private Color critOutlineColor = new Color(1f, 0.2f, 0.2f, 1f);
    [SerializeField] private Vector2 critOutlineDistance = new Vector2(2f, -2f);

    [Header("Anim")]
    [SerializeField] private float floatUp = 60f;
    [SerializeField] private float duration = 0.55f;

    private Tween _tween;

    private void Awake()
    {
        if (rect == null) rect = transform as RectTransform;
        if (text == null) text = GetComponentInChildren<TextMeshProUGUI>();
        if (canvasGroup == null) canvasGroup = GetComponent<CanvasGroup>();
        if (canvasGroup == null) canvasGroup = gameObject.AddComponent<CanvasGroup>();
        if (outline == null) outline = GetComponent<Outline>();
    }

    private void OnDestroy()
    {
        if (_tween != null && _tween.IsActive()) _tween.Kill();
    }

    public void Play(float damage, bool isCrit)
    {
        if (text != null)
        {
            text.text = Mathf.RoundToInt(damage).ToString();
            text.color = isCrit ? critTextColor : normalTextColor;
        }

        if (outline != null)
        {
            outline.enabled = isCrit;
            outline.effectColor = critOutlineColor;
            outline.effectDistance = critOutlineDistance;
        }

        if (canvasGroup != null) canvasGroup.alpha = 1f;

        var startPos = rect != null ? rect.anchoredPosition : Vector2.zero;
        var endPos = startPos + new Vector2(0f, floatUp);

        _tween?.Kill();
        _tween = DOTween.Sequence()
            .SetUpdate(true) // Jam：即使 TimeScale=0 也能播 UI
            .Join(rect.DOAnchorPos(endPos, duration).SetEase(Ease.OutCubic))
            .Join(canvasGroup.DOFade(0f, duration).SetEase(Ease.InQuad))
            .OnComplete(() => Destroy(gameObject));
    }
}




// === UI\MakeMask\ChoicedMaterial.cs ===
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

/// <summary>
/// 面具区域随机生成的“已选材料”UI。
/// 点击后收回到材料库（由 MakeMuskUI 处理）。
/// </summary>
public class ChoicedMaterial : MonoBehaviour, IPointerClickHandler
{
    [SerializeField] private Image image;

    public MaterialObj Material { get; private set; }
    private MakeMuskUI _owner;

    public void Initialize(MakeMuskUI owner, MaterialObj material, Material qualityMat, Material selectedMat)
    {
        _owner = owner;
        Material = material;

        if (image == null) image = GetComponent<Image>();

        var sprite = material != null ? material.BaseSprite : null;
        if (image != null) image.sprite = sprite;


        // 尺寸对齐 sprite
        if (sprite != null)
        {
            var rt = transform as RectTransform;
            if (rt != null)
            {
                rt.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, sprite.rect.width);
                rt.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, sprite.rect.height);
            }
        }
    }


    public void OnPointerClick(PointerEventData eventData)
    {
        _owner?.OnClickChoiced(this);
    }
}





// === UI\MakeMask\InfoNode.cs ===
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class InfoNode : MonoBehaviour
{
    [Header("Sprite Display")]
    [Tooltip("显示材料 的 Image（优先显示）。")]
    [SerializeField] private Image spriteImage;

    [Header("TMP（可选）")]
    [SerializeField] private TextMeshProUGUI nameText;
    [SerializeField] private TextMeshProUGUI descText;
    [SerializeField] private TextMeshProUGUI ttlText;
    [SerializeField] private TextMeshProUGUI costText;

    public void Show(string name, string desc, int remainingTurns)
    {
        Show(name, desc, remainingTurns, null);
    }

    public void Show(string name, string desc, int remainingTurns, Sprite sprite,int cost =0)
    {
        // 优先显示 Sprite
        if (spriteImage != null)
        {
            spriteImage.sprite = sprite;
            spriteImage.gameObject.SetActive(sprite != null);
        }

        // 文本信息（可选）
        if (nameText != null) nameText.text = name ?? string.Empty;
        if (descText != null) descText.text = desc ?? string.Empty;
        if (ttlText != null) ttlText.text = $"保质期：{remainingTurns}";
        if(costText!=null) costText.text = cost.ToString();
    }

    public void Clear()
    {
        if (spriteImage != null)
        {
            spriteImage.sprite = null;
            spriteImage.gameObject.SetActive(false);
        }
        if (nameText != null) nameText.text = string.Empty;
        if (descText != null) descText.text = string.Empty;
        if (ttlText != null) ttlText.text = string.Empty;
    }
}


// === UI\MakeMask\MakeMuskUI.cs ===
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class MakeMuskUI : MonoBehaviour
{
    [Header("Refs")]
    [SerializeField] private InfoNode infoNode;

    [SerializeField] private TextMeshProUGUI CostText;

    [Header("Selected Cost Display")]
    [Tooltip("显示选中材料总消耗的 TMP 文本。")]
    [SerializeField] private TextMeshProUGUI selectedCostText;

    [Header("Mask View")]
    [SerializeField] private Image maskImage;
    [SerializeField] private Sprite baseMaskSprite;
    [SerializeField] private Sprite composedMaskSprite;
    [Tooltip("不同材料数量下的面具 Sprite 列表（按顺序递进）：0个材料取下标0，超过列表长度取最后一个）。")]
    [SerializeField] private List<Sprite> maskSpritesByMaterialCount = new List<Sprite>();

    [Header("Inventory List")]
    [SerializeField] private Transform inventoryContentRoot; // ScrollView Content
    [SerializeField] private MaterialButton materialButtonPrefab;

    [Header("Chosen Area")]
    [SerializeField] private RectTransform chosenSpawnArea;
    [SerializeField] private ChoicedMaterial choicedMaterialPrefab;

    [Header("Buttons")]
    [SerializeField] private Button nextButton;
    [SerializeField] private Button composeButton;

    [Header("Outline Shader Material (UI/AlphaOutline)")]
    [SerializeField] private Material outlineMaterial;

    [Header("Debug")]
    [SerializeField] private bool enableLogs = true;

    private readonly Dictionary<MaterialObj, MaterialButton> _buttons = new();
    private readonly Dictionary<MaterialObj, ChoicedMaterial> _choiced = new();

    private bool _composedOnce;

    private void OnEnable()
    {
        if (nextButton != null) nextButton.onClick.AddListener(OnClickNext);
        if (composeButton != null) composeButton.onClick.AddListener(OnClickCompose);
        if (enableLogs)
        {
            if (composeButton == null) Debug.LogWarning("[MakeMuskUI] composeButton 未绑定。", this);
            if (nextButton == null) Debug.LogWarning("[MakeMuskUI] nextButton 未绑定。", this);
            if (chosenSpawnArea == null) Debug.LogWarning("[MakeMuskUI] chosenSpawnArea 未绑定：仍可选择并合成，但不会生成 ChoicedMaterial UI。", this);
            if (choicedMaterialPrefab == null) Debug.LogWarning("[MakeMuskUI] choicedMaterialPrefab 未绑定：仍可选择并合成，但不会生成 ChoicedMaterial UI。", this);
            if (UnityEngine.EventSystems.EventSystem.current == null) Debug.LogWarning("[MakeMuskUI] 场景中没有 EventSystem，UI 点击/悬停可能无效。", this);
        }

        // UI 兜底：如果 UI 被直接打开但还没创建 CurrentMask，自动补一个
        if (GameManager.I != null && GameManager.I.GetCurrentMask() == null)
        {
            GameManager.I.EnsureCurrentMaskForMakeUI();
        }
        RefreshInventoryUI();
        UpdateNextInteractable();
        UpdateMaskSprite();
        UpdateSelectedCostDisplay();
    }

    private void OnDisable()
    {
        if (nextButton != null) nextButton.onClick.RemoveListener(OnClickNext);
        if (composeButton != null) composeButton.onClick.RemoveListener(OnClickCompose);
    }

    public void RefreshInventoryUI()
    {
        if (inventoryContentRoot == null || materialButtonPrefab == null) return;

        // 清空旧按钮
        foreach (var kv in _buttons)
        {
            if (kv.Value != null) Destroy(kv.Value.gameObject);
        }
        _buttons.Clear();
        // 清空旧“已选”UI
        foreach (var kv in _choiced)
        {
            if (kv.Value != null) Destroy(kv.Value.gameObject);
        }
        _choiced.Clear();

        // 更新选中消耗显示（清空后应该隐藏）
        UpdateSelectedCostDisplay();

        // 按"加入库存顺序"展示：MaterialInventory.Items 的顺序就是加入顺序
        var inv = GameManager.I != null ? GameManager.I.GetMaterialInventoryItems() : null;
        if (inv == null) return;

        for (int i = 0; i < inv.Count; i++)
        {
            var mat = inv[i];
            if (mat == null) continue;

            var btn = Instantiate(materialButtonPrefab, inventoryContentRoot, false);
            btn.Initialize(this, mat, outlineMaterial);
            _buttons[mat] = btn;
        }

        if (infoNode != null) infoNode.Clear();
    }

    public void ShowMaterialInfo(MaterialObj mat)
    {
        if (infoNode == null) return;
        if (mat == null)
        {
            infoNode.Clear();
            return;
        }
        infoNode.gameObject.SetActive(true);
        string name = !string.IsNullOrWhiteSpace(mat.DisplayName) ? mat.DisplayName : mat.name;
        string desc = mat.BuildDescription();
        int ttl = mat.RemainingShelfLifeTurns;
        Sprite sprite = mat.BaseSprite; // 使用材料的 BaseSprite
        infoNode.Show(name, desc, ttl, sprite,mat.ManaCost);
    }
    public void CloseInfo(){
        infoNode.gameObject.SetActive(false);
    }
    public void OnClickMaterialButton(MaterialButton btn)
    {
        if (btn == null || btn.Material == null) return;
        var mat = btn.Material;

        // 已选则忽略（V0：一个材料只能被选中一次）
        if (_choiced.ContainsKey(mat)) return;

        // 检查费用是否足够
        var mask = GameManager.I != null ? GameManager.I.GetCurrentMask() : null;
        if (mask != null)
        {
            int cost = Mathf.Max(0, mat.ManaCost);
            foreach(var choiced in _choiced.Values)
            {
                cost += choiced.Material.ManaCost;
            }
            if (mask.CurrentMana < cost)
            {
                // 费用不足：关闭信息，显示警告，不执行后续逻辑
                CloseInfo();
                GameManager.I?.ShowCostWarning();
                return;
            }
        }

        // 播放点击材料音效
        if (AudioManager.I != null)
        {
            AudioManager.I.PlaySfxOnce(AudioKey.FBX_Click_Met);
        }

        // 生成 ChoicedMaterial（UI），但不移动材料实例（材料仍在库存中）
        ChoicedMaterial c = null;
        if (choicedMaterialPrefab != null && chosenSpawnArea != null)
        {
            c = Instantiate(choicedMaterialPrefab, chosenSpawnArea, false);
            c.Initialize(this, mat, outlineMaterial, outlineMaterial);
        }

        // 即使未配置 choicedMaterialPrefab / chosenSpawnArea，也要记录“已选”，否则 Compose 会认为没选中
        _choiced[mat] = c;

        btn.SetSelected(true);
        ShowMaterialInfo(mat);
        UpdateNextInteractable();
        UpdateSelectedCostDisplay();
    }

    public void OnClickChoiced(ChoicedMaterial c)
    {
        if (c == null || c.Material == null) return;
        var mat = c.Material;

        if (_choiced.Remove(mat))
        {
            Destroy(c.gameObject);
        }

        if (_buttons.TryGetValue(mat, out var btn) && btn != null)
        {
            btn.SetSelected(false);
        }

        UpdateNextInteractable();
        UpdateSelectedCostDisplay();
    }

    private void OnClickCompose()
    {
        if (GameManager.I == null) return;
        var mask = GameManager.I.GetCurrentMask();
        if (mask == null)
        {
            // 再兜底一次：可能是中途被销毁/未创建
            mask = GameManager.I.EnsureCurrentMaskForMakeUI();
            if (mask == null)
            {
                if (enableLogs) Debug.LogWarning("[MakeMuskUI] Compose 失败：当前 Mask 为空（GameManager.GetCurrentMask()）。", this);
                return;
            }
        }

        if (_choiced.Count == 0)
        {
            if (enableLogs) Debug.Log("[MakeMuskUI] Compose：没有已选材料。", this);
            return;
        }

        // 绑定所有已选材料（顺序：按玩家选择顺序。这里用当前字典遍历顺序可能不稳定，V0 先简单实现：按按钮 sibling 顺序绑定）
        // Jam 简化：直接遍历 _choiced 的 key
        var list = new List<MaterialObj>(_choiced.Keys);

        for (int i = 0; i < list.Count; i++)
        {
            var mat = list[i];
            if (mat == null) continue;

            var result = mask.BindMaterial(mat);
            if (result.Success)
            {
                // 播放合成材料音效
                if (AudioManager.I != null)
                {
                    AudioManager.I.PlaySfxOnce(AudioKey.FBX_Compose_Met);
                }
                
                if (enableLogs) Debug.Log($"[MakeMuskUI] Compose 成功：Bind {mat.DisplayName} cost={mat.ManaCost} maskMana={mask.CurrentMana}/{mask.BaseMana}", this);
                // 从库存移除（材料成为面具一部分，不再参与库存结算）
                GameManager.I.RemoveMaterialFromInventory(mat);

                // 删除按钮与已选 UI
                if (_buttons.TryGetValue(mat, out var btn) && btn != null)
                {
                    Destroy(btn.gameObject);
                    _buttons.Remove(mat);
                }
                if (_choiced.TryGetValue(mat, out var cm) && cm != null)
                {
                    Destroy(cm.gameObject);
                }
                _choiced.Remove(mat);

                _composedOnce = true;
            }
            else
            {
                if (enableLogs) Debug.LogWarning($"[MakeMuskUI] Compose 失败：Bind {mat.DisplayName} reason={result.FailReason}", this);
                
                // 如果是费用不足，触发警告动画
                if (result.FailReason == BindFailReason.NotEnoughMana)
                {
                    GameManager.I?.ShowCostWarning();
                }
                
                // 绑定失败：取消选择，材料仍在库存中
                if (_choiced.TryGetValue(mat, out var cm) && cm != null) Destroy(cm.gameObject);
                _choiced.Remove(mat);
                if (_buttons.TryGetValue(mat, out var btn) && btn != null) btn.SetSelected(false);
            }
        }

        // Compose 后为面具分配随机 Sprite
        if (_composedOnce && mask != null)
        {
            GameManager.I?.AssignRandomMaskSprite(mask);
        }

        UpdateMaskSprite();
        UpdateNextInteractable();
        UpdateSelectedCostDisplay();
    }

    private void OnClickNext()
    {
        if (_choiced.Count > 0) return; // 安全：有未处理的已选材料禁止进入战斗
        GameManager.I?.NotifyMakeMaskFinished();
    }

    private void UpdateNextInteractable()
    {
        if (nextButton != null) nextButton.interactable = _choiced.Count == 0;
    }

    private void UpdateMaskSprite()
    {
        if (maskImage == null) return;

        var mask = GameManager.I != null ? GameManager.I.GetCurrentMask() : null;
        
        // 优先使用材料数量对应的 Sprite 列表
        if (mask != null && maskSpritesByMaterialCount != null && maskSpritesByMaterialCount.Count > 0)
        {
            int materialCount = mask.Materials != null ? mask.Materials.Count : 0;
            int spriteIndex = Mathf.Clamp(materialCount, 0, maskSpritesByMaterialCount.Count - 1);
            var sprite = maskSpritesByMaterialCount[spriteIndex];
            if (sprite != null)
            {
                maskImage.sprite = sprite;
                return;
            }
        }

        // 回退：优先使用当前面具的 DisplaySprite
        if (mask != null && mask.DisplaySprite != null)
        {
            maskImage.sprite = mask.DisplaySprite;
            return;
        }

        // 最后回退到旧逻辑
        maskImage.sprite = _composedOnce && composedMaskSprite != null ? composedMaskSprite : baseMaskSprite;
    }
    private void Update(){
        CostText.text = MaskMakeManager.I.CurrentMask.CurrentMana.ToString();
    }

    /// <summary>
    /// 更新选中材料消耗显示：计算当前选中材料的总消耗，如果大于0则显示并更新文本，否则隐藏。
    /// </summary>
    private void UpdateSelectedCostDisplay()
    {
        // 计算当前选中材料的总消耗
        int totalCost = 0;
        foreach (var choiced in _choiced.Values)
        {
            if (choiced != null && choiced.Material != null)
            {
                totalCost += Mathf.Max(0, choiced.Material.ManaCost);
            }
        }

        // 如果消耗大于0，显示并更新文本；否则隐藏
        if (totalCost > 0)
        {
            selectedCostText.gameObject.SetActive(true);
            selectedCostText.text = $"-{totalCost}";
        }
        else
        {
            selectedCostText.gameObject.SetActive(false);
        }
    }
}


// === UI\MakeMask\MaterialButton.cs ===
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

/// <summary>
/// 材料库存中的一个材料实例对应的按钮 UI。
/// </summary>
public class MaterialButton : MonoBehaviour, IPointerClickHandler, IPointerEnterHandler, IPointerExitHandler
{
    [SerializeField] private Image image;

    public MaterialObj Material { get; private set; }
    public bool IsSelected { get; private set; }

    private MakeMuskUI _owner;

    public void Initialize(MakeMuskUI owner, MaterialObj material, Material outlineMat)
    {
        _owner = owner;
        Material = material;
        IsSelected = false;

        if (image == null) image = GetComponent<Image>();

        var sprite = material != null ? material.BaseSprite : null;
        if (image != null) image.sprite = sprite;

    }

    public void SetSelected(bool selected)
    {
        IsSelected = selected;
        gameObject.SetActive(!selected);
    }

    public void OnPointerClick(PointerEventData eventData)
    {
        _owner?.OnClickMaterialButton(this);
        _owner?.CloseInfo();
    }

    public void OnPointerEnter(PointerEventData eventData)
    {
        _owner?.ShowMaterialInfo(Material);
    }

    public void OnPointerExit(PointerEventData eventData)
    {
        _owner?.CloseInfo();
        // no-op
    }
}





// === UI\MakeMask\MeterialNode.cs ===
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MeterialNode : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}


// === UI\MakeMask\PlayerInfoMove.cs ===
using DG.Tweening;
using UnityEngine;
using UnityEngine.EventSystems;

/// <summary>
/// 底部数据区的鼠标悬停动画控制器。
/// 鼠标靠近时移出，鼠标离开时退回。
/// </summary>
public class PlayerInfoMove : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler
{
    [Header("Bottom Data Area")]
    [SerializeField] private RectTransform bottomDataArea; // 底部数据区的 RectTransform
    [SerializeField] private RectTransform showPosition; // 移出到达的位置
    [SerializeField] private RectTransform hidePosition; // 移入到达的位置（隐藏位置）
    [SerializeField] private float animationDuration = 0.3f; // 动画时长

    [Header("Debug")]
    [SerializeField] private bool enableLogs = false;

    private Tween _bottomDataAreaTween; // 底部数据区的动画
    private bool _isBottomDataAreaVisible; // 底部数据区是否可见

    private void OnEnable()
    {
        // 初始化底部数据区位置（隐藏状态）
        InitializeBottomDataArea();
    }

    private void OnDisable()
    {
        // 清理动画
        _bottomDataAreaTween?.Kill();
        _bottomDataAreaTween = null;
    }

    /// <summary>
    /// 初始化底部数据区位置（设置为隐藏位置）
    /// </summary>
    private void InitializeBottomDataArea()
    {
        if (bottomDataArea == null || hidePosition == null)
        {
            if (enableLogs)
            {
                if (bottomDataArea == null) Debug.LogWarning("[PlayerInfoMove] bottomDataArea 未绑定。", this);
                if (hidePosition == null) Debug.LogWarning("[PlayerInfoMove] hidePosition 未绑定。", this);
            }
            return;
        }
        
        // 设置初始位置为隐藏位置
        bottomDataArea.anchoredPosition = hidePosition.anchoredPosition;
        _isBottomDataAreaVisible = false;
    }

    /// <summary>
    /// 显示底部数据区（移出动画）
    /// </summary>
    private void ShowBottomDataArea()
    {
        if (bottomDataArea == null || showPosition == null) return;
        if (_isBottomDataAreaVisible) return; // 已经显示，不需要重复动画

        // 停止当前动画
        _bottomDataAreaTween?.Kill();

        // 移动到显示位置
        _bottomDataAreaTween = bottomDataArea.DOAnchorPos(showPosition.anchoredPosition, animationDuration)
            .SetEase(Ease.OutQuad)
            .SetUpdate(true)
            .OnComplete(() => {
                _isBottomDataAreaVisible = true;
                _bottomDataAreaTween = null;
            });
    }

    /// <summary>
    /// 隐藏底部数据区（移入动画）
    /// </summary>
    private void HideBottomDataArea()
    {
        if (bottomDataArea == null || hidePosition == null) return;
        if (!_isBottomDataAreaVisible) return; // 已经隐藏，不需要重复动画

        // 停止当前动画
        _bottomDataAreaTween?.Kill();

        // 移动到隐藏位置
        _bottomDataAreaTween = bottomDataArea.DOAnchorPos(hidePosition.anchoredPosition, animationDuration)
            .SetEase(Ease.InQuad)
            .SetUpdate(true)
            .OnComplete(() => {
                _isBottomDataAreaVisible = false;
                _bottomDataAreaTween = null;
            });
    }

    /// <summary>
    /// 鼠标进入事件（IPointerEnterHandler）
    /// </summary>
    public void OnPointerEnter(PointerEventData eventData)
    {
        ShowBottomDataArea();
    }

    /// <summary>
    /// 鼠标离开事件（IPointerExitHandler）
    /// </summary>
    public void OnPointerExit(PointerEventData eventData)
    {
        HideBottomDataArea();
    }
}


